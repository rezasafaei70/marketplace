from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.utils.translation import gettext_lazy as _
from django.utils import timezone
import uuid


class UserManager(BaseUserManager):
    def create_user(self, phone_number, password=None, **extra_fields):
        if not phone_number:
            raise ValueError(_('شماره موبایل الزامی است'))
        
        user = self.model(phone_number=phone_number, **extra_fields)
        if password:
            user.set_password(password)
        user.save(using=self._db)
        return user
    
    def create_superuser(self, phone_number, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True)
        
        return self.create_user(phone_number, password, **extra_fields)


class User(AbstractBaseUser, PermissionsMixin):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    phone_number = models.CharField(_('شماره موبایل'), max_length=11, unique=True)
    email = models.EmailField(_('ایمیل'), blank=True, null=True)
    first_name = models.CharField(_('نام'), max_length=30, blank=True)
    last_name = models.CharField(_('نام خانوادگی'), max_length=30, blank=True)
    national_id = models.CharField(_('کد ملی'), max_length=10, blank=True, null=True)
    is_active = models.BooleanField(_('فعال'), default=True)
    is_staff = models.BooleanField(_('کارمند'), default=False)
    date_joined = models.DateTimeField(_('تاریخ عضویت'), default=timezone.now)
    
    objects = UserManager()
    
    USERNAME_FIELD = 'phone_number'
    REQUIRED_FIELDS = []
    
    class Meta:
        verbose_name = _('کاربر')
        verbose_name_plural = _('کاربران')
    
    def get_full_name(self):
        return f"{self.first_name} {self.last_name}".strip()
    
    def get_short_name(self):
        return self.first_name
    
    def __str__(self):
        return self.phone_number


class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    avatar = models.ImageField(_('تصویر پروفایل'), upload_to='avatars/', blank=True, null=True)
    birth_date = models.DateField(_('تاریخ تولد'), blank=True, null=True)
    loyalty_points = models.PositiveIntegerField(_('امتیازهای وفاداری'), default=0)
    
    class Meta:
        verbose_name = _('پروفایل کاربر')
        verbose_name_plural = _('پروفایل‌های کاربران')
    
    def __str__(self):
        return f"پروفایل {self.user.phone_number}"


class Address(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='addresses')
    title = models.CharField(_('عنوان آدرس'), max_length=100)
    province = models.CharField(_('استان'), max_length=100)
    city = models.CharField(_('شهر'), max_length=100)
    postal_code = models.CharField(_('کد پستی'), max_length=10)
    address = models.TextField(_('آدرس کامل'))
    receiver_name = models.CharField(_('نام گیرنده'), max_length=100)
    receiver_phone = models.CharField(_('شماره تماس گیرنده'), max_length=11)
    is_default = models.BooleanField(_('آدرس پیش‌فرض'), default=False)
    
    class Meta:
        verbose_name = _('آدرس')
        verbose_name_plural = _('آدرس‌ها')
    
    def __str__(self):
        return f"{self.title} - {self.user.phone_number}"


class OTP(models.Model):
    phone_number = models.CharField(_('شماره موبایل'), max_length=11)
    code = models.CharField(_('کد یکبار مصرف'), max_length=6)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    expires_at = models.DateTimeField(_('تاریخ انقضا'))
    is_used = models.BooleanField(_('استفاده شده'), default=False)
    
    class Meta:
        verbose_name = _('کد یکبار مصرف')
        verbose_name_plural = _('کدهای یکبار مصرف')
    
    def __str__(self):
        return f"{self.phone_number} - {self.code}"
    
    def is_expired(self):
        return timezone.now() > self.expires_at


class UserSession(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='sessions')
    session_key = models.CharField(_('کلید نشست'), max_length=255)
    ip_address = models.GenericIPAddressField(_('آدرس IP'))
    user_agent = models.TextField(_('مرورگر کاربر'))
    device = models.CharField(_('دستگاه'), max_length=100)
    location = models.CharField(_('موقعیت'), max_length=255, blank=True, null=True)
    last_activity = models.DateTimeField(_('آخرین فعالیت'), auto_now=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    is_active = models.BooleanField(_('فعال'), default=True)
    
    class Meta:
        verbose_name = _('نشست کاربر')
        verbose_name_plural = _('نشست‌های کاربران')
    
    def __str__(self):
        return f"{self.user.phone_number} - {self.device}"


class LoginAttempt(models.Model):
    phone_number = models.CharField(_('شماره موبایل'), max_length=11)
    ip_address = models.GenericIPAddressField(_('آدرس IP'))
    user_agent = models.TextField(_('مرورگر کاربر'))
    timestamp = models.DateTimeField(_('زمان'), auto_now_add=True)
    success = models.BooleanField(_('موفق'), default=False)
    
    class Meta:
        verbose_name = _('تلاش ورود')
        verbose_name_plural = _('تلاش‌های ورود')
    
    def __str__(self):
        status = 'موفق' if self.success else 'ناموفق'
        return f"{self.phone_number} - {status} - {self.timestamp}"



from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'addresses', views.AddressViewSet, basename='address')
router.register(r'sessions', views.UserSessionViewSet, basename='session')

urlpatterns = [
    path('request-otp/', views.request_otp, name='request-otp'),
    path('verify-otp/', views.verify_otp, name='verify-otp'),
    path('profile/', views.UserProfileView.as_view(), name='profile'),
    path('change-password/', views.ChangePasswordView.as_view(), name='change-password'),
    path('', include(router.urls)),
]


from rest_framework import status, viewsets, generics, permissions
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes,action
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework_simplejwt.tokens import RefreshToken
from django.utils import timezone
from django.db.models import Q
from django.contrib.auth import get_user_model
from datetime import timedelta
import random
import uuid
import re

from .models import OTP, UserProfile, Address, UserSession, LoginAttempt
from .serializers import (
    PhoneNumberSerializer, OTPVerificationSerializer, UserSerializer,
    UserProfileSerializer, AddressSerializer, UserSessionSerializer,
    ChangePasswordSerializer
)
from apps.common.utils import send_otp_sms, get_client_ip, parse_user_agent

User = get_user_model()


@api_view(['POST'])
@permission_classes([AllowAny])
def request_otp(request):
    serializer = PhoneNumberSerializer(data=request.data)
    if serializer.is_valid():
        phone_number = serializer.validated_data['phone_number']
        
        # محدودیت تعداد درخواست OTP
        recent_otps = OTP.objects.filter(
            phone_number=phone_number,
            created_at__gt=timezone.now() - timedelta(minutes=10)
        )
        
        if recent_otps.count() >= 5:
            return Response(
                {'error': 'تعداد درخواست‌های شما بیش از حد مجاز است. لطفا بعدا تلاش کنید.'},
                status=status.HTTP_429_TOO_MANY_REQUESTS
            )
        
        # ایجاد کد OTP
        code = ''.join([str(random.randint(0, 9)) for _ in range(6)])
        expires_at = timezone.now() + timedelta(minutes=2)
        
        # ذخیره OTP در دیتابیس
        OTP.objects.create(
            phone_number=phone_number,
            code=code,
            expires_at=expires_at
        )
        
        # ارسال پیامک
        send_otp_sms(phone_number, code)
        
        return Response({'message': 'کد تایید برای شما ارسال شد'}, status=status.HTTP_200_OK)
    
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@permission_classes([AllowAny])
def verify_otp(request):
    serializer = OTPVerificationSerializer(data=request.data)
    if serializer.is_valid():
        phone_number = serializer.validated_data['phone_number']
        otp = serializer.validated_data['otp']
        
        # ثبت تلاش ورود
        ip_address = get_client_ip(request)
        user_agent = request.META.get('HTTP_USER_AGENT', '')
        
        # کد OTP را استفاده شده علامت‌گذاری می‌کنیم
        otp.is_used = True
        otp.save()
        
        # بررسی وجود کاربر یا ایجاد کاربر جدید
        user, created = User.objects.get_or_create(phone_number=phone_number)
        
        # ایجاد پروفایل در صورت عدم وجود
        if created:
            UserProfile.objects.create(user=user)
        
        # ثبت نشست کاربر
        device_info = parse_user_agent(user_agent)
        UserSession.objects.create(
            user=user,
            session_key=str(uuid.uuid4()),
            ip_address=ip_address,
            user_agent=user_agent,
            device=device_info.get('device', 'نامشخص')
        )
        
        # ثبت ورود موفق
        LoginAttempt.objects.create(
            phone_number=phone_number,
            ip_address=ip_address,
            user_agent=user_agent,
            success=True
        )
        
        # تولید توکن JWT
        refresh = RefreshToken.for_user(user)
        
        return Response({
            'refresh': str(refresh),
            'access': str(refresh.access_token),
            'user': UserSerializer(user).data,
            'is_new_user': created
        }, status=status.HTTP_200_OK)
    
    # ثبت تلاش ناموفق
    if 'phone_number' in request.data:
        LoginAttempt.objects.create(
            phone_number=request.data['phone_number'],
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
            success=False
        )
    
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class UserProfileView(generics.RetrieveUpdateAPIView):
    permission_classes = [IsAuthenticated]
    serializer_class = UserProfileSerializer
    
    def get_object(self):
        return UserProfile.objects.get(user=self.request.user)
    
    def update(self, request, *args, **kwargs):
        instance = self.get_object()
        user_data = request.data.pop('user', {})
        
        # به‌روزرسانی اطلاعات کاربر
        user = instance.user
        if 'email' in user_data:
            user.email = user_data['email']
        if 'first_name' in user_data:
            user.first_name = user_data['first_name']
        if 'last_name' in user_data:
            user.last_name = user_data['last_name']
        user.save()
        
        # به‌روزرسانی پروفایل
        return super().update(request, *args, **kwargs)


class AddressViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    serializer_class = AddressSerializer
    
    def get_queryset(self):
        return Address.objects.filter(user=self.request.user)


class UserSessionViewSet(viewsets.ReadOnlyModelViewSet):
    permission_classes = [IsAuthenticated]
    serializer_class = UserSessionSerializer
    
    def get_queryset(self):
        return UserSession.objects.filter(user=self.request.user, is_active=True)
    
    @action(detail=True, methods=['post'])
    def terminate(self, request, pk=None):
        try:
            session = UserSession.objects.get(pk=pk, user=request.user)
            session.is_active = False
            session.save()
            return Response({'message': 'نشست با موفقیت خاتمه یافت'}, status=status.HTTP_200_OK)
        except UserSession.DoesNotExist:
            return Response({'error': 'نشست یافت نشد'}, status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=False, methods=['post'])
    def terminate_all_except_current(self, request):
        current_session_key = request.session.session_key
        UserSession.objects.filter(user=request.user).exclude(session_key=current_session_key).update(is_active=False)
        return Response({'message': 'تمام نشست‌های دیگر با موفقیت خاتمه یافتند'}, status=status.HTTP_200_OK)


class ChangePasswordView(generics.GenericAPIView):
    permission_classes = [IsAuthenticated]
    serializer_class = ChangePasswordSerializer
    
    def post(self, request):
        serializer = self.get_serializer(data=request.data)
        if serializer.is_valid():
            user = request.user
            user.set_password(serializer.validated_data['new_password'])
            user.save()
            
            # خاتمه دادن به تمام نشست‌های کاربر به جز نشست فعلی
            current_session_key = request.session.session_key
            UserSession.objects.filter(user=user).exclude(session_key=current_session_key).update(is_active=False)
            
            return Response({'message': 'رمز عبور با موفقیت تغییر یافت'}, status=status.HTTP_200_OK)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


from rest_framework import serializers
from django.utils import timezone
from django.contrib.auth import get_user_model
from datetime import timedelta
import random
from .models import OTP, UserProfile, Address, UserSession
from apps.common.utils import send_otp_sms

User = get_user_model()


class PhoneNumberSerializer(serializers.Serializer):
    phone_number = serializers.CharField(max_length=11)
    
    def validate_phone_number(self, value):
        if not value.isdigit() or len(value) != 11 or not value.startswith('09'):
            raise serializers.ValidationError('شماره موبایل معتبر نیست')
        return value


class OTPVerificationSerializer(serializers.Serializer):
    phone_number = serializers.CharField(max_length=11)
    code = serializers.CharField(max_length=6)
    
    def validate(self, data):
        phone_number = data.get('phone_number')
        code = data.get('code')
        
        try:
            otp = OTP.objects.filter(
                phone_number=phone_number,
                code=code,
                is_used=False,
                expires_at__gt=timezone.now()
            ).latest('created_at')
        except OTP.DoesNotExist:
            raise serializers.ValidationError('کد وارد شده نامعتبر است یا منقضی شده است')
        
        data['otp'] = otp
        return data


class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'phone_number', 'email', 'first_name', 'last_name', 'date_joined')
        read_only_fields = ('id', 'phone_number', 'date_joined')


class UserProfileSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True)
    
    class Meta:
        model = UserProfile
        fields = ('user', 'avatar', 'birth_date', 'loyalty_points')
        read_only_fields = ('loyalty_points',)


class AddressSerializer(serializers.ModelSerializer):
    class Meta:
        model = Address
        fields = ('id', 'title', 'province', 'city', 'postal_code', 'address',
                  'receiver_name', 'receiver_phone', 'is_default')
        read_only_fields = ('id',)
    
    def create(self, validated_data):
        user = self.context['request'].user
        if validated_data.get('is_default', False):
            # اگر آدرس جدید پیش‌فرض باشد، سایر آدرس‌های پیش‌فرض را غیرفعال کنیم
            Address.objects.filter(user=user, is_default=True).update(is_default=False)
        
        validated_data['user'] = user
        return super().create(validated_data)
    
    def update(self, instance, validated_data):
        if validated_data.get('is_default', False) and not instance.is_default:
            # اگر آدرس به پیش‌فرض تغییر کند، سایر آدرس‌های پیش‌فرض را غیرفعال کنیم
            Address.objects.filter(user=instance.user, is_default=True).update(is_default=False)
        
        return super().update(instance, validated_data)


class UserSessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = UserSession
        fields = ('id', 'device', 'ip_address', 'location', 'last_activity', 'created_at')
        read_only_fields = fields


class ChangePasswordSerializer(serializers.Serializer):
    old_password = serializers.CharField(required=True)
    new_password = serializers.CharField(required=True, min_length=8)
    
    def validate_old_password(self, value):
        user = self.context['request'].user
        if not user.check_password(value):
            raise serializers.ValidationError('رمز عبور فعلی اشتباه است')
        return value


from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
import uuid


class PageView(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL,
                           related_name='page_views', null=True, blank=True)
    session_id = models.CharField(_('شناسه نشست'), max_length=100)
    url = models.URLField(_('آدرس صفحه'))
    page_title = models.CharField(_('عنوان صفحه'), max_length=255, blank=True)
    referrer = models.URLField(_('ارجاع‌دهنده'), blank=True, null=True)
    user_agent = models.TextField(_('مرورگر کاربر'), blank=True)
    ip_address = models.GenericIPAddressField(_('آدرس IP'))
    device_type = models.CharField(_('نوع دستگاه'), max_length=50, blank=True)
    os = models.CharField(_('سیستم عامل'), max_length=50, blank=True)
    browser = models.CharField(_('مرورگر'), max_length=50, blank=True)
    created_at = models.DateTimeField(_('تاریخ بازدید'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('بازدید صفحه')
        verbose_name_plural = _('بازدیدهای صفحه')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.url} - {self.created_at}"


class ProductView(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey('products.Product', on_delete=models.CASCADE, related_name='views')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL,
                           related_name='product_views', null=True, blank=True)
    session_id = models.CharField(_('شناسه نشست'), max_length=100)
    ip_address = models.GenericIPAddressField(_('آدرس IP'))
    referrer = models.URLField(_('ارجاع‌دهنده'), blank=True, null=True)
    created_at = models.DateTimeField(_('تاریخ بازدید'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('بازدید محصول')
        verbose_name_plural = _('بازدیدهای محصول')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.product.name} - {self.created_at}"


class SearchQuery(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    query = models.CharField(_('عبارت جستجو'), max_length=255)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL,
                           related_name='search_queries', null=True, blank=True)
    session_id = models.CharField(_('شناسه نشست'), max_length=100)
    results_count = models.IntegerField(_('تعداد نتایج'), default=0)
    category = models.ForeignKey('categories.Category', on_delete=models.SET_NULL,
                               related_name='search_queries', null=True, blank=True)
    created_at = models.DateTimeField(_('تاریخ جستجو'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('جستجو')
        verbose_name_plural = _('جستجوها')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.query} - {self.created_at}"


class CartEvent(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    cart = models.ForeignKey('orders.Cart', on_delete=models.CASCADE, related_name='events')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL,
                           related_name='cart_events', null=True, blank=True)
    session_id = models.CharField(_('شناسه نشست'), max_length=100)
    event_type_choices = [
        ('create', _('ایجاد سبد')),
        ('add', _('افزودن محصول')),
        ('remove', _('حذف محصول')),
        ('update', _('به‌روزرسانی تعداد')),
        ('clear', _('خالی کردن سبد')),
        ('checkout', _('تکمیل خرید')),
        ('abandon', _('رها کردن سبد')),
    ]
    event_type = models.CharField(_('نوع رویداد'), max_length=20, choices=event_type_choices)
    product = models.ForeignKey('products.Product', on_delete=models.SET_NULL,
                              related_name='cart_events', null=True, blank=True)
    quantity = models.PositiveIntegerField(_('تعداد'), null=True, blank=True)
    created_at = models.DateTimeField(_('تاریخ رویداد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('رویداد سبد خرید')
        verbose_name_plural = _('رویدادهای سبد خرید')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.get_event_type_display()} - {self.created_at}"


class UserActivity(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='activities')
    activity_type_choices = [
        ('login', _('ورود')),
        ('logout', _('خروج')),
        ('register', _('ثبت نام')),
        ('password_change', _('تغییر رمز عبور')),
        ('profile_update', _('به‌روزرسانی پروفایل')),
        ('order_create', _('ایجاد سفارش')),
        ('order_payment', _('پرداخت سفارش')),
        ('review_submit', _('ثبت نظر')),
        ('wishlist_add', _('افزودن به علاقه‌مندی‌ها')),
        ('wishlist_remove', _('حذف از علاقه‌مندی‌ها')),
    ]
    activity_type = models.CharField(_('نوع فعالیت'), max_length=20, choices=activity_type_choices)
    ip_address = models.GenericIPAddressField(_('آدرس IP'))
    user_agent = models.TextField(_('مرورگر کاربر'), blank=True)
    object_id = models.CharField(_('شناسه شیء'), max_length=100, blank=True, null=True)
    description = models.TextField(_('توضیحات'), blank=True)
    created_at = models.DateTimeField(_('تاریخ فعالیت'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('فعالیت کاربر')
        verbose_name_plural = _('فعالیت‌های کاربر')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.get_activity_type_display()} - {self.created_at}"


class SalesReport(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    date = models.DateField(_('تاریخ'))
    total_sales = models.DecimalField(_('مجموع فروش'), max_digits=15, decimal_places=0, default=0)
    total_orders = models.PositiveIntegerField(_('تعداد سفارش‌ها'), default=0)
    average_order_value = models.DecimalField(_('میانگین ارزش سفارش'), max_digits=15, decimal_places=0, default=0)
    total_discount = models.DecimalField(_('مجموع تخفیف'), max_digits=15, decimal_places=0, default=0)
    total_shipping = models.DecimalField(_('مجموع هزینه ارسال'), max_digits=15, decimal_places=0, default=0)
    total_tax = models.DecimalField(_('مجموع مالیات'), max_digits=15, decimal_places=0, default=0)
    total_refund = models.DecimalField(_('مجموع برگشتی'), max_digits=15, decimal_places=0, default=0)
    net_sales = models.DecimalField(_('فروش خالص'), max_digits=15, decimal_places=0, default=0)
    
    class Meta:
        verbose_name = _('گزارش فروش')
        verbose_name_plural = _('گزارش‌های فروش')
        ordering = ['-date']
        unique_together = ('date',)
    
    def __str__(self):
        return f"گزارش فروش {self.date}"


class ProductPerformance(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey('products.Product', on_delete=models.CASCADE, related_name='performances')
    date = models.DateField(_('تاریخ'))
    views = models.PositiveIntegerField(_('بازدیدها'), default=0)
    add_to_carts = models.PositiveIntegerField(_('افزودن به سبد'), default=0)
    purchases = models.PositiveIntegerField(_('خریدها'), default=0)
    revenue = models.DecimalField(_('درآمد'), max_digits=15, decimal_places=0, default=0)
    conversion_rate = models.FloatField(_('نرخ تبدیل'), default=0)
    
    class Meta:
        verbose_name = _('عملکرد محصول')
        verbose_name_plural = _('عملکرد محصولات')
        ordering = ['-date']
        unique_together = ('product', 'date')
    
    def __str__(self):
        return f"عملکرد {self.product.name} - {self.date}"


from rest_framework import serializers
from .models import (
    PageView, ProductView, SearchQuery, CartEvent,
    UserActivity, SalesReport, ProductPerformance
)


class PageViewSerializer(serializers.ModelSerializer):
    class Meta:
        model = PageView
        fields = ('id', 'user', 'session_id', 'url', 'page_title', 'referrer',
                 'user_agent', 'ip_address', 'device_type', 'os', 'browser', 'created_at')
        read_only_fields = ('id', 'created_at')


class ProductViewSerializer(serializers.ModelSerializer):
    product_name = serializers.CharField(source='product.name', read_only=True)
    
    class Meta:
        model = ProductView
        fields = ('id', 'product', 'product_name', 'user', 'session_id',
                 'ip_address', 'referrer', 'created_at')
        read_only_fields = ('id', 'created_at')


class SearchQuerySerializer(serializers.ModelSerializer):
    class Meta:
        model = SearchQuery
        fields = ('id', 'query', 'user', 'session_id', 'results_count',
                 'category', 'created_at')
        read_only_fields = ('id', 'created_at')


class CartEventSerializer(serializers.ModelSerializer):
    event_type_display = serializers.CharField(source='get_event_type_display', read_only=True)
    product_name = serializers.CharField(source='product.name', read_only=True)
    
    class Meta:
        model = CartEvent
        fields = ('id', 'cart', 'user', 'session_id', 'event_type', 'event_type_display',
                 'product', 'product_name', 'quantity', 'created_at')
        read_only_fields = ('id', 'created_at')


class UserActivitySerializer(serializers.ModelSerializer):
    user_name = serializers.CharField(source='user.get_full_name', read_only=True)
    activity_type_display = serializers.CharField(source='get_activity_type_display', read_only=True)
    
    class Meta:
        model = UserActivity
        fields = ('id', 'user', 'user_name', 'activity_type', 'activity_type_display',
                 'ip_address', 'user_agent', 'object_id', 'description', 'created_at')
        read_only_fields = ('id', 'created_at')


class SalesReportSerializer(serializers.ModelSerializer):
    class Meta:
        model = SalesReport
        fields = ('id', 'date', 'total_sales', 'total_orders', 'average_order_value',
                 'total_discount', 'total_shipping', 'total_tax', 'total_refund', 'net_sales')
        read_only_fields = fields


class ProductPerformanceSerializer(serializers.ModelSerializer):
    product_name = serializers.CharField(source='product.name', read_only=True)
    
    class Meta:
        model = ProductPerformance
        fields = ('id', 'product', 'product_name', 'date', 'views', 'add_to_carts',
                 'purchases', 'revenue', 'conversion_rate')
        read_only_fields = fields


class TrackPageViewSerializer(serializers.Serializer):
    url = serializers.URLField()
    page_title = serializers.CharField(required=False, allow_blank=True)
    referrer = serializers.URLField(required=False, allow_null=True)
    user_agent = serializers.CharField(required=False, allow_blank=True)
    
    def create(self, validated_data):
        request = self.context.get('request')
        user = request.user if request.user.is_authenticated else None
        session_id = request.session.session_key or 'anonymous'
        ip_address = self._get_client_ip(request)
        
        # تشخیص نوع دستگاه، سیستم عامل و مرورگر
        user_agent = validated_data.get('user_agent', '')
        device_type, os, browser = self._parse_user_agent(user_agent)
        
        page_view = PageView.objects.create(
            user=user,
            session_id=session_id,
            url=validated_data['url'],
            page_title=validated_data.get('page_title', ''),
            referrer=validated_data.get('referrer'),
            user_agent=user_agent,
            ip_address=ip_address,
            device_type=device_type,
            os=os,
            browser=browser
        )
        
        return page_view
    
    def _get_client_ip(self, request):
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR', '0.0.0.0')
        return ip
    
    def _parse_user_agent(self, user_agent):
        # این تابع می‌تواند با استفاده از کتابخانه‌های تشخیص user-agent پیاده‌سازی شود
        # برای سادگی، یک پیاده‌سازی ساده ارائه می‌دهیم
        device_type = 'unknown'
        os = 'unknown'
        browser = 'unknown'
        
        user_agent = user_agent.lower()
        
        # تشخیص نوع دستگاه
        if 'mobile' in user_agent or 'android' in user_agent or 'iphone' in user_agent:
            device_type = 'mobile'
        elif 'tablet' in user_agent or 'ipad' in user_agent:
            device_type = 'tablet'
        else:
            device_type = 'desktop'
        
        # تشخیص سیستم عامل
        if 'windows' in user_agent:
            os = 'Windows'
        elif 'mac os' in user_agent or 'macos' in user_agent:
            os = 'MacOS'
        elif 'linux' in user_agent:
            os = 'Linux'
        elif 'android' in user_agent:
            os = 'Android'
        elif 'ios' in user_agent or 'iphone' in user_agent or 'ipad' in user_agent:
            os = 'iOS'
        
        # تشخیص مرورگر
        if 'chrome' in user_agent and 'edge' not in user_agent:
            browser = 'Chrome'
        elif 'firefox' in user_agent:
            browser = 'Firefox'
        elif 'safari' in user_agent and 'chrome' not in user_agent:
            browser = 'Safari'
        elif 'edge' in user_agent:
            browser = 'Edge'
        elif 'opera' in user_agent or 'opr' in user_agent:
            browser = 'Opera'
        
        return device_type, os, browser


class TrackProductViewSerializer(serializers.Serializer):
    product_id = serializers.UUIDField()
    referrer = serializers.URLField(required=False, allow_null=True)
    
    def create(self, validated_data):
        request = self.context.get('request')
        user = request.user if request.user.is_authenticated else None
        session_id = request.session.session_key or 'anonymous'
        ip_address = self._get_client_ip(request)
        
        from apps.products.models import Product
        try:
            product = Product.objects.get(id=validated_data['product_id'])
        except Product.DoesNotExist:
            raise serializers.ValidationError('محصول مورد نظر یافت نشد')
        
        product_view = ProductView.objects.create(
            product=product,
            user=user,
            session_id=session_id,
            ip_address=ip_address,
            referrer=validated_data.get('referrer')
        )
        
        return product_view
    
    def _get_client_ip(self, request):
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR', '0.0.0.0')
        return ip


class TrackSearchQuerySerializer(serializers.Serializer):
    query = serializers.CharField()
    results_count = serializers.IntegerField(required=False, default=0)
    category_id = serializers.UUIDField(required=False, allow_null=True)
    
    def create(self, validated_data):
        request = self.context.get('request')
        user = request.user if request.user.is_authenticated else None
        session_id = request.session.session_key or 'anonymous'
        
        category = None
        if validated_data.get('category_id'):
            from apps.categories.models import Category
            try:
                category = Category.objects.get(id=validated_data['category_id'])
            except Category.DoesNotExist:
                pass
        
        search_query = SearchQuery.objects.create(
            query=validated_data['query'],
            user=user,
            session_id=session_id,
            results_count=validated_data.get('results_count', 0),
            category=category
        )
        
        return search_query


class TrackCartEventSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()
    event_type = serializers.ChoiceField(choices=CartEvent.event_type_choices)
    product_id = serializers.UUIDField(required=False, allow_null=True)
    quantity = serializers.IntegerField(required=False, allow_null=True)
    
    def create(self, validated_data):
        request = self.context.get('request')
        user = request.user if request.user.is_authenticated else None
        session_id = request.session.session_key or 'anonymous'
        
        from apps.orders.models import Cart
        try:
            cart = Cart.objects.get(id=validated_data['cart_id'])
        except Cart.DoesNotExist:
            raise serializers.ValidationError('سبد خرید مورد نظر یافت نشد')
        
        product = None
        if validated_data.get('product_id'):
            from apps.products.models import Product
            try:
                product = Product.objects.get(id=validated_data['product_id'])
            except Product.DoesNotExist:
                raise serializers.ValidationError('محصول مورد نظر یافت نشد')
        
        cart_event = CartEvent.objects.create(
            cart=cart,
            user=user,
            session_id=session_id,
            event_type=validated_data['event_type'],
            product=product,
            quantity=validated_data.get('quantity')
        )
        
        return cart_event


from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'admin/page-views', views.AdminPageViewViewSet)
router.register(r'admin/search-queries', views.AdminSearchQueryViewSet)
router.register(r'admin/user-activities', views.AdminUserActivityViewSet)
router.register(r'admin/sales-reports', views.AdminSalesReportViewSet)
router.register(r'admin/product-performances', views.AdminProductPerformanceViewSet)

urlpatterns = [
    path('', include(router.urls)),
    path('track/page-view/', views.TrackPageViewView.as_view(), name='track-page-view'),
    path('track/product-view/', views.TrackProductViewView.as_view(), name='track-product-view'),
    path('track/search-query/', views.TrackSearchQueryView.as_view(), name='track-search-query'),
    path('track/cart-event/', views.TrackCartEventView.as_view(), name='track-cart-event'),
    path('admin/dashboard/', views.AdminDashboardView.as_view(), name='admin-dashboard'),
]


from rest_framework import viewsets, permissions, status, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db.models import Count, Sum, Avg, F, Q
from django.db.models.functions import TruncDate, TruncMonth, TruncWeek
from django.utils import timezone
from datetime import timedelta
import pandas as pd

from .models import (
    PageView, ProductView, SearchQuery, CartEvent,
    UserActivity, SalesReport, ProductPerformance
)
from .serializers import (
    PageViewSerializer, ProductViewSerializer, SearchQuerySerializer,
    CartEventSerializer, UserActivitySerializer, SalesReportSerializer,
    ProductPerformanceSerializer, TrackPageViewSerializer,
    TrackProductViewSerializer, TrackSearchQuerySerializer,
    TrackCartEventSerializer
)
from apps.sellers.permissions import IsAdminUser


class TrackPageViewView(generics.CreateAPIView):
    serializer_class = TrackPageViewSerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response({'status': 'بازدید صفحه ثبت شد'}, status=status.HTTP_201_CREATED)


class TrackProductViewView(generics.CreateAPIView):
    serializer_class = TrackProductViewSerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response({'status': 'بازدید محصول ثبت شد'}, status=status.HTTP_201_CREATED)


class TrackSearchQueryView(generics.CreateAPIView):
    serializer_class = TrackSearchQuerySerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response({'status': 'جستجو ثبت شد'}, status=status.HTTP_201_CREATED)


class TrackCartEventView(generics.CreateAPIView):
    serializer_class = TrackCartEventSerializer
    permission_classes = [permissions.AllowAny]
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response({'status': 'رویداد سبد خرید ثبت شد'}, status=status.HTTP_201_CREATED)


class AdminDashboardView(generics.GenericAPIView):
    permission_classes = [IsAdminUser]
    
    def get(self, request, *args, **kwargs):
        # تاریخ‌های مورد نیاز
        today = timezone.now().date()
        yesterday = today - timedelta(days=1)
        start_of_week = today - timedelta(days=today.weekday())
        start_of_month = today.replace(day=1)
        
        # آمار فروش
        from apps.orders.models import Order, OrderStatus
        
        # فروش امروز
        today_sales = Order.objects.filter(
            status=OrderStatus.PAID,
            payment_date__date=today
        ).aggregate(
            total=Sum('final_price'),
            count=Count('id')
        )
        
        # فروش دیروز
        yesterday_sales = Order.objects.filter(
            status=OrderStatus.PAID,
            payment_date__date=yesterday
        ).aggregate(
            total=Sum('final_price'),
            count=Count('id')
        )
        
        # فروش این هفته
        week_sales = Order.objects.filter(
            status=OrderStatus.PAID,
            payment_date__date__gte=start_of_week
        ).aggregate(
            total=Sum('final_price'),
            count=Count('id')
        )
        
        # فروش این ماه
        month_sales = Order.objects.filter(
            status=OrderStatus.PAID,
            payment_date__date__gte=start_of_month
        ).aggregate(
            total=Sum('final_price'),
            count=Count('id')
        )
        
        # میانگین ارزش سفارش
        avg_order_value = Order.objects.filter(
            status=OrderStatus.PAID
        ).aggregate(
            avg=Avg('final_price')
        )
        
        # آمار کاربران
        from django.contrib.auth import get_user_model
        User = get_user_model()
        
        # کاربران جدید امروز
        new_users_today = User.objects.filter(
            date_joined__date=today
        ).count()
        
        # کاربران جدید این هفته
        new_users_week = User.objects.filter(
            date_joined__date__gte=start_of_week
        ).count()
        
        # کل کاربران
        total_users = User.objects.count()
        
        # آمار محصولات
        from apps.products.models import Product
        
        # محصولات پربازدید
        popular_products = ProductView.objects.filter(
            created_at__date__gte=start_of_month
        ).values('product').annotate(
            views=Count('id')
        ).order_by('-views')[:5]
        
        popular_product_ids = [item['product'] for item in popular_products]
        popular_product_details = Product.objects.filter(id__in=popular_product_ids)
        
        # محصولات پرفروش
        from apps.orders.models import OrderItem
        
        best_selling = OrderItem.objects.filter(
            order__status=OrderStatus.PAID,
            order__payment_date__date__gte=start_of_month
        ).values('product').annotate(
            sales=Sum('quantity')
        ).order_by('-sales')[:5]
        
        best_selling_ids = [item['product'] for item in best_selling]
        best_selling_details = Product.objects.filter(id__in=best_selling_ids)
        
        # آمار جستجو
        top_searches = SearchQuery.objects.filter(
            created_at__date__gte=start_of_month
        ).values('query').annotate(
            count=Count('id')
        ).order_by('-count')[:10]
        
        # آمار بازدید
        visits_by_date = PageView.objects.filter(
            created_at__date__gte=start_of_month
        ).annotate(
            date=TruncDate('created_at')
        ).values('date').annotate(
            count=Count('id')
        ).order_by('date')
        
        # تبدیل به فرمت مناسب برای نمودار
        dates = [item['date'].strftime('%Y-%m-%d') for item in visits_by_date]
        visit_counts = [item['count'] for item in visits_by_date]
        
        # نمودار فروش
        sales_by_date = Order.objects.filter(
            status=OrderStatus.PAID,
            payment_date__date__gte=start_of_month
        ).annotate(
            date=TruncDate('payment_date')
        ).values('date').annotate(
            total=Sum('final_price'),
            count=Count('id')
        ).order_by('date')
        
        # تبدیل به فرمت مناسب برای نمودار
        sale_dates = [item['date'].strftime('%Y-%m-%d') for item in sales_by_date]
        sale_totals = [float(item['total']) for item in sales_by_date]
        sale_counts = [item['count'] for item in sales_by_date]
        
        return Response({
            'sales': {
                'today': {
                    'total': today_sales['total'] or 0,
                    'count': today_sales['count'] or 0
                },
                'yesterday': {
                    'total': yesterday_sales['total'] or 0,
                    'count': yesterday_sales['count'] or 0
                },
                'week': {
                    'total': week_sales['total'] or 0,
                    'count': week_sales['count'] or 0
                },
                'month': {
                    'total': month_sales['total'] or 0,
                    'count': month_sales['count'] or 0
                },
                'avg_order_value': avg_order_value['avg'] or 0
            },
            'users': {
                'new_today': new_users_today,
                'new_week': new_users_week,
                'total': total_users
            },
            'products': {
                'popular': [
                    {
                        'id': str(product.id),
                        'name': product.name,
                        'views': next((item['views'] for item in popular_products if item['product'] == product.id), 0)
                    } for product in popular_product_details
                ],
                'best_selling': [
                    {
                        'id': str(product.id),
                        'name': product.name,
                        'sales': next((item['sales'] for item in best_selling if item['product'] == product.id), 0)
                    } for product in best_selling_details
                ]
            },
            'searches': [
                {
                    'query': item['query'],
                    'count': item['count']
                } for item in top_searches
            ],
            'charts': {
                'visits': {
                    'labels': dates,
                    'data': visit_counts
                },
                'sales': {
                    'labels': sale_dates,
                    'amounts': sale_totals,
                    'counts': sale_counts
                }
            }
        })


class AdminSalesReportViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = SalesReport.objects.all().order_by('-date')
    serializer_class = SalesReportSerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=False, methods=['get'])
    def generate(self, request):
        # تاریخ‌های مورد نیاز
        end_date = timezone.now().date()
        start_date = request.query_params.get('start_date')
        if not start_date:
            start_date = end_date - timedelta(days=30)
        else:
            from datetime import datetime
            start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
        
        # تولید گزارش برای هر روز
        from apps.orders.models import Order, OrderStatus
        
        current_date = start_date
        while current_date <= end_date:
            # بررسی آیا گزارش قبلاً ایجاد شده است
            existing_report = SalesReport.objects.filter(date=current_date).first()
            if not existing_report:
                # دریافت داده‌های سفارش برای این روز
                daily_orders = Order.objects.filter(
                    payment_date__date=current_date,
                    status=OrderStatus.PAID
                )
                
                if daily_orders.exists():
                    # محاسبه آمار فروش
                    order_stats = daily_orders.aggregate(
                        total_sales=Sum('final_price'),
                        total_orders=Count('id'),
                        total_discount=Sum('total_discount'),
                        total_shipping=Sum('shipping_cost'),
                        total_tax=Sum('tax')
                    )
                    
                    # محاسبه برگشتی‌ها
                    refunded_orders = Order.objects.filter(
                        payment_date__date=current_date,
                        status=OrderStatus.REFUNDED
                    )
                    
                    total_refund = refunded_orders.aggregate(total=Sum('final_price'))['total'] or 0
                    
                    # محاسبه میانگین ارزش سفارش
                    average_order_value = 0
                    if order_stats['total_orders'] > 0:
                        average_order_value = order_stats['total_sales'] / order_stats['total_orders']
                    
                    # محاسبه فروش خالص
                    net_sales = order_stats['total_sales'] - total_refund
                    
                    # ایجاد گزارش
                    SalesReport.objects.create(
                        date=current_date,
                        total_sales=order_stats['total_sales'] or 0,
                        total_orders=order_stats['total_orders'] or 0,
                        average_order_value=average_order_value,
                        total_discount=order_stats['total_discount'] or 0,
                        total_shipping=order_stats['total_shipping'] or 0,
                        total_tax=order_stats['total_tax'] or 0,
                        total_refund=total_refund,
                        net_sales=net_sales
                    )
            
            current_date += timedelta(days=1)
        
        # بازگرداندن گزارش‌های ایجاد شده
        reports = SalesReport.objects.filter(date__range=[start_date, end_date]).order_by('date')
        serializer = self.get_serializer(reports, many=True)
        
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def summary(self, request):
        # دریافت پارامترهای فیلتر
        period = request.query_params.get('period', 'month')  # day, week, month, year
        start_date = request.query_params.get('start_date')
        end_date = request.query_params.get('end_date')
        
        # تنظیم تاریخ‌ها
        if start_date and end_date:
            from datetime import datetime
            start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
        else:
            end_date = timezone.now().date()
            if period == 'day':
                start_date = end_date
            elif period == 'week':
                start_date = end_date - timedelta(days=7)
            elif period == 'month':
                start_date = end_date - timedelta(days=30)
            else:  # year
                start_date = end_date - timedelta(days=365)
        
        # دریافت گزارش‌ها
        reports = SalesReport.objects.filter(date__range=[start_date, end_date])
        
        if not reports.exists():
            return Response({
                'error': 'داده‌ای برای این بازه زمانی یافت نشد'
            }, status=status.HTTP_404_NOT_FOUND)
        
        # محاسبه آمار کلی
        summary = reports.aggregate(
            total_sales=Sum('total_sales'),
            total_orders=Sum('total_orders'),
            total_discount=Sum('total_discount'),
            total_shipping=Sum('total_shipping'),
            total_tax=Sum('total_tax'),
            total_refund=Sum('total_refund'),
            net_sales=Sum('net_sales')
        )
        
        # محاسبه میانگین ارزش سفارش
        average_order_value = 0
        if summary['total_orders'] > 0:
            average_order_value = summary['total_sales'] / summary['total_orders']
        
        # تهیه داده‌های نمودار
        if period == 'day':
            # نمودار ساعتی
            from apps.orders.models import Order, OrderStatus
            hourly_data = Order.objects.filter(
                payment_date__date=start_date,
                status=OrderStatus.PAID
            ).annotate(
                hour=F('payment_date__hour')
            ).values('hour').annotate(
                total=Sum('final_price'),
                count=Count('id')
            ).order_by('hour')
            
            labels = [f"{h:02d}:00" for h in range(24)]
            sales_data = [0] * 24
            orders_data = [0] * 24
            
            for item in hourly_data:
                hour = item['hour']
                sales_data[hour] = float(item['total'])
                orders_data[hour] = item['count']
            
            chart_data = {
                'labels': labels,
                'sales': sales_data,
                'orders': orders_data
            }
        else:
            # نمودار روزانه/هفتگی/ماهانه
            if period == 'week':
                # گروه‌بندی روزانه
                labels = []
                sales_data = []
                orders_data = []
                
                current_date = start_date
                while current_date <= end_date:
                    labels.append(current_date.strftime('%Y-%m-%d'))
                    
                    daily_report = reports.filter(date=current_date).first()
                    if daily_report:
                        sales_data.append(float(daily_report.total_sales))
                        orders_data.append(daily_report.total_orders)
                    else:
                        sales_data.append(0)
                        orders_data.append(0)
                    
                    current_date += timedelta(days=1)
            elif period == 'month':
                # گروه‌بندی روزانه
                labels = []
                sales_data = []
                orders_data = []
                
                current_date = start_date
                while current_date <= end_date:
                    labels.append(current_date.strftime('%Y-%m-%d'))
                    
                    daily_report = reports.filter(date=current_date).first()
                    if daily_report:
                        sales_data.append(float(daily_report.total_sales))
                        orders_data.append(daily_report.total_orders)
                    else:
                        sales_data.append(0)
                        orders_data.append(0)
                    
                    current_date += timedelta(days=1)
            else:  # year
                # گروه‌بندی ماهانه
                monthly_data = pd.DataFrame(list(reports.values()))
                monthly_data['month'] = pd.to_datetime(monthly_data['date']).dt.strftime('%Y-%m')
                monthly_grouped = monthly_data.groupby('month').agg({
                    'total_sales': 'sum',
                    'total_orders': 'sum'
                }).reset_index()
                
                labels = monthly_grouped['month'].tolist()
                sales_data = monthly_grouped['total_sales'].astype(float).tolist()
                orders_data = monthly_grouped['total_orders'].tolist()
            
            chart_data = {
                'labels': labels,
                'sales': sales_data,
                'orders': orders_data
            }
        
        return Response({
            'summary': {
                'total_sales': summary['total_sales'],
                'total_orders': summary['total_orders'],
                'average_order_value': average_order_value,
                'total_discount': summary['total_discount'],
                'total_shipping': summary['total_shipping'],
                'total_tax': summary['total_tax'],
                'total_refund': summary['total_refund'],
                'net_sales': summary['net_sales'],
                'period': period,
                'start_date': start_date.strftime('%Y-%m-%d'),
                'end_date': end_date.strftime('%Y-%m-%d')
            },
            'chart': chart_data
        })


class AdminProductPerformanceViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = ProductPerformance.objects.all().order_by('-date')
    serializer_class = ProductPerformanceSerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=False, methods=['get'])
    def generate(self, request):
        # تاریخ‌های مورد نیاز
        end_date = timezone.now().date()
        start_date = request.query_params.get('start_date')
        if not start_date:
            start_date = end_date - timedelta(days=30)
        else:
            from datetime import datetime
            start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
        
        # دریافت همه محصولات
        from apps.products.models import Product
        products = Product.objects.all()
        
        # تولید گزارش برای هر محصول و هر روز
        from apps.orders.models import OrderItem
        
        for product in products:
            current_date = start_date
            while current_date <= end_date:
                # بررسی آیا گزارش قبلاً ایجاد شده است
                existing_report = ProductPerformance.objects.filter(
                    product=product,
                    date=current_date
                ).first()
                
                if not existing_report:
                    # محاسبه بازدیدها
                    views = ProductView.objects.filter(
                        product=product,
                        created_at__date=current_date
                    ).count()
                    
                    # محاسبه افزودن به سبد
                    add_to_carts = CartEvent.objects.filter(
                        product=product,
                        event_type='add',
                        created_at__date=current_date
                    ).count()
                    
                    # محاسبه خریدها
                    purchases_data = OrderItem.objects.filter(
                        product=product,
                        order__payment_date__date=current_date,
                        order__status='paid'
                    ).aggregate(
                        purchases=Sum('quantity'),
                        revenue=Sum(F('quantity') * F('unit_price'))
                    )
                    
                    purchases = purchases_data['purchases'] or 0
                    revenue = purchases_data['revenue'] or 0
                    
                    # محاسبه نرخ تبدیل
                    conversion_rate = 0
                    if views > 0:
                        conversion_rate = (purchases / views) * 100
                    
                    # ایجاد گزارش
                    ProductPerformance.objects.create(
                        product=product,
                        date=current_date,
                        views=views,
                        add_to_carts=add_to_carts,
                        purchases=purchases,
                        revenue=revenue,
                        conversion_rate=conversion_rate
                    )
                
                current_date += timedelta(days=1)
        
        # بازگرداندن گزارش‌های ایجاد شده
        product_id = request.query_params.get('product_id')
        if product_id:
            reports = ProductPerformance.objects.filter(
                product_id=product_id,
                date__range=[start_date, end_date]
            ).order_by('date')
        else:
            reports = ProductPerformance.objects.filter(
                date__range=[start_date, end_date]
            ).order_by('-revenue')[:20]  # فقط 20 محصول برتر
        
        serializer = self.get_serializer(reports, many=True)
        
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def top_products(self, request):
        # دریافت پارامترهای فیلتر
        period = request.query_params.get('period', 'month')  # week, month, year
        metric = request.query_params.get('metric', 'revenue')  # revenue, purchases, views, conversion
        
        # تنظیم تاریخ‌ها
        end_date = timezone.now().date()
        if period == 'week':
            start_date = end_date - timedelta(days=7)
        elif period == 'month':
            start_date = end_date - timedelta(days=30)
        else:  # year
            start_date = end_date - timedelta(days=365)
        
        # گروه‌بندی داده‌ها بر اساس محصول
        reports = ProductPerformance.objects.filter(
            date__range=[start_date, end_date]
        ).values(
            'product', 'product__name'
        ).annotate(
            total_views=Sum('views'),
            total_add_to_carts=Sum('add_to_carts'),
            total_purchases=Sum('purchases'),
            total_revenue=Sum('revenue'),
            avg_conversion_rate=Avg('conversion_rate')
        )
        
        # مرتب‌سازی بر اساس معیار انتخاب شده
        if metric == 'revenue':
            reports = reports.order_by('-total_revenue')
        elif metric == 'purchases':
            reports = reports.order_by('-total_purchases')
        elif metric == 'views':
            reports = reports.order_by('-total_views')
        else:  # conversion
            reports = reports.order_by('-avg_conversion_rate')
        
        # محدود کردن به 10 محصول برتر
        reports = reports[:10]
        
        return Response({
            'period': period,
            'metric': metric,
            'start_date': start_date.strftime('%Y-%m-%d'),
            'end_date': end_date.strftime('%Y-%m-%d'),
            'products': [
                {
                    'id': str(item['product']),
                    'name': item['product__name'],
                    'views': item['total_views'],
                    'add_to_carts': item['total_add_to_carts'],
                    'purchases': item['total_purchases'],
                    'revenue': float(item['total_revenue']),
                    'conversion_rate': item['avg_conversion_rate']
                } for item in reports
            ]
        })


class AdminPageViewViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = PageView.objects.all().order_by('-created_at')
    serializer_class = PageViewSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس URL
        url = self.request.query_params.get('url')
        if url:
            queryset = queryset.filter(url__icontains=url)
        
        # فیلتر بر اساس کاربر
        user_id = self.request.query_params.get('user_id')
        if user_id:
            queryset = queryset.filter(user_id=user_id)
        
        # فیلتر بر اساس نوع دستگاه
        device_type = self.request.query_params.get('device_type')
        if device_type:
            queryset = queryset.filter(device_type=device_type)
        
        # فیلتر بر اساس تاریخ
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        
        if start_date:
            queryset = queryset.filter(created_at__date__gte=start_date)
        if end_date:
            queryset = queryset.filter(created_at__date__lte=end_date)
        
        return queryset
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        # دریافت پارامترهای فیلتر
        period = request.query_params.get('period', 'month')  # day, week, month, year
        
        # تنظیم تاریخ‌ها
        end_date = timezone.now().date()
        if period == 'day':
            start_date = end_date
        elif period == 'week':
            start_date = end_date - timedelta(days=7)
        elif period == 'month':
            start_date = end_date - timedelta(days=30)
        else:  # year
            start_date = end_date - timedelta(days=365)
        
        # آمار کلی
        total_views = PageView.objects.filter(
            created_at__date__range=[start_date, end_date]
        ).count()
        
        unique_visitors = PageView.objects.filter(
            created_at__date__range=[start_date, end_date]
        ).values('session_id').distinct().count()
        
        # آمار بر اساس نوع دستگاه
        device_stats = PageView.objects.filter(
            created_at__date__range=[start_date, end_date]
        ).values('device_type').annotate(
            count=Count('id')
        ).order_by('-count')
        
        # صفحات پربازدید
        top_pages = PageView.objects.filter(
            created_at__date__range=[start_date, end_date]
        ).values('url', 'page_title').annotate(
            views=Count('id')
        ).order_by('-views')[:10]
        
        # آمار بر اساس مرورگر
        browser_stats = PageView.objects.filter(
            created_at__date__range=[start_date, end_date]
        ).values('browser').annotate(
            count=Count('id')
        ).order_by('-count')
        
        # آمار بر اساس سیستم عامل
        os_stats = PageView.objects.filter(
            created_at__date__range=[start_date, end_date]
        ).values('os').annotate(
            count=Count('id')
        ).order_by('-count')
        
        # نمودار بازدید بر اساس زمان
        if period == 'day':
            # نمودار ساعتی
            time_stats = PageView.objects.filter(
                created_at__date=end_date
            ).annotate(
                hour=F('created_at__hour')
            ).values('hour').annotate(
                count=Count('id')
            ).order_by('hour')
            
            labels = [f"{h:02d}:00" for h in range(24)]
            data = [0] * 24
            
            for item in time_stats:
                hour = item['hour']
                data[hour] = item['count']
        elif period == 'week':
            # نمودار روزانه
            time_stats = PageView.objects.filter(
                created_at__date__range=[start_date, end_date]
            ).annotate(
                date=TruncDate('created_at')
            ).values('date').annotate(
                count=Count('id')
            ).order_by('date')
            
            labels = []
            data = []
            
            current_date = start_date
            while current_date <= end_date:
                labels.append(current_date.strftime('%Y-%m-%d'))
                
                count = next((item['count'] for item in time_stats if item['date'] == current_date), 0)
                data.append(count)
                
                current_date += timedelta(days=1)
        elif period == 'month':
            # نمودار روزانه
            time_stats = PageView.objects.filter(
                created_at__date__range=[start_date, end_date]
            ).annotate(
                date=TruncDate('created_at')
            ).values('date').annotate(
                count=Count('id')
            ).order_by('date')
            
            labels = []
            data = []
            
            current_date = start_date
            while current_date <= end_date:
                labels.append(current_date.strftime('%Y-%m-%d'))
                
                count = next((item['count'] for item in time_stats if item['date'] == current_date), 0)
                data.append(count)
                
                current_date += timedelta(days=1)
        else:  # year
            # نمودار ماهانه
            time_stats = PageView.objects.filter(
                created_at__date__range=[start_date, end_date]
            ).annotate(
                month=TruncMonth('created_at')
            ).values('month').annotate(
                count=Count('id')
            ).order_by('month')
            
            labels = [item['month'].strftime('%Y-%m') for item in time_stats]
            data = [item['count'] for item in time_stats]
        
        return Response({
            'summary': {
                'total_views': total_views,
                'unique_visitors': unique_visitors,
                'period': period,
                'start_date': start_date.strftime('%Y-%m-%d'),
                'end_date': end_date.strftime('%Y-%m-%d')
            },
            'device_stats': [
                {
                    'device_type': item['device_type'] or 'unknown',
                    'count': item['count'],
                    'percentage': (item['count'] / total_views * 100) if total_views > 0 else 0
                } for item in device_stats
            ],
            'browser_stats': [
                {
                    'browser': item['browser'] or 'unknown',
                    'count': item['count'],
                    'percentage': (item['count'] / total_views * 100) if total_views > 0 else 0
                } for item in browser_stats
            ],
            'os_stats': [
                {
                    'os': item['os'] or 'unknown',
                    'count': item['count'],
                    'percentage': (item['count'] / total_views * 100) if total_views > 0 else 0
                } for item in os_stats
            ],
            'top_pages': [
                {
                    'url': item['url'],
                    'title': item['page_title'] or item['url'],
                    'views': item['views'],
                    'percentage': (item['views'] / total_views * 100) if total_views > 0 else 0
                } for item in top_pages
            ],
            'chart': {
                'labels': labels,
                'data': data
            }
        })


class AdminSearchQueryViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = SearchQuery.objects.all().order_by('-created_at')
    serializer_class = SearchQuerySerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=False, methods=['get'])
    def popular(self, request):
        # دریافت پارامترهای فیلتر
        period = request.query_params.get('period', 'month')  # week, month, year
        
        # تنظیم تاریخ‌ها
        end_date = timezone.now().date()
        if period == 'week':
            start_date = end_date - timedelta(days=7)
        elif period == 'month':
            start_date = end_date - timedelta(days=30)
        else:  # year
            start_date = end_date - timedelta(days=365)
        
        # عبارات جستجوی محبوب
        popular_queries = SearchQuery.objects.filter(
            created_at__date__range=[start_date, end_date]
        ).values('query').annotate(
            count=Count('id'),
            avg_results=Avg('results_count')
        ).order_by('-count')[:20]
        
        # عبارات جستجوی بدون نتیجه
        zero_result_queries = SearchQuery.objects.filter(
            created_at__date__range=[start_date, end_date],
            results_count=0
        ).values('query').annotate(
            count=Count('id')
        ).order_by('-count')[:10]
        
        return Response({
            'period': period,
            'start_date': start_date.strftime('%Y-%m-%d'),
            'end_date': end_date.strftime('%Y-%m-%d'),
            'popular_queries': [
                {
                    'query': item['query'],
                    'count': item['count'],
                    'avg_results': item['avg_results']
                } for item in popular_queries
            ],
            'zero_result_queries': [
                {
                    'query': item['query'],
                    'count': item['count']
                } for item in zero_result_queries
            ]
        })


class AdminUserActivityViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = UserActivity.objects.all().order_by('-created_at')
    serializer_class = UserActivitySerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس کاربر
        user_id = self.request.query_params.get('user_id')
        if user_id:
            queryset = queryset.filter(user_id=user_id)
        
        # فیلتر بر اساس نوع فعالیت
        activity_type = self.request.query_params.get('activity_type')
        if activity_type:
            queryset = queryset.filter(activity_type=activity_type)
        
        # فیلتر بر اساس تاریخ
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        
        if start_date:
            queryset = queryset.filter(created_at__date__gte=start_date)
        if end_date:
            queryset = queryset.filter(created_at__date__lte=end_date)
        
        return queryset


from django.db import models
from django.utils.translation import gettext_lazy as _
from django.utils.text import slugify
from mptt.models import MPTTModel, TreeForeignKey
import uuid


class Category(MPTTModel):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(_('نام'), max_length=100)
    slug = models.SlugField(_('اسلاگ'), max_length=100, unique=True)
    description = models.TextField(_('توضیحات'), blank=True)
    parent = TreeForeignKey('self', on_delete=models.CASCADE, null=True, blank=True,
                           related_name='children', verbose_name=_('دسته والد'))
    image = models.ImageField(_('تصویر'), upload_to='categories/', blank=True, null=True)
    is_active = models.BooleanField(_('فعال'), default=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    order = models.PositiveIntegerField(_('ترتیب نمایش'), default=0)
    
    class MPTTMeta:
        order_insertion_by = ['order', 'name']
    
    class Meta:
        verbose_name = _('دسته‌بندی')
        verbose_name_plural = _('دسته‌بندی‌ها')
    
    def __str__(self):
        return self.name
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)


class CategoryAttribute(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='attributes',
                               verbose_name=_('دسته‌بندی'))
    name = models.CharField(_('نام ویژگی'), max_length=100)
    slug = models.SlugField(_('اسلاگ'), max_length=100)
    is_required = models.BooleanField(_('اجباری'), default=False)
    is_filter = models.BooleanField(_('قابل فیلتر'), default=False)
    is_color = models.BooleanField(_('ویژگی رنگ'), default=False)
    is_size = models.BooleanField(_('ویژگی سایز'), default=False)
    order = models.PositiveIntegerField(_('ترتیب نمایش'), default=0)
    
    class Meta:
        verbose_name = _('ویژگی دسته‌بندی')
        verbose_name_plural = _('ویژگی‌های دسته‌بندی')
        ordering = ['order', 'name']
        unique_together = ('category', 'slug')
    
    def __str__(self):
        return f"{self.name} - {self.category.name}"
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)


class CategoryAttributeValue(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    attribute = models.ForeignKey(CategoryAttribute, on_delete=models.CASCADE,
                                related_name='values', verbose_name=_('ویژگی'))
    value = models.CharField(_('مقدار'), max_length=100)
    color_code = models.CharField(_('کد رنگ'), max_length=7, blank=True, null=True)
    order = models.PositiveIntegerField(_('ترتیب نمایش'), default=0)
    
    class Meta:
        verbose_name = _('مقدار ویژگی دسته‌بندی')
        verbose_name_plural = _('مقادیر ویژگی دسته‌بندی')
        ordering = ['order', 'value']
        unique_together = ('attribute', 'value')
    
    def __str__(self):
        return f"{self.attribute.name}: {self.value}"


from rest_framework import serializers
from .models import Category, CategoryAttribute, CategoryAttributeValue


class CategoryAttributeValueSerializer(serializers.ModelSerializer):
    class Meta:
        model = CategoryAttributeValue
        fields = ('id', 'value', 'color_code', 'order')


class CategoryAttributeSerializer(serializers.ModelSerializer):
    values = CategoryAttributeValueSerializer(many=True, read_only=True)
    
    class Meta:
        model = CategoryAttribute
        fields = ('id', 'name', 'slug', 'is_required', 'is_filter', 'is_color', 'is_size', 'order', 'values')


class CategorySerializer(serializers.ModelSerializer):
    children = serializers.SerializerMethodField()
    attributes = CategoryAttributeSerializer(many=True, read_only=True)
    parent_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Category
        fields = ('id', 'name', 'slug', 'description', 'parent', 'parent_name', 'image', 
                 'is_active', 'created_at', 'updated_at', 'order', 'children', 'attributes')
    
    def get_children(self, obj):
        return CategorySerializer(obj.get_children(), many=True).data
    
    def get_parent_name(self, obj):
        if obj.parent:
            return obj.parent.name
        return None


class CategoryListSerializer(serializers.ModelSerializer):
    class Meta:
        model = Category
        fields = ('id', 'name', 'slug', 'image', 'parent')


class CategoryDetailSerializer(serializers.ModelSerializer):
    children = CategoryListSerializer(many=True, read_only=True)
    attributes = CategoryAttributeSerializer(many=True, read_only=True)
    breadcrumbs = serializers.SerializerMethodField()
    
    class Meta:
        model = Category
        fields = ('id', 'name', 'slug', 'description', 'parent', 'image', 
                 'is_active', 'created_at', 'updated_at', 'order', 
                 'children', 'attributes', 'breadcrumbs')
    
    def get_breadcrumbs(self, obj):
        result = []
        node = obj
        while node:
            result.insert(0, {'id': node.id, 'name': node.name, 'slug': node.slug})
            node = node.parent
        return result


class CategoryAttributeValueDetailSerializer(serializers.ModelSerializer):
    class Meta:
        model = CategoryAttributeValue
        fields = '__all__'


class CategoryAttributeDetailSerializer(serializers.ModelSerializer):
    values = CategoryAttributeValueDetailSerializer(many=True, read_only=True)
    category_name = serializers.SerializerMethodField()
    
    class Meta:
        model = CategoryAttribute
        fields = '__all__'
    
    def get_category_name(self, obj):
        return obj.category.name

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'categories', views.CategoryViewSet)
router.register(r'attributes', views.CategoryAttributeViewSet)
router.register(r'attribute-values', views.CategoryAttributeValueViewSet)

urlpatterns = [
    path('', include(router.urls)),
]



from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db.models import Q
from .models import Category, CategoryAttribute, CategoryAttributeValue
from .serializers import (
    CategorySerializer, CategoryListSerializer, CategoryDetailSerializer,
    CategoryAttributeSerializer, CategoryAttributeValueSerializer,
    CategoryAttributeDetailSerializer, CategoryAttributeValueDetailSerializer
)


class CategoryViewSet(viewsets.ModelViewSet):
    queryset = Category.objects.all()
    serializer_class = CategorySerializer
    lookup_field = 'slug'
    permission_classes = [permissions.IsAdminUser]
    
    def get_permissions(self):
        if self.action in ['list', 'retrieve', 'root_categories', 'by_parent']:
            return [permissions.AllowAny()]
        return super().get_permissions()
    
    def get_serializer_class(self):
        if self.action == 'list':
            return CategoryListSerializer
        elif self.action == 'retrieve':
            return CategoryDetailSerializer
        return CategorySerializer
    
    def get_queryset(self):
        queryset = Category.objects.all()
        if self.action in ['list', 'root_categories', 'by_parent']:
            queryset = queryset.filter(is_active=True)
        return queryset
    
    @action(detail=False, methods=['get'])
    def root_categories(self, request):
        categories = Category.objects.filter(parent=None, is_active=True)
        serializer = CategoryListSerializer(categories, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def by_parent(self, request):
        parent_slug = request.query_params.get('parent', None)
        if parent_slug:
            try:
                parent = Category.objects.get(slug=parent_slug)
                categories = Category.objects.filter(parent=parent, is_active=True)
                serializer = CategoryListSerializer(categories, many=True)
                return Response(serializer.data)
            except Category.DoesNotExist:
                return Response({'error': 'دسته‌بندی والد یافت نشد'}, status=status.HTTP_404_NOT_FOUND)
        else:
            return Response({'error': 'پارامتر parent الزامی است'}, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['get'])
    def attributes(self, request, slug=None):
        category = self.get_object()
        # دریافت ویژگی‌های این دسته و تمام دسته‌های والد
        attributes = []
        current = category
        while current:
            attrs = CategoryAttribute.objects.filter(category=current)
            for attr in attrs:
                attributes.append(attr)
            current = current.parent
        
        serializer = CategoryAttributeDetailSerializer(attributes, many=True)
        return Response(serializer.data)


class CategoryAttributeViewSet(viewsets.ModelViewSet):
    queryset = CategoryAttribute.objects.all()
    serializer_class = CategoryAttributeSerializer
    permission_classes = [permissions.IsAdminUser]
    
    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [permissions.AllowAny()]
        return super().get_permissions()
    
    def get_serializer_class(self):
        if self.action in ['retrieve', 'list']:
            return CategoryAttributeDetailSerializer
        return CategoryAttributeSerializer


class CategoryAttributeValueViewSet(viewsets.ModelViewSet):
    queryset = CategoryAttributeValue.objects.all()
    serializer_class = CategoryAttributeValueSerializer
    permission_classes = [permissions.IsAdminUser]
    
    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [permissions.AllowAny()]
        return super().get_permissions()
    
    def get_serializer_class(self):
        if self.action in ['retrieve', 'list']:
            return CategoryAttributeValueDetailSerializer
        return CategoryAttributeValueSerializer

from django.db import models
from django.contrib.auth import get_user_model
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from apps.common.models import BaseModel

User = get_user_model()


class Comment(BaseModel):
    """Comment model for products, blog posts, etc."""
    STATUS_CHOICES = [
        ('pending', 'در انتظار بررسی'),
        ('approved', 'تایید شده'),
        ('rejected', 'رد شده'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='comments', verbose_name='کاربر')
    
    # Generic foreign key for linking to any model
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE, verbose_name='نوع محتوا')
    object_id = models.UUIDField(verbose_name='شناسه محتوا')
    content_object = GenericForeignKey('content_type', 'object_id')
    
    text = models.TextField(verbose_name='متن نظر')
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='pending', verbose_name='وضعیت')
    
    parent = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True, 
                              related_name='replies', verbose_name='نظر والد')
    
    likes_count = models.PositiveIntegerField(default=0, verbose_name='تعداد لایک‌ها')
    dislikes_count = models.PositiveIntegerField(default=0, verbose_name='تعداد دیسلایک‌ها')
    
    admin_note = models.TextField(blank=True, verbose_name='یادداشت مدیر')
    
    class Meta:
        verbose_name = 'نظر'
        verbose_name_plural = 'نظرات'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['content_type', 'object_id']),
        ]

    def __str__(self):
        return f"{self.user.phone} - {self.text[:50]}"
    
    @property
    def is_reply(self):
        """Check if comment is a reply"""
        return self.parent is not None
    
    @property
    def replies_count(self):
        """Get replies count"""
        return self.replies.count()


class CommentVote(BaseModel):
    """Model for comment likes/dislikes"""
    VOTE_CHOICES = [
        ('like', 'لایک'),
        ('dislike', 'دیسلایک'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='کاربر')
    comment = models.ForeignKey(Comment, on_delete=models.CASCADE, related_name='votes', verbose_name='نظر')
    vote_type = models.CharField(max_length=10, choices=VOTE_CHOICES, verbose_name='نوع رای')
    
    class Meta:
        verbose_name = 'رای نظر'
        verbose_name_plural = 'آرای نظرات'
        unique_together = ['user', 'comment']
        
    def __str__(self):
        return f"{self.user.phone} - {self.get_vote_type_display()} - {self.comment.id}"
    
    def save(self, *args, **kwargs):
        # Check if this is a new vote or update
        is_new = self.pk is None
        
        # Get old vote if exists
        old_vote_type = None
        if not is_new:
            old_vote = CommentVote.objects.get(pk=self.pk)
            old_vote_type = old_vote.vote_type
        
        super().save(*args, **kwargs)
        
        # Update comment vote counts
        if is_new:
            # New vote
            if self.vote_type == 'like':
                self.comment.likes_count += 1
            else:
                self.comment.dislikes_count += 1
        elif old_vote_type != self.vote_type:
            # Changed vote
            if self.vote_type == 'like':
                self.comment.likes_count += 1
                self.comment.dislikes_count -= 1
            else:
                self.comment.likes_count -= 1
                self.comment.dislikes_count += 1
        
        self.comment.save()
    
    def delete(self, *args, **kwargs):
        # Update comment vote counts
        if self.vote_type == 'like':
            self.comment.likes_count = max(0, self.comment.likes_count - 1)
        else:
            self.comment.dislikes_count = max(0, self.comment.dislikes_count - 1)
        self.comment.save()
        
        super().delete(*args, **kwargs)


class CommentReport(BaseModel):
    """Model for reporting inappropriate comments"""
    REASON_CHOICES = [
        ('spam', 'اسپم'),
        ('offensive', 'توهین‌آمیز'),
        ('irrelevant', 'غیرمرتبط'),
        ('advertising', 'تبلیغاتی'),
        ('other', 'سایر'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'در انتظار بررسی'),
        ('resolved', 'بررسی شده'),
        ('dismissed', 'رد شده'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='گزارش‌دهنده')
    comment = models.ForeignKey(Comment, on_delete=models.CASCADE, related_name='reports', verbose_name='نظر')
    reason = models.CharField(max_length=20, choices=REASON_CHOICES, verbose_name='دلیل گزارش')
    description = models.TextField(blank=True, verbose_name='توضیحات')
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='pending', verbose_name='وضعیت')
    admin_note = models.TextField(blank=True, verbose_name='یادداشت مدیر')
    
    class Meta:
        verbose_name = 'گزارش نظر'
        verbose_name_plural = 'گزارش‌های نظرات'
        unique_together = ['user', 'comment']
        
    def __str__(self):
        return f"{self.user.phone} - {self.get_reason_display()} - {self.comment.id}"



from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register('', views.CommentViewSet)
router.register('reports', views.CommentReportViewSet)

urlpatterns = [
    path('', include(router.urls)),
]


from rest_framework import serializers
from django.contrib.contenttypes.models import ContentType
from .models import Comment, CommentVote, CommentReport


class CommentSerializer(serializers.ModelSerializer):
    user_name = serializers.SerializerMethodField()
    user_avatar = serializers.SerializerMethodField()
    content_type_name = serializers.CharField(write_only=True)
    object_id = serializers.UUIDField(write_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    replies_count = serializers.IntegerField(read_only=True)
    is_reply = serializers.BooleanField(read_only=True)
    user_vote = serializers.SerializerMethodField()
    
    class Meta:
        model = Comment
        fields = [
            'id', 'user', 'user_name', 'user_avatar', 'content_type_name', 
            'object_id', 'text', 'status', 'status_display', 'parent', 
            'likes_count', 'dislikes_count', 'replies_count', 'is_reply',
            'user_vote', 'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'user', 'status', 'likes_count', 'dislikes_count', 'created_at', 'updated_at']
    
    def get_user_name(self, obj):
        """Get user's name"""
        if obj.user.first_name or obj.user.last_name:
            return f"{obj.user.first_name} {obj.user.last_name}".strip()
        return obj.user.phone
    
    def get_user_avatar(self, obj):
        """Get user's avatar"""
        if hasattr(obj.user, 'profile') and obj.user.profile.avatar:
            return obj.user.profile.avatar.url
        return None
    
    def get_user_vote(self, obj):
        """Get current user's vote on this comment"""
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            vote = CommentVote.objects.filter(user=request.user, comment=obj).first()
            if vote:
                return vote.vote_type
        return None
    
    def validate(self, data):
        """Validate content type and object ID"""
        content_type_name = data.pop('content_type_name', None)
        object_id = data.get('object_id')
        
        if not content_type_name or not object_id:
            raise serializers.ValidationError("نوع محتوا و شناسه محتوا الزامی است")
        
        try:
            app_label, model = content_type_name.split('.')
            content_type = ContentType.objects.get(app_label=app_label, model=model)
            data['content_type'] = content_type
            
            # Check if object exists
            model_class = content_type.model_class()
            model_class.objects.get(id=object_id)
            
        except (ValueError, ContentType.DoesNotExist):
            raise serializers.ValidationError("نوع محتوا نامعتبر است")
        except model_class.DoesNotExist:
            raise serializers.ValidationError("محتوا با این شناسه یافت نشد")
        
        # Check if parent comment exists and belongs to the same content object
        parent = data.get('parent')
        if parent:
            if parent.content_type != data['content_type'] or parent.object_id != object_id:
                raise serializers.ValidationError("نظر والد باید متعلق به همان محتوا باشد")
            
            # Check if parent is already a reply
            if parent.parent:
                raise serializers.ValidationError("پاسخ به پاسخ مجاز نیست")
        
        return data
    
    def create(self, validated_data):
        validated_data['user'] = self.context['request'].user
        return super().create(validated_data)


class CommentVoteSerializer(serializers.ModelSerializer):
    class Meta:
        model = CommentVote
        fields = ['id', 'comment', 'vote_type', 'created_at']
        read_only_fields = ['id', 'created_at']
    
    def validate(self, data):
        user = self.context['request'].user
        comment = data['comment']
        
        # Check if user is voting on their own comment
        if comment.user == user:
            raise serializers.ValidationError("شما نمی‌توانید به نظر خود رای دهید")
        
        return data
    
    def create(self, validated_data):
        user = self.context['request'].user
        comment = validated_data['comment']
        vote_type = validated_data['vote_type']
        
        # Check if vote already exists
        vote, created = CommentVote.objects.update_or_create(
            user=user,
            comment=comment,
            defaults={'vote_type': vote_type}
        )
        
        return vote


class CommentReportSerializer(serializers.ModelSerializer):
    reason_display = serializers.CharField(source='get_reason_display', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    
    class Meta:
        model = CommentReport
        fields = [
            'id', 'comment', 'reason', 'reason_display', 'description',
            'status', 'status_display', 'created_at'
        ]
        read_only_fields = ['id', 'status', 'created_at']
    
    def validate(self, data):
        user = self.context['request'].user
        comment = data['comment']
        
        # Check if user is reporting their own comment
        if comment.user == user:
            raise serializers.ValidationError("شما نمی‌توانید نظر خود را گزارش کنید")
        
        # Check if user already reported this comment
        if CommentReport.objects.filter(user=user, comment=comment).exists():
            raise serializers.ValidationError("شما قبلاً این نظر را گزارش کرده‌اید")
        
        return data
    
    def create(self, validated_data):
        validated_data['user'] = self.context['request'].user
        return super().create(validated_data)


class ReplySerializer(serializers.ModelSerializer):
    user_name = serializers.SerializerMethodField()
    user_avatar = serializers.SerializerMethodField()
    
    class Meta:
        model = Comment
        fields = [
            'id', 'user', 'user_name', 'user_avatar', 'text',
            'likes_count', 'dislikes_count', 'created_at'
        ]
    
    def get_user_name(self, obj):
        """Get user's name"""
        if obj.user.first_name or obj.user.last_name:
            return f"{obj.user.first_name} {obj.user.last_name}".strip()
        return obj.user.phone
    
    def get_user_avatar(self, obj):
        """Get user's avatar"""
        if hasattr(obj.user, 'profile') and obj.user.profile.avatar:
            return obj.user.profile.avatar.url
        return None


from rest_framework import viewsets, status, permissions
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny, IsAdminUser
from django.contrib.contenttypes.models import ContentType
from django.db.models import Q
from .models import Comment, CommentVote, CommentReport
from .serializers import (
    CommentSerializer, CommentVoteSerializer, CommentReportSerializer,
    ReplySerializer
)
from apps.common.pagination import StandardResultsSetPagination


class CommentViewSet(viewsets.ModelViewSet):
    """Comment viewset for CRUD operations"""
    queryset = Comment.objects.filter(status='approved', parent=None)
    serializer_class = CommentSerializer
    pagination_class = StandardResultsSetPagination
    
    def get_permissions(self):
        if self.action in ['list', 'retrieve', 'for_object']:
            permission_classes = [AllowAny]
        elif self.action in ['update', 'partial_update', 'destroy']:
            permission_classes = [IsAuthenticated]
        else:
            permission_classes = [IsAuthenticated]
        return [permission() for permission in permission_classes]
    
    def get_queryset(self):
        queryset = Comment.objects.all()
        
        # Filter by status
        if self.request.user.is_staff:
            status_filter = self.request.query_params.get('status')
            if status_filter:
                queryset = queryset.filter(status=status_filter)
        else:
            # Regular users can only see approved comments or their own
            queryset = queryset.filter(
                Q(status='approved') | Q(user=self.request.user)
            )
        
        # Filter by parent (top-level comments)
        if self.action != 'replies':
            queryset = queryset.filter(parent=None)
        
        return queryset
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
    
    def perform_update(self, serializer):
        comment = self.get_object()
        
        # Only allow users to edit their own comments or admins
        if comment.user != self.request.user and not self.request.user.is_staff:
            self.permission_denied(self.request, message="شما اجازه ویرایش این نظر را ندارید")
        
        serializer.save()
    
    def perform_destroy(self, instance):
        # Only allow users to delete their own comments or admins
        if instance.user != self.request.user and not self.request.user.is_staff:
            self.permission_denied(self.request, message="شما اجازه حذف این نظر را ندارید")
        
        instance.delete()
    
    @action(detail=False, methods=['get'])
    def for_object(self, request):
        """Get comments for a specific object"""
        content_type_name = request.query_params.get('content_type')
        object_id = request.query_params.get('object_id')
        
        if not content_type_name or not object_id:
            return Response(
                {"error": "نوع محتوا و شناسه محتوا الزامی است"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            app_label, model = content_type_name.split('.')
            content_type = ContentType.objects.get(app_label=app_label, model=model)
            
            queryset = self.get_queryset().filter(
                content_type=content_type,
                object_id=object_id
            )
            
            page = self.paginate_queryset(queryset)
            if page is not None:
                serializer = self.get_serializer(page, many=True)
                return self.get_paginated_response(serializer.data)
            
            serializer = self.get_serializer(queryset, many=True)
            return Response(serializer.data)
            
        except (ValueError, ContentType.DoesNotExist):
            return Response(
                {"error": "نوع محتوا نامعتبر است"},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=True, methods=['get'])
    def replies(self, request, pk=None):
        """Get replies for a comment"""
        comment = self.get_object()
        replies = Comment.objects.filter(parent=comment, status='approved')
        
        page = self.paginate_queryset(replies)
        if page is not None:
            serializer = ReplySerializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = ReplySerializer(replies, many=True)
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def vote(self, request, pk=None):
        """Vote on a comment"""
        comment = self.get_object()
        vote_type = request.data.get('vote_type')
        
        if vote_type not in ['like', 'dislike']:
            return Response(
                {"error": "نوع رای باید 'like' یا 'dislike' باشد"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Check if user is voting on their own comment
        if comment.user == request.user:
            return Response(
                {"error": "شما نمی‌توانید به نظر خود رای دهید"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Create or update vote
        vote, created = CommentVote.objects.update_or_create(
            user=request.user,
            comment=comment,
            defaults={'vote_type': vote_type}
        )
        
        return Response({
            "message": "رای شما ثبت شد",
            "likes_count": comment.likes_count,
            "dislikes_count": comment.dislikes_count
        })
    
    @action(detail=True, methods=['post'])
    def report(self, request, pk=None):
        """Report a comment"""
        comment = self.get_object()
        reason = request.data.get('reason')
        description = request.data.get('description', '')
        
        if not reason:
            return Response(
                {"error": "دلیل گزارش الزامی است"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Check if user is reporting their own comment
        if comment.user == request.user:
            return Response(
                {"error": "شما نمی‌توانید نظر خود را گزارش کنید"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Check if user already reported this comment
        if CommentReport.objects.filter(user=request.user, comment=comment).exists():
            return Response(
                {"error": "شما قبلاً این نظر را گزارش کرده‌اید"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Create report
        CommentReport.objects.create(
            user=request.user,
            comment=comment,
            reason=reason,
            description=description
        )
        
        return Response({"message": "گزارش شما ثبت شد"})
    
    @action(detail=True, methods=['post'], permission_classes=[IsAdminUser])
    def approve(self, request, pk=None):
        """Approve a comment (admin only)"""
        comment = self.get_object()
        comment.status = 'approved'
        comment.save()
        return Response({"message": "نظر تایید شد"})
    
    @action(detail=True, methods=['post'], permission_classes=[IsAdminUser])
    def reject(self, request, pk=None):
        """Reject a comment (admin only)"""
        comment = self.get_object()
        comment.status = 'rejected'
        comment.save()
        return Response({"message": "نظر رد شد"})
    
    @action(detail=False, methods=['get'], permission_classes=[IsAdminUser])
    def pending(self, request):
        """Get pending comments (admin only)"""
        queryset = Comment.objects.filter(status='pending')
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class CommentReportViewSet(viewsets.ModelViewSet):
    """Comment report viewset for admins"""
    queryset = CommentReport.objects.all()
    serializer_class = CommentReportSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        if self.request.user.is_staff:
            return CommentReport.objects.all()
        return CommentReport.objects.filter(user=self.request.user)
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        if serializer.is_valid():
            serializer.save(user=request.user)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['post'], permission_classes=[IsAdminUser])
    def resolve(self, request, pk=None):
        """Resolve a report (admin only)"""
        report = self.get_object()
        action = request.data.get('action')
        admin_note = request.data.get('admin_note', '')
        
        if action not in ['dismiss', 'remove_comment']:
            return Response(
                {"error": "عملیات باید 'dismiss' یا 'remove_comment' باشد"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        report.status = 'resolved' if action == 'remove_comment' else 'dismissed'
        report.admin_note = admin_note
        report.save()
        
        if action == 'remove_comment':
            report.comment.status = 'rejected'
            report.comment.admin_note = admin_note
            report.comment.save()
        
        return Response({"message": "گزارش پردازش شد"})


from django.db import models
from django.contrib.auth import get_user_model
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
import uuid

User = get_user_model()


class TimeStampedModel(models.Model):
    """Abstract base class with created_at and updated_at fields"""
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='تاریخ ایجاد')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='تاریخ بروزرسانی')

    class Meta:
        abstract = True


class SoftDeleteModel(models.Model):
    """Abstract base class with soft delete functionality"""
    is_deleted = models.BooleanField(default=False, verbose_name='حذف شده')
    deleted_at = models.DateTimeField(null=True, blank=True, verbose_name='تاریخ حذف')

    class Meta:
        abstract = True

    def soft_delete(self):
        from django.utils import timezone
        self.is_deleted = True
        self.deleted_at = timezone.now()
        self.save()

    def restore(self):
        self.is_deleted = False
        self.deleted_at = None
        self.save()


class BaseModel(TimeStampedModel, SoftDeleteModel):
    """Base model with timestamp and soft delete functionality"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    class Meta:
        abstract = True


class ActivityLog(TimeStampedModel):
    """Model to track user activities"""
    ACTION_CHOICES = [
        ('create', 'ایجاد'),
        ('update', 'بروزرسانی'),
        ('delete', 'حذف'),
        ('view', 'مشاهده'),
        ('login', 'ورود'),
        ('logout', 'خروج'),
        ('purchase', 'خرید'),
        ('payment', 'پرداخت'),
        ('review', 'نظر'),
        ('like', 'پسند'),
        ('follow', 'دنبال کردن'),
        ('search', 'جستجو'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='کاربر')
    action = models.CharField(max_length=20, choices=ACTION_CHOICES, verbose_name='عمل')
    description = models.TextField(blank=True, verbose_name='توضیحات')
    ip_address = models.GenericIPAddressField(null=True, blank=True, verbose_name='آدرس IP')
    user_agent = models.TextField(blank=True, verbose_name='User Agent')
    
    # Generic foreign key for linking to any model
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE, null=True, blank=True)
    object_id = models.PositiveIntegerField(null=True, blank=True)
    content_object = GenericForeignKey('content_type', 'object_id')

    class Meta:
        verbose_name = 'لاگ فعالیت'
        verbose_name_plural = 'لاگ‌های فعالیت'
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.user.phone} - {self.get_action_display()} - {self.created_at}"


class Setting(models.Model):
    """System settings model"""
    SETTING_TYPES = [
        ('string', 'متن'),
        ('integer', 'عدد صحیح'),
        ('float', 'عدد اعشاری'),
        ('boolean', 'بولین'),
        ('json', 'JSON'),
        ('text', 'متن طولانی'),
    ]

    key = models.CharField(max_length=100, unique=True, verbose_name='کلید')
    value = models.TextField(verbose_name='مقدار')
    value_type = models.CharField(max_length=20, choices=SETTING_TYPES, default='string', verbose_name='نوع مقدار')
    description = models.TextField(blank=True, verbose_name='توضیحات')
    is_active = models.BooleanField(default=True, verbose_name='فعال')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='تاریخ ایجاد')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='تاریخ بروزرسانی')

    class Meta:
        verbose_name = 'تنظیمات'
        verbose_name_plural = 'تنظیمات'

    def __str__(self):
        return self.key

    def get_value(self):
        """Return the value in its proper type"""
        if self.value_type == 'integer':
            return int(self.value)
        elif self.value_type == 'float':
            return float(self.value)
        elif self.value_type == 'boolean':
            return self.value.lower() in ['true', '1', 'yes']
        elif self.value_type == 'json':
            import json
            return json.loads(self.value)
        return self.value


class ContactMessage(TimeStampedModel):
    """Contact form messages"""
    name = models.CharField(max_length=100, verbose_name='نام')
    email = models.EmailField(verbose_name='ایمیل')
    phone = models.CharField(max_length=15, blank=True, verbose_name='تلفن')
    subject = models.CharField(max_length=200, verbose_name='موضوع')
    message = models.TextField(verbose_name='پیام')
    is_read = models.BooleanField(default=False, verbose_name='خوانده شده')
    replied = models.BooleanField(default=False, verbose_name='پاسخ داده شده')
    reply_message = models.TextField(blank=True, verbose_name='پیام پاسخ')
    replied_at = models.DateTimeField(null=True, blank=True, verbose_name='تاریخ پاسخ')

    class Meta:
        verbose_name = 'پیام تماس'
        verbose_name_plural = 'پیام‌های تماس'
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.name} - {self.subject}"


class FAQ(models.Model):
    """Frequently Asked Questions"""
    question = models.CharField(max_length=500, verbose_name='سوال')
    answer = models.TextField(verbose_name='پاسخ')
    category = models.CharField(max_length=100, blank=True, verbose_name='دسته‌بندی')
    order = models.PositiveIntegerField(default=0, verbose_name='ترتیب')
    is_active = models.BooleanField(default=True, verbose_name='فعال')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='تاریخ ایجاد')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='تاریخ بروزرسانی')

    class Meta:
        verbose_name = 'سوال متداول'
        verbose_name_plural = 'سوالات متداول'
        ordering = ['order', '-created_at']

    def __str__(self):
        return self.question


class Province(models.Model):
    """Iranian provinces"""
    name = models.CharField(max_length=100, verbose_name='نام استان')
    code = models.CharField(max_length=10, unique=True, verbose_name='کد استان')
    is_active = models.BooleanField(default=True, verbose_name='فعال')

    class Meta:
        verbose_name = 'استان'
        verbose_name_plural = 'استان‌ها'
        ordering = ['name']

    def __str__(self):
        return self.name


class City(models.Model):
    """Iranian cities"""
    name = models.CharField(max_length=100, verbose_name='نام شهر')
    province = models.ForeignKey(Province, on_delete=models.CASCADE, related_name='cities', verbose_name='استان')
    code = models.CharField(max_length=10, verbose_name='کد شهر')
    is_active = models.BooleanField(default=True, verbose_name='فعال')

    class Meta:
        verbose_name = 'شهر'
        verbose_name_plural = 'شهرها'
        ordering = ['name']
        unique_together = ['province', 'code']

    def __str__(self):
        return f"{self.name} - {self.province.name}"


class Banner(TimeStampedModel):
    """Website banners"""
    POSITION_CHOICES = [
        ('header', 'هدر'),
        ('sidebar', 'نوار کناری'),
        ('footer', 'فوتر'),
        ('homepage', 'صفحه اصلی'),
        ('category', 'صفحه دسته‌بندی'),
        ('product', 'صفحه محصول'),
    ]

    title = models.CharField(max_length=200, verbose_name='عنوان')
    image = models.ImageField(upload_to='banners/', verbose_name='تصویر')
    link = models.URLField(blank=True, verbose_name='لینک')
    position = models.CharField(max_length=20, choices=POSITION_CHOICES, verbose_name='موقعیت')
    order = models.PositiveIntegerField(default=0, verbose_name='ترتیب')
    is_active = models.BooleanField(default=True, verbose_name='فعال')
    start_date = models.DateTimeField(null=True, blank=True, verbose_name='تاریخ شروع')
    end_date = models.DateTimeField(null=True, blank=True, verbose_name='تاریخ پایان')

    class Meta:
        verbose_name = 'بنر'
        verbose_name_plural = 'بنرها'
        ordering = ['position', 'order']

    def __str__(self):
        return self.title

    @property
    def is_valid(self):
        from django.utils import timezone
        now = timezone.now()
        if self.start_date and now < self.start_date:
            return False
        if self.end_date and now > self.end_date:
            return False
        return self.is_active


class Newsletter(TimeStampedModel):
    """Newsletter subscriptions"""
    email = models.EmailField(unique=True, verbose_name='ایمیل')
    is_active = models.BooleanField(default=True, verbose_name='فعال')
    confirmed = models.BooleanField(default=False, verbose_name='تایید شده')
    confirmation_token = models.CharField(max_length=100, blank=True, verbose_name='توکن تایید')

    class Meta:
        verbose_name = 'خبرنامه'
        verbose_name_plural = 'خبرنامه‌ها'
        ordering = ['-created_at']

    def __str__(self):
        return self.email


from rest_framework import serializers
from .models import (
    ActivityLog, Setting, ContactMessage, FAQ, 
    Province, City, Banner, Newsletter
)


class ActivityLogSerializer(serializers.ModelSerializer):
    user_phone = serializers.CharField(source='user.phone', read_only=True)
    action_display = serializers.CharField(source='get_action_display', read_only=True)

    class Meta:
        model = ActivityLog
        fields = [
            'id', 'user', 'user_phone', 'action', 'action_display',
            'description', 'ip_address', 'created_at'
        ]
        read_only_fields = ['id', 'created_at']


class SettingSerializer(serializers.ModelSerializer):
    class Meta:
        model = Setting
        fields = [
            'id', 'key', 'value', 'value_type', 'description',
            'is_active', 'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'created_at', 'updated_at']


class ContactMessageSerializer(serializers.ModelSerializer):
    class Meta:
        model = ContactMessage
        fields = [
            'id', 'name', 'email', 'phone', 'subject', 'message',
            'is_read', 'replied', 'reply_message', 'replied_at', 'created_at'
        ]
        read_only_fields = ['id', 'is_read', 'replied', 'replied_at', 'created_at']


class ContactMessageReplySerializer(serializers.Serializer):
    reply_message = serializers.CharField(max_length=2000)

    def update(self, instance, validated_data):
        from django.utils import timezone
        instance.reply_message = validated_data['reply_message']
        instance.replied = True
        instance.replied_at = timezone.now()
        instance.save()
        return instance


class FAQSerializer(serializers.ModelSerializer):
    class Meta:
        model = FAQ
        fields = [
            'id', 'question', 'answer', 'category', 'order',
            'is_active', 'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'created_at', 'updated_at']


class ProvinceSerializer(serializers.ModelSerializer):
    cities_count = serializers.IntegerField(source='cities.count', read_only=True)

    class Meta:
        model = Province
        fields = ['id', 'name', 'code', 'is_active', 'cities_count']


class CitySerializer(serializers.ModelSerializer):
    province_name = serializers.CharField(source='province.name', read_only=True)

    class Meta:
        model = City
        fields = ['id', 'name', 'code', 'province', 'province_name', 'is_active']


class BannerSerializer(serializers.ModelSerializer):
    position_display = serializers.CharField(source='get_position_display', read_only=True)
    is_valid = serializers.BooleanField(read_only=True)

    class Meta:
        model = Banner
        fields = [
            'id', 'title', 'image', 'link', 'position', 'position_display',
            'order', 'is_active', 'is_valid', 'start_date', 'end_date',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'created_at', 'updated_at']


class NewsletterSerializer(serializers.ModelSerializer):
    class Meta:
        model = Newsletter
        fields = ['id', 'email', 'is_active', 'confirmed', 'created_at']
        read_only_fields = ['id', 'confirmed', 'created_at']


class NewsletterSubscribeSerializer(serializers.Serializer):
    email = serializers.EmailField()

    def create(self, validated_data):
        newsletter, created = Newsletter.objects.get_or_create(
            email=validated_data['email'],
            defaults={'is_active': True}
        )
        return newsletter




from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register('settings', views.SettingViewSet)
router.register('contacts', views.ContactMessageViewSet)
router.register('faqs', views.FAQViewSet)
router.register('provinces', views.ProvinceViewSet)
router.register('cities', views.CityViewSet)
router.register('banners', views.BannerViewSet)
router.register('newsletters', views.NewsletterViewSet)
router.register('activities', views.ActivityLogViewSet)

# حتماً urlpatterns را به عنوان یک لیست تعریف کنید
urlpatterns = [
    path('', include(router.urls)),
    # سایر مسیرها را اینجا اضافه کنید
]


from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny, IsAdminUser
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter
from django.utils import timezone
from .models import (
    ActivityLog, Setting, ContactMessage, FAQ,
    Province, City, Banner, Newsletter
)
from .serializers import (
    ActivityLogSerializer, SettingSerializer, ContactMessageSerializer,
    ContactMessageReplySerializer, FAQSerializer, ProvinceSerializer,
    CitySerializer, BannerSerializer, NewsletterSerializer,
    NewsletterSubscribeSerializer
)
from .pagination import StandardResultsSetPagination


class ActivityLogViewSet(viewsets.ReadOnlyModelViewSet):
    """Activity logs viewset"""
    queryset = ActivityLog.objects.all()
    serializer_class = ActivityLogSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardResultsSetPagination
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['action', 'user']
    search_fields = ['description', 'user__phone']
    ordering_fields = ['created_at']
    ordering = ['-created_at']

    def get_queryset(self):
        if self.request.user.is_staff:
            return ActivityLog.objects.all()
        return ActivityLog.objects.filter(user=self.request.user)


class SettingViewSet(viewsets.ModelViewSet):
    """System settings viewset"""
    queryset = Setting.objects.filter(is_active=True)
    serializer_class = SettingSerializer
    permission_classes = [IsAdminUser]
    filter_backends = [SearchFilter]
    search_fields = ['key', 'description']

    @action(detail=False, methods=['get'], permission_classes=[AllowAny])
    def public(self, request):
        """Get public settings"""
        public_keys = ['site_name', 'site_description', 'contact_email', 'contact_phone']
        settings = Setting.objects.filter(key__in=public_keys, is_active=True)
        serializer = self.get_serializer(settings, many=True)
        return Response(serializer.data)


class ContactMessageViewSet(viewsets.ModelViewSet):
    """Contact messages viewset"""
    queryset = ContactMessage.objects.all()
    serializer_class = ContactMessageSerializer
    pagination_class = StandardResultsSetPagination
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['is_read', 'replied']
    search_fields = ['name', 'email', 'subject']
    ordering_fields = ['created_at']
    ordering = ['-created_at']

    def get_permissions(self):
        if self.action == 'create':
            permission_classes = [AllowAny]
        else:
            permission_classes = [IsAdminUser]
        return [permission() for permission in permission_classes]

    def perform_create(self, serializer):
        serializer.save()
        # Send notification to admin
        # self.send_admin_notification(serializer.instance)

    @action(detail=True, methods=['post'])
    def reply(self, request, pk=None):
        """Reply to contact message"""
        message = self.get_object()
        serializer = ContactMessageReplySerializer(message, data=request.data)
        if serializer.is_valid():
            serializer.save()
            # Send email reply
            # self.send_reply_email(message)
            return Response({'message': 'پاسخ با موفقیت ارسال شد'})
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['post'])
    def mark_as_read(self, request, pk=None):
        """Mark message as read"""
        message = self.get_object()
        message.is_read = True
        message.save()
        return Response({'message': 'پیام به عنوان خوانده شده علامت‌گذاری شد'})


class FAQViewSet(viewsets.ModelViewSet):
    """FAQ viewset"""
    queryset = FAQ.objects.filter(is_active=True)
    serializer_class = FAQSerializer
    filter_backends = [SearchFilter, OrderingFilter]
    search_fields = ['question', 'answer', 'category']
    ordering_fields = ['order', 'created_at']
    ordering = ['order']

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            permission_classes = [AllowAny]
        else:
            permission_classes = [IsAdminUser]
        return [permission() for permission in permission_classes]

    @action(detail=False, methods=['get'])
    def categories(self, request):
        """Get FAQ categories"""
        categories = FAQ.objects.filter(is_active=True).values_list('category', flat=True).distinct()
        return Response(list(categories))


class ProvinceViewSet(viewsets.ReadOnlyModelViewSet):
    """Provinces viewset"""
    queryset = Province.objects.filter(is_active=True)
    serializer_class = ProvinceSerializer
    permission_classes = [AllowAny]
    ordering = ['name']


class CityViewSet(viewsets.ReadOnlyModelViewSet):
    """Cities viewset"""
    queryset = City.objects.filter(is_active=True)
    serializer_class = CitySerializer
    permission_classes = [AllowAny]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['province']
    ordering = ['name']


class BannerViewSet(viewsets.ModelViewSet):
    """Banners viewset"""
    queryset = Banner.objects.all()
    serializer_class = BannerSerializer
    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filterset_fields = ['position', 'is_active']
    ordering_fields = ['order', 'created_at']
    ordering = ['position', 'order']

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            permission_classes = [AllowAny]
        else:
            permission_classes = [IsAdminUser]
        return [permission() for permission in permission_classes]

    def get_queryset(self):
        if self.action in ['list', 'retrieve'] and not self.request.user.is_staff:
            # Only show valid banners to public
            now = timezone.now()
            return Banner.objects.filter(
                is_active=True
            ).filter(
                models.Q(start_date__isnull=True) | models.Q(start_date__lte=now)
            ).filter(
                models.Q(end_date__isnull=True) | models.Q(end_date__gte=now)
            )
        return Banner.objects.all()

    @action(detail=False, methods=['get'])
    def by_position(self, request):
        """Get banners by position"""
        position = request.query_params.get('position')
        if not position:
            return Response({'error': 'موقعیت الزامی است'}, status=status.HTTP_400_BAD_REQUEST)
        
        banners = self.get_queryset().filter(position=position)
        serializer = self.get_serializer(banners, many=True)
        return Response(serializer.data)


class NewsletterViewSet(viewsets.ModelViewSet):
    """Newsletter viewset"""
    queryset = Newsletter.objects.all()
    serializer_class = NewsletterSerializer
    pagination_class = StandardResultsSetPagination
    filter_backends = [DjangoFilterBackend, SearchFilter]
    filterset_fields = ['is_active', 'confirmed']
    search_fields = ['email']
    ordering = ['-created_at']

    def get_permissions(self):
        if self.action == 'subscribe':
            permission_classes = [AllowAny]
        else:
            permission_classes = [IsAdminUser]
        return [permission() for permission in permission_classes]

    @action(detail=False, methods=['post'], permission_classes=[AllowAny])
    def subscribe(self, request):
        """Subscribe to newsletter"""
        serializer = NewsletterSubscribeSerializer(data=request.data)
        if serializer.is_valid():
            newsletter = serializer.save()
            if newsletter:
                # Send confirmation email
                # self.send_confirmation_email(newsletter)
                return Response({
                    'message': 'با موفقیت در خبرنامه عضو شدید',
                    'email': newsletter.email
                })
            return Response({'message': 'قبلاً عضو خبرنامه هستید'})
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=False, methods=['post'])
    def unsubscribe(self, request):
        """Unsubscribe from newsletter"""
        email = request.data.get('email')
        if not email:
            return Response({'error': 'ایمیل الزامی است'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            newsletter = Newsletter.objects.get(email=email)
            newsletter.is_active = False
            newsletter.save()
            return Response({'message': 'با موفقیت از خبرنامه لغو عضویت کردید'})
        except Newsletter.DoesNotExist:
            return Response({'error': 'ایمیل در خبرنامه یافت نشد'}, status=status.HTTP_404_NOT_FOUND)


    from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
from django.utils import timezone
from django.core.validators import MinValueValidator, MaxValueValidator
import uuid


class DiscountType(models.TextChoices):
    FIXED = 'fixed', _('مبلغ ثابت')
    PERCENTAGE = 'percentage', _('درصدی')


class Discount(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    code = models.CharField(_('کد تخفیف'), max_length=50, unique=True)
    discount_type = models.CharField(_('نوع تخفیف'), max_length=20, choices=DiscountType.choices)
    value = models.DecimalField(_('مقدار تخفیف'), max_digits=15, decimal_places=0)
    max_discount = models.DecimalField(_('حداکثر تخفیف'), max_digits=15, decimal_places=0, blank=True, null=True)
    min_purchase = models.DecimalField(_('حداقل خرید'), max_digits=15, decimal_places=0, default=0)
    start_date = models.DateTimeField(_('تاریخ شروع'), default=timezone.now)
    end_date = models.DateTimeField(_('تاریخ پایان'), blank=True, null=True)
    usage_limit = models.PositiveIntegerField(_('محدودیت استفاده'), blank=True, null=True)
    usage_count = models.PositiveIntegerField(_('تعداد استفاده'), default=0)
    is_active = models.BooleanField(_('فعال'), default=True)
    description = models.TextField(_('توضیحات'), blank=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    # محدودیت‌های اضافی
    is_first_purchase_only = models.BooleanField(_('فقط اولین خرید'), default=False)
    is_one_time_per_user = models.BooleanField(_('یک بار برای هر کاربر'), default=False)
    
    # محدودیت‌های کاربری
    specific_users = models.ManyToManyField(
        settings.AUTH_USER_MODEL,
        related_name='specific_discounts',
        blank=True,
        verbose_name=_('کاربران خاص')
    )
    is_for_specific_users = models.BooleanField(_('فقط برای کاربران خاص'), default=False)
    
    # محدودیت‌های محصول و دسته‌بندی
    specific_products = models.ManyToManyField(
        'products.Product',
        related_name='specific_discounts',
        blank=True,
        verbose_name=_('محصولات خاص')
    )
    specific_categories = models.ManyToManyField(
        'categories.Category',
        related_name='specific_discounts',
        blank=True,
        verbose_name=_('دسته‌بندی‌های خاص')
    )
    is_for_specific_products = models.BooleanField(_('فقط برای محصولات خاص'), default=False)
    
    class Meta:
        verbose_name = _('کد تخفیف')
        verbose_name_plural = _('کدهای تخفیف')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.code} - {self.get_discount_type_display()} {self.value}"
    
    @property
    def is_expired(self):
        if not self.end_date:
            return False
        return timezone.now() > self.end_date
    
    @property
    def is_started(self):
        return timezone.now() >= self.start_date
    
    @property
    def is_exhausted(self):
        if not self.usage_limit:
            return False
        return self.usage_count >= self.usage_limit
    
    @property
    def is_valid(self):
        return (
            self.is_active and
            self.is_started and
            not self.is_expired and
            not self.is_exhausted
        )


class DiscountUsage(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    discount = models.ForeignKey(Discount, on_delete=models.CASCADE, related_name='usages')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='discount_usages')
    order = models.ForeignKey('orders.Order', on_delete=models.CASCADE, related_name='discount_usages')
    used_at = models.DateTimeField(_('تاریخ استفاده'), auto_now_add=True)
    amount = models.DecimalField(_('مقدار تخفیف'), max_digits=15, decimal_places=0)
    
    class Meta:
        verbose_name = _('استفاده از تخفیف')
        verbose_name_plural = _('استفاده‌های تخفیف')
        ordering = ['-used_at']
        unique_together = ('discount', 'order')
    
    def __str__(self):
        return f"{self.discount.code} - {self.user.get_full_name()} - {self.amount}"


class LoyaltyPoint(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='loyalty_points')
    points = models.PositiveIntegerField(_('امتیاز'))
    reason = models.CharField(_('دلیل'), max_length=100)
    reference_id = models.CharField(_('شناسه مرجع'), max_length=100, blank=True, null=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('امتیاز وفاداری')
        verbose_name_plural = _('امتیازهای وفاداری')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.points} امتیاز - {self.reason}"


class LoyaltyReward(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(_('نام جایزه'), max_length=100)
    description = models.TextField(_('توضیحات'))
    points_required = models.PositiveIntegerField(_('امتیاز مورد نیاز'))
    reward_type_choices = [
        ('discount', _('کد تخفیف')),
        ('product', _('محصول رایگان')),
        ('shipping', _('ارسال رایگان')),
    ]
    reward_type = models.CharField(_('نوع جایزه'), max_length=20, choices=reward_type_choices)
    discount_value = models.DecimalField(_('مقدار تخفیف'), max_digits=15, decimal_places=0, blank=True, null=True)
    discount_type = models.CharField(_('نوع تخفیف'), max_length=20, choices=DiscountType.choices, blank=True, null=True)
    product = models.ForeignKey('products.Product', on_delete=models.SET_NULL, blank=True, null=True, related_name='loyalty_rewards')
    is_active = models.BooleanField(_('فعال'), default=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('جایزه وفاداری')
        verbose_name_plural = _('جوایز وفاداری')
        ordering = ['points_required']
    
    def __str__(self):
        return f"{self.name} - {self.points_required} امتیاز"


class LoyaltyRewardClaim(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='loyalty_reward_claims')
    reward = models.ForeignKey(LoyaltyReward, on_delete=models.CASCADE, related_name='claims')
    claimed_at = models.DateTimeField(_('تاریخ درخواست'), auto_now_add=True)
    status_choices = [
        ('pending', _('در انتظار')),
        ('approved', _('تایید شده')),
        ('rejected', _('رد شده')),
        ('delivered', _('تحویل داده شده')),
    ]
    status = models.CharField(_('وضعیت'), max_length=20, choices=status_choices, default='pending')
    discount_code = models.CharField(_('کد تخفیف'), max_length=50, blank=True, null=True)
    order = models.ForeignKey('orders.Order', on_delete=models.SET_NULL, blank=True, null=True, related_name='loyalty_reward_claims')
    notes = models.TextField(_('یادداشت‌ها'), blank=True)
    
    class Meta:
        verbose_name = _('درخواست جایزه وفاداری')
        verbose_name_plural = _('درخواست‌های جایزه وفاداری')
        ordering = ['-claimed_at']
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.reward.name} - {self.get_status_display()}"




from rest_framework import serializers
from django.db import transaction
from django.utils import timezone
from django.db.models import Sum
import random
import string

from .models import (
    Discount, DiscountUsage, LoyaltyPoint, LoyaltyReward, LoyaltyRewardClaim,
    DiscountType
)


class DiscountSerializer(serializers.ModelSerializer):
    discount_type_display = serializers.CharField(source='get_discount_type_display', read_only=True)
    is_expired = serializers.BooleanField(read_only=True)
    is_valid = serializers.BooleanField(read_only=True)
    
    class Meta:
        model = Discount
        fields = ('id', 'code', 'discount_type', 'discount_type_display', 'value',
                 'max_discount', 'min_purchase', 'start_date', 'end_date',
                 'usage_limit', 'usage_count', 'is_active', 'description',
                 'is_first_purchase_only', 'is_one_time_per_user',
                 'is_for_specific_users', 'is_for_specific_products',
                 'is_expired', 'is_valid', 'created_at', 'updated_at')
        read_only_fields = ('id', 'usage_count', 'created_at', 'updated_at')


class DiscountUsageSerializer(serializers.ModelSerializer):
    discount_code = serializers.CharField(source='discount.code', read_only=True)
    user_full_name = serializers.CharField(source='user.get_full_name', read_only=True)
    order_number = serializers.CharField(source='order.order_number', read_only=True)
    
    class Meta:
        model = DiscountUsage
        fields = ('id', 'discount', 'discount_code', 'user', 'user_full_name',
                 'order', 'order_number', 'used_at', 'amount')
        read_only_fields = fields


class LoyaltyPointSerializer(serializers.ModelSerializer):
    user_full_name = serializers.CharField(source='user.get_full_name', read_only=True)
    
    class Meta:
        model = LoyaltyPoint
        fields = ('id', 'user', 'user_full_name', 'points', 'reason',
                 'reference_id', 'created_at')
        read_only_fields = fields


class LoyaltyRewardSerializer(serializers.ModelSerializer):
    reward_type_display = serializers.CharField(source='get_reward_type_display', read_only=True)
    product_name = serializers.CharField(source='product.name', read_only=True)
    
    class Meta:
        model = LoyaltyReward
        fields = ('id', 'name', 'description', 'points_required', 'reward_type',
                 'reward_type_display', 'discount_value', 'discount_type',
                 'product', 'product_name', 'is_active', 'created_at', 'updated_at')
        read_only_fields = ('id', 'created_at', 'updated_at')


class LoyaltyRewardClaimSerializer(serializers.ModelSerializer):
    reward_name = serializers.CharField(source='reward.name', read_only=True)
    reward_points = serializers.IntegerField(source='reward.points_required', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    user_full_name = serializers.CharField(source='user.get_full_name', read_only=True)
    
    class Meta:
        model = LoyaltyRewardClaim
        fields = ('id', 'user', 'user_full_name', 'reward', 'reward_name',
                 'reward_points', 'claimed_at', 'status', 'status_display',
                 'discount_code', 'order', 'notes')
        read_only_fields = ('id', 'claimed_at', 'status', 'discount_code', 'order')


class ApplyDiscountSerializer(serializers.Serializer):
    code = serializers.CharField(max_length=50)
    cart_id = serializers.UUIDField()
    
    def validate(self, data):
        code = data.get('code')
        cart_id = data.get('cart_id')
        
        # بررسی کد تخفیف
        try:
            discount = Discount.objects.get(code=code, is_active=True)
        except Discount.DoesNotExist:
            raise serializers.ValidationError('کد تخفیف نامعتبر است')
        
        # بررسی اعتبار کد تخفیف
        if not discount.is_valid:
            if discount.is_expired:
                raise serializers.ValidationError('کد تخفیف منقضی شده است')
            elif discount.is_exhausted:
                raise serializers.ValidationError('کد تخفیف به حداکثر استفاده رسیده است')
            else:
                raise serializers.ValidationError('کد تخفیف نامعتبر است')
        
        # بررسی زمان شروع
        if not discount.is_started:
            raise serializers.ValidationError('کد تخفیف هنوز فعال نشده است')
        
        # بررسی سبد خرید
        from apps.orders.models import Cart, CartStatus
        try:
            cart = Cart.objects.get(id=cart_id, status=CartStatus.OPEN)
        except Cart.DoesNotExist:
            raise serializers.ValidationError('سبد خرید نامعتبر است')
        
        # بررسی کاربر
        user = self.context['request'].user
        
        # بررسی محدودیت کاربران خاص
        if discount.is_for_specific_users and not discount.specific_users.filter(id=user.id).exists():
            raise serializers.ValidationError('این کد تخفیف برای شما قابل استفاده نیست')
        
        # بررسی محدودیت اولین خرید
        if discount.is_first_purchase_only:
            from apps.orders.models import Order
            if Order.objects.filter(user=user).exists():
                raise serializers.ValidationError('این کد تخفیف فقط برای اولین خرید قابل استفاده است')
        
        # بررسی محدودیت یک بار استفاده برای هر کاربر
        if discount.is_one_time_per_user:
            if DiscountUsage.objects.filter(discount=discount, user=user).exists():
                raise serializers.ValidationError('شما قبلاً از این کد تخفیف استفاده کرده‌اید')
        
        # بررسی حداقل خرید
        cart_total = sum(item.total_price for item in cart.items.all())
        if cart_total < discount.min_purchase:
            raise serializers.ValidationError(f'حداقل مبلغ خرید برای استفاده از این کد تخفیف {discount.min_purchase} تومان است')
        
        # بررسی محدودیت محصولات خاص
        if discount.is_for_specific_products:
            # محصولات و دسته‌بندی‌های مجاز
            allowed_products = list(discount.specific_products.values_list('id', flat=True))
            allowed_categories = list(discount.specific_categories.values_list('id', flat=True))
            
            # بررسی محصولات سبد خرید
            valid_items = False
            for item in cart.items.all():
                if item.product.id in allowed_products or item.product.category.id in allowed_categories:
                    valid_items = True
                    break
            
            if not valid_items:
                raise serializers.ValidationError('این کد تخفیف فقط برای محصولات خاص قابل استفاده است')
        
        # محاسبه مبلغ تخفیف
        if discount.discount_type == DiscountType.FIXED:
            discount_amount = discount.value
        else:  # درصدی
            discount_amount = cart_total * (discount.value / 100)
            
            # اعمال حداکثر تخفیف
            if discount.max_discount and discount_amount > discount.max_discount:
                discount_amount = discount.max_discount
        
        data['discount'] = discount
        data['cart'] = cart
        data['discount_amount'] = discount_amount
        
        return data


class ClaimLoyaltyRewardSerializer(serializers.Serializer):
    reward_id = serializers.UUIDField()
    
    def validate(self, data):
        reward_id = data.get('reward_id')
        
        # بررسی جایزه
        try:
            reward = LoyaltyReward.objects.get(id=reward_id, is_active=True)
        except LoyaltyReward.DoesNotExist:
            raise serializers.ValidationError('جایزه مورد نظر یافت نشد یا غیرفعال است')
        
        # بررسی امتیاز کاربر
        user = self.context['request'].user
        user_profile = user.profile
        
        if user_profile.loyalty_points < reward.points_required:
            raise serializers.ValidationError('امتیاز شما برای دریافت این جایزه کافی نیست')
        
        data['reward'] = reward
        return data
    
    @transaction.atomic
    def create(self, validated_data):
        reward = validated_data['reward']
        user = self.context['request'].user
        
        # کسر امتیاز از کاربر
        user_profile = user.profile
        user_profile.loyalty_points -= reward.points_required
        user_profile.save()
        
        # ثبت کسر امتیاز
        LoyaltyPoint.objects.create(
            user=user,
            points=-reward.points_required,
            reason=f"استفاده برای جایزه: {reward.name}",
            reference_id=str(reward.id)
        )
        
        # ایجاد درخواست جایزه
        claim = LoyaltyRewardClaim.objects.create(
            user=user,
            reward=reward,
            status='pending'
        )
        
        # اگر جایزه کد تخفیف است، به صورت خودکار ایجاد و تایید می‌شود
        if reward.reward_type == 'discount':
            # ایجاد کد تخفیف یکتا
            discount_code = f"LOYAL-{user.id}-{''.join(random.choices(string.ascii_uppercase + string.digits, k=6))}"
            
            # ایجاد کد تخفیف
            discount = Discount.objects.create(
                code=discount_code,
                discount_type=reward.discount_type,
                value=reward.discount_value,
                is_one_time_per_user=True,
                is_for_specific_users=True,
                start_date=timezone.now(),
                end_date=timezone.now() + timezone.timedelta(days=30),
                description=f"کد تخفیف جایزه وفاداری: {reward.name}"
            )
            
            # اضافه کردن کاربر به لیست کاربران مجاز
            discount.specific_users.add(user)
            
            # به‌روزرسانی درخواست جایزه
            claim.status = 'approved'
            claim.discount_code = discount_code
            claim.notes = "کد تخفیف به صورت خودکار ایجاد شد"
            claim.save()
        
        return claim


from rest_framework import viewsets, permissions, status, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db import transaction
from django.db.models import Sum
from django.utils import timezone
import uuid

from .models import (
    Discount, DiscountUsage, LoyaltyPoint, LoyaltyReward, LoyaltyRewardClaim,
    DiscountType
)
from .serializers import (
    DiscountSerializer, DiscountUsageSerializer, LoyaltyPointSerializer,
    LoyaltyRewardSerializer, LoyaltyRewardClaimSerializer,
    ApplyDiscountSerializer, ClaimLoyaltyRewardSerializer
)
from apps.sellers.permissions import IsAdminUser


class DiscountViewSet(viewsets.ModelViewSet):
    queryset = Discount.objects.all()
    serializer_class = DiscountSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس وضعیت
        is_active = self.request.query_params.get('is_active')
        if is_active is not None:
            queryset = queryset.filter(is_active=is_active == 'true')
        
        # فیلتر بر اساس نوع تخفیف
        discount_type = self.request.query_params.get('discount_type')
        if discount_type:
            queryset = queryset.filter(discount_type=discount_type)
        
        # فیلتر بر اساس تاریخ
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        
        if start_date:
            queryset = queryset.filter(start_date__gte=start_date)
        if end_date:
            queryset = queryset.filter(end_date__lte=end_date)
        
        return queryset


class DiscountUsageViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = DiscountUsage.objects.all()
    serializer_class = DiscountUsageSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس کد تخفیف
        discount_id = self.request.query_params.get('discount_id')
        if discount_id:
            queryset = queryset.filter(discount_id=discount_id)
        
        # فیلتر بر اساس کاربر
        user_id = self.request.query_params.get('user_id')
        if user_id:
            queryset = queryset.filter(user_id=user_id)
        
        # فیلتر بر اساس تاریخ
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        
        if start_date:
            queryset = queryset.filter(used_at__gte=start_date)
        if end_date:
            queryset = queryset.filter(used_at__lte=end_date)
        
        return queryset


class ApplyDiscountView(generics.GenericAPIView):
    serializer_class = ApplyDiscountSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        discount = serializer.validated_data['discount']
        cart = serializer.validated_data['cart']
        discount_amount = serializer.validated_data['discount_amount']
        
        # ذخیره کد تخفیف در سبد خرید
        cart.discount_code = discount.code
        cart.discount_amount = discount_amount
        cart.save()
        
        return Response({
            'status': 'کد تخفیف با موفقیت اعمال شد',
            'discount_code': discount.code,
            'discount_amount': discount_amount,
            'cart_total_before_discount': sum(item.total_price for item in cart.items.all()),
            'cart_total_after_discount': sum(item.total_price for item in cart.items.all()) - discount_amount
        })


class LoyaltyRewardViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = LoyaltyReward.objects.filter(is_active=True)
    serializer_class = LoyaltyRewardSerializer
    permission_classes = [permissions.IsAuthenticated]


class LoyaltyPointViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = LoyaltyPointSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return LoyaltyPoint.objects.filter(user=self.request.user).order_by('-created_at')
    
    @action(detail=False, methods=['get'])
    def summary(self, request):
        user = request.user
        
        # محاسبه مجموع امتیازات
        points = LoyaltyPoint.objects.filter(user=user).aggregate(total=Sum('points'))['total'] or 0
        
        # امتیازات کسب شده
        earned_points = LoyaltyPoint.objects.filter(user=user, points__gt=0).aggregate(total=Sum('points'))['total'] or 0
        
        # امتیازات استفاده شده
        used_points = abs(LoyaltyPoint.objects.filter(user=user, points__lt=0).aggregate(total=Sum('points'))['total'] or 0)
        
        # تاریخچه امتیازات
        recent_points = LoyaltyPoint.objects.filter(user=user).order_by('-created_at')[:5]
        
        return Response({
            'total_points': user.profile.loyalty_points,
            'earned_points': earned_points,
            'used_points': used_points,
            'recent_activity': LoyaltyPointSerializer(recent_points, many=True).data
        })


class LoyaltyRewardClaimViewSet(viewsets.ModelViewSet):
    serializer_class = LoyaltyRewardClaimSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return LoyaltyRewardClaim.objects.filter(user=self.request.user).order_by('-claimed_at')
    
    def create(self, request, *args, **kwargs):
        serializer = ClaimLoyaltyRewardSerializer(data=request.data, context={'request': request})
        serializer.is_valid(raise_exception=True)
        claim = serializer.save()
        
        return Response(
            LoyaltyRewardClaimSerializer(claim).data,
            status=status.HTTP_201_CREATED
        )


class AdminLoyaltyRewardViewSet(viewsets.ModelViewSet):
    queryset = LoyaltyReward.objects.all()
    serializer_class = LoyaltyRewardSerializer
    permission_classes = [IsAdminUser]


class AdminLoyaltyPointViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = LoyaltyPoint.objects.all()
    serializer_class = LoyaltyPointSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس کاربر
        user_id = self.request.query_params.get('user_id')
        if user_id:
            queryset = queryset.filter(user_id=user_id)
        
        return queryset


class AdminLoyaltyRewardClaimViewSet(viewsets.ModelViewSet):
    queryset = LoyaltyRewardClaim.objects.all().order_by('-claimed_at')
    serializer_class = LoyaltyRewardClaimSerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=True, methods=['post'])
    def update_status(self, request, pk=None):
        claim = self.get_object()
        new_status = request.data.get('status')
        notes = request.data.get('notes', '')
        
        if new_status not in ['approved', 'rejected', 'delivered']:
            return Response({'error': 'وضعیت نامعتبر است'}, status=status.HTTP_400_BAD_REQUEST)
        
        with transaction.atomic():
            # به‌روزرسانی وضعیت درخواست
            claim.status = new_status
            claim.notes = notes
            claim.save()
            
            # اگر درخواست رد شده، امتیازات را برگردان
            if new_status == 'rejected':
                user_profile = claim.user.profile
                user_profile.loyalty_points += claim.reward.points_required
                user_profile.save()
                
                # ثبت برگشت امتیاز
                LoyaltyPoint.objects.create(
                    user=claim.user,
                    points=claim.reward.points_required,
                    reason=f"برگشت امتیاز به دلیل رد درخواست جایزه: {claim.reward.name}",
                    reference_id=str(claim.id)
                )
        
        return Response({'status': 'وضعیت درخواست با موفقیت به‌روزرسانی شد'})


class AdminManualPointsView(generics.GenericAPIView):
    permission_classes = [IsAdminUser]
    
    def post(self, request, *args, **kwargs):
        user_id = request.data.get('user_id')
        points = request.data.get('points')
        reason = request.data.get('reason', 'تنظیم دستی توسط مدیر')
        
        if not user_id or not points:
            return Response({'error': 'شناسه کاربر و امتیاز الزامی هستند'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            from django.contrib.auth import get_user_model
            User = get_user_model()
            user = User.objects.get(id=user_id)
        except User.DoesNotExist:
            return Response({'error': 'کاربر یافت نشد'}, status=status.HTTP_404_NOT_FOUND)
        
        try:
            points = int(points)
        except ValueError:
            return Response({'error': 'امتیاز باید عددی باشد'}, status=status.HTTP_400_BAD_REQUEST)
        
        with transaction.atomic():
            # به‌روزرسانی امتیاز کاربر
            user_profile = user.profile
            user_profile.loyalty_points += points
            user_profile.save()
            
            # ثبت تغییر امتیاز
            loyalty_point = LoyaltyPoint.objects.create(
                user=user,
                points=points,
                reason=reason,
                reference_id=f"ADMIN-{uuid.uuid4().hex[:8]}"
            )
        
        return Response({
            'status': 'امتیاز با موفقیت اضافه شد',
            'user': user.get_full_name(),
            'points_added': points,
            'new_total_points': user_profile.loyalty_points,
            'loyalty_point': LoyaltyPointSerializer(loyalty_point).data
        })

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'admin/discounts', views.DiscountViewSet)
router.register(r'admin/discount-usages', views.DiscountUsageViewSet)
router.register(r'rewards', views.LoyaltyRewardViewSet)
router.register(r'loyalty-points', views.LoyaltyPointViewSet, basename='loyalty-points')
router.register(r'reward-claims', views.LoyaltyRewardClaimViewSet, basename='reward-claims')
router.register(r'admin/rewards', views.AdminLoyaltyRewardViewSet, basename='admin-rewards')
router.register(r'admin/loyalty-points', views.AdminLoyaltyPointViewSet, basename='admin-loyalty-points')
router.register(r'admin/reward-claims', views.AdminLoyaltyRewardClaimViewSet, basename='admin-reward-claims')

urlpatterns = [
    path('', include(router.urls)),
    path('apply-discount/', views.ApplyDiscountView.as_view(), name='apply-discount'),
    path('admin/manual-points/', views.AdminManualPointsView.as_view(), name='admin-manual-points'),
]




from django.db import models
from django.contrib.auth import get_user_model
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from apps.common.models import BaseModel

User = get_user_model()


class Notification(BaseModel):
    """Notification model for user notifications"""
    TYPE_CHOICES = [
        ('order', 'سفارش'),
        ('payment', 'پرداخت'),
        ('product', 'محصول'),
        ('comment', 'نظر'),
        ('review', 'بررسی'),
        ('account', 'حساب کاربری'),
        ('system', 'سیستمی'),
        ('promotion', 'تبلیغاتی'),
    ]
    
    PRIORITY_CHOICES = [
        ('low', 'کم'),
        ('medium', 'متوسط'),
        ('high', 'زیاد'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='notifications', verbose_name='کاربر')
    type = models.CharField(max_length=20, choices=TYPE_CHOICES, verbose_name='نوع')
    title = models.CharField(max_length=255, verbose_name='عنوان')
    message = models.TextField(verbose_name='پیام')
    is_read = models.BooleanField(default=False, verbose_name='خوانده شده')
    read_at = models.DateTimeField(null=True, blank=True, verbose_name='زمان خواندن')
    priority = models.CharField(max_length=10, choices=PRIORITY_CHOICES, default='medium', verbose_name='اولویت')
    
    # Link to related object (optional)
    content_type = models.ForeignKey(ContentType, on_delete=models.SET_NULL, null=True, blank=True, verbose_name='نوع محتوا')
    object_id = models.CharField(max_length=50, null=True, blank=True, verbose_name='شناسه محتوا')
    content_object = GenericForeignKey('content_type', 'object_id')
    
    # Additional data as JSON
    data = models.JSONField(default=dict, blank=True, verbose_name='داده‌های اضافی')
    
    # Action URL
    action_url = models.CharField(max_length=255, blank=True, verbose_name='لینک عمل')
    
    class Meta:
        verbose_name = 'اعلان'
        verbose_name_plural = 'اعلان‌ها'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', '-created_at']),
            models.Index(fields=['user', 'is_read']),
        ]
    
    def __str__(self):
        return f"{self.user.phone} - {self.title}"
    
    def mark_as_read(self):
        """Mark notification as read"""
        from django.utils import timezone
        if not self.is_read:
            self.is_read = True
            self.read_at = timezone.now()
            self.save(update_fields=['is_read', 'read_at'])


class NotificationSetting(models.Model):
    """User notification preferences"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='notification_settings', verbose_name='کاربر')
    
    # Email notifications
    email_order = models.BooleanField(default=True, verbose_name='اعلان سفارش از طریق ایمیل')
    email_payment = models.BooleanField(default=True, verbose_name='اعلان پرداخت از طریق ایمیل')
    email_product = models.BooleanField(default=True, verbose_name='اعلان محصول از طریق ایمیل')
    email_comment = models.BooleanField(default=True, verbose_name='اعلان نظر از طریق ایمیل')
    email_review = models.BooleanField(default=True, verbose_name='اعلان بررسی از طریق ایمیل')
    email_account = models.BooleanField(default=True, verbose_name='اعلان حساب کاربری از طریق ایمیل')
    email_system = models.BooleanField(default=True, verbose_name='اعلان سیستمی از طریق ایمیل')
    email_promotion = models.BooleanField(default=False, verbose_name='اعلان تبلیغاتی از طریق ایمیل')
    
    # SMS notifications
    sms_order = models.BooleanField(default=True, verbose_name='اعلان سفارش از طریق پیامک')
    sms_payment = models.BooleanField(default=True, verbose_name='اعلان پرداخت از طریق پیامک')
    sms_product = models.BooleanField(default=False, verbose_name='اعلان محصول از طریق پیامک')
    sms_comment = models.BooleanField(default=False, verbose_name='اعلان نظر از طریق پیامک')
    sms_review = models.BooleanField(default=False, verbose_name='اعلان بررسی از طریق پیامک')
    sms_account = models.BooleanField(default=True, verbose_name='اعلان حساب کاربری از طریق پیامک')
    sms_system = models.BooleanField(default=True, verbose_name='اعلان سیستمی از طریق پیامک')
    sms_promotion = models.BooleanField(default=False, verbose_name='اعلان تبلیغاتی از طریق پیامک')
    
    # Push notifications
    push_order = models.BooleanField(default=True, verbose_name='اعلان سفارش از طریق نوتیفیکیشن')
    push_payment = models.BooleanField(default=True, verbose_name='اعلان پرداخت از طریق نوتیفیکیشن')
    push_product = models.BooleanField(default=True, verbose_name='اعلان محصول از طریق نوتیفیکیشن')
    push_comment = models.BooleanField(default=True, verbose_name='اعلان نظر از طریق نوتیفیکیشن')
    push_review = models.BooleanField(default=True, verbose_name='اعلان بررسی از طریق نوتیفیکیشن')
    push_account = models.BooleanField(default=True, verbose_name='اعلان حساب کاربری از طریق نوتیفیکیشن')
    push_system = models.BooleanField(default=True, verbose_name='اعلان سیستمی از طریق نوتیفیکیشن')
    push_promotion = models.BooleanField(default=False, verbose_name='اعلان تبلیغاتی از طریق نوتیفیکیشن')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='تاریخ ایجاد')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='تاریخ بروزرسانی')
    
    class Meta:
        verbose_name = 'تنظیمات اعلان'
        verbose_name_plural = 'تنظیمات اعلان‌ها'
    
    def __str__(self):
        return f"تنظیمات اعلان {self.user.phone}"
    
    @classmethod
    def get_or_create_settings(cls, user):
        """Get or create notification settings for a user"""
        settings, created = cls.objects.get_or_create(user=user)
        return settings


class DeviceToken(models.Model):
    """Device tokens for push notifications"""
    PLATFORM_CHOICES = [
        ('android', 'Android'),
        ('ios', 'iOS'),
        ('web', 'Web'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='device_tokens', verbose_name='کاربر')
    token = models.TextField(verbose_name='توکن دستگاه')
    platform = models.CharField(max_length=10, choices=PLATFORM_CHOICES, verbose_name='پلتفرم')
    device_name = models.CharField(max_length=255, blank=True, verbose_name='نام دستگاه')
    is_active = models.BooleanField(default=True, verbose_name='فعال')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='تاریخ ایجاد')
    last_used_at = models.DateTimeField(auto_now=True, verbose_name='آخرین استفاده')
    
    class Meta:
        verbose_name = 'توکن دستگاه'
        verbose_name_plural = 'توکن‌های دستگاه'
        unique_together = ['user', 'token']
    
    def __str__(self):
        return f"{self.user.phone} - {self.get_platform_display()} - {self.device_name}"



    from rest_framework import serializers
from .models import Notification, NotificationSetting, DeviceToken


class NotificationSerializer(serializers.ModelSerializer):
    type_display = serializers.CharField(source='get_type_display', read_only=True)
    priority_display = serializers.CharField(source='get_priority_display', read_only=True)
    
    class Meta:
        model = Notification
        fields = [
            'id', 'type', 'type_display', 'title', 'message', 'is_read',
            'read_at', 'priority', 'priority_display', 'action_url', 'data',
            'created_at'
        ]
        read_only_fields = ['id', 'created_at']


class NotificationSettingSerializer(serializers.ModelSerializer):
    class Meta:
        model = NotificationSetting
        exclude = ['user', 'created_at', 'updated_at']
    
    def update(self, instance, validated_data):
        instance = super().update(instance, validated_data)
        return instance


class DeviceTokenSerializer(serializers.ModelSerializer):
    platform_display = serializers.CharField(source='get_platform_display', read_only=True)
    
    class Meta:
        model = DeviceToken
        fields = [
            'id', 'token', 'platform', 'platform_display', 'device_name',
            'is_active', 'created_at', 'last_used_at'
        ]
        read_only_fields = ['id', 'created_at', 'last_used_at']
    
    def validate(self, data):
        # Check if token already exists for this user
        user = self.context['request'].user
        token = data.get('token')
        
        if self.instance is None:  # Creating new token
            if DeviceToken.objects.filter(user=user, token=token).exists():
                raise serializers.ValidationError("این توکن قبلاً برای این کاربر ثبت شده است")
        
        return data
    
    def create(self, validated_data):
        validated_data['user'] = self.context['request'].user
        return super().create(validated_data)


class NotificationCountSerializer(serializers.Serializer):
    total = serializers.IntegerField()
    unread = serializers.IntegerField()


class BulkNotificationActionSerializer(serializers.Serializer):
    notification_ids = serializers.ListField(
        child=serializers.UUIDField(),
        required=True
    )
    action = serializers.ChoiceField(
        choices=['mark_read', 'mark_unread', 'delete'],
        required=True
    )


from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register('', views.NotificationViewSet, basename='notification')
router.register('settings', views.NotificationSettingViewSet, basename='notification-settings')
router.register('devices', views.DeviceTokenViewSet, basename='device-token')

urlpatterns = [
    path('', include(router.urls)),
]



from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.utils import timezone
from django.db.models import Q, Count
from .models import Notification, NotificationSetting, DeviceToken
from .serializers import (
    NotificationSerializer, NotificationSettingSerializer, DeviceTokenSerializer,
    NotificationCountSerializer, BulkNotificationActionSerializer
)
from apps.common.pagination import StandardResultsSetPagination


class NotificationViewSet(viewsets.ModelViewSet):
    """Notification viewset for user notifications"""
    serializer_class = NotificationSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        return Notification.objects.filter(user=self.request.user).order_by('-created_at')
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
    
    @action(detail=True, methods=['post'])
    def mark_as_read(self, request, pk=None):
        """Mark a notification as read"""
        notification = self.get_object()
        notification.mark_as_read()
        return Response({'message': 'اعلان به عنوان خوانده شده علامت‌گذاری شد'})
    
    @action(detail=True, methods=['post'])
    def mark_as_unread(self, request, pk=None):
        """Mark a notification as unread"""
        notification = self.get_object()
        notification.is_read = False
        notification.read_at = None
        notification.save()
        return Response({'message': 'اعلان به عنوان خوانده نشده علامت‌گذاری شد'})
    
    @action(detail=False, methods=['post'])
    def mark_all_as_read(self, request):
        """Mark all notifications as read"""
        Notification.objects.filter(user=request.user, is_read=False).update(
            is_read=True,
            read_at=timezone.now()
        )
        return Response({'message': 'همه اعلان‌ها به عنوان خوانده شده علامت‌گذاری شدند'})
    
    @action(detail=False, methods=['get'])
    def unread(self, request):
        """Get unread notifications"""
        queryset = self.get_queryset().filter(is_read=False)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def count(self, request):
        """Get notification counts"""
        total = self.get_queryset().count()
        unread = self.get_queryset().filter(is_read=False).count()
        
        serializer = NotificationCountSerializer({
            'total': total,
            'unread': unread
        })
        return Response(serializer.data)
    
    @action(detail=False, methods=['post'])
    def bulk_action(self, request):
        """Perform bulk action on notifications"""
        serializer = BulkNotificationActionSerializer(data=request.data)
        if serializer.is_valid():
            notification_ids = serializer.validated_data['notification_ids']
            action = serializer.validated_data['action']
            
            notifications = self.get_queryset().filter(id__in=notification_ids)
            
            if action == 'mark_read':
                notifications.update(is_read=True, read_at=timezone.now())
                return Response({'message': f'{notifications.count()} اعلان به عنوان خوانده شده علامت‌گذاری شد'})
            elif action == 'mark_unread':
                notifications.update(is_read=False, read_at=None)
                return Response({'message': f'{notifications.count()} اعلان به عنوان خوانده نشده علامت‌گذاری شد'})
            elif action == 'delete':
                count = notifications.count()
                notifications.delete()
                return Response({'message': f'{count} اعلان حذف شد'})
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=False, methods=['get'])
    def by_type(self, request):
        """Get notifications grouped by type"""
        notification_type = request.query_params.get('type')
        if not notification_type:
            return Response(
                {"error": "نوع اعلان الزامی است"},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        queryset = self.get_queryset().filter(type=notification_type)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class NotificationSettingViewSet(viewsets.ModelViewSet):
    """Notification settings viewset"""
    serializer_class = NotificationSettingSerializer
    permission_classes = [IsAuthenticated]
    
    def get_object(self):
        return NotificationSetting.get_or_create_settings(self.request.user)
    
    def list(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance)
        return Response(serializer.data)
    
    def update(self, request, *args, **kwargs):
        partial = kwargs.pop('partial', False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)
    
    def perform_update(self, serializer):
        serializer.save()


class DeviceTokenViewSet(viewsets.ModelViewSet):
    """Device token viewset for push notifications"""
    serializer_class = DeviceTokenSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return DeviceToken.objects.filter(user=self.request.user)
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
    
    @action(detail=True, methods=['post'])
    def deactivate(self, request, pk=None):
        """Deactivate a device token"""
        device_token = self.get_object()
        device_token.is_active = False
        device_token.save()
        return Response({'message': 'توکن دستگاه غیرفعال شد'})



from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
from django.core.validators import MinValueValidator, MaxValueValidator
import uuid


class CartStatus(models.TextChoices):
    OPEN = 'open', _('باز')
    CHECKOUT = 'checkout', _('در حال تسویه')
    ABANDONED = 'abandoned', _('رها شده')
    CONVERTED = 'converted', _('تبدیل شده به سفارش')


class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, 
                           related_name='carts', null=True, blank=True)
    session_key = models.CharField(_('کلید نشست'), max_length=40, null=True, blank=True)
    status = models.CharField(_('وضعیت'), max_length=20, choices=CartStatus.choices, default=CartStatus.OPEN)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('سبد خرید')
        verbose_name_plural = _('سبدهای خرید')
        ordering = ['-updated_at']
    
    def __str__(self):
        if self.user:
            return f"سبد خرید {self.user.get_full_name()}"
        return f"سبد خرید مهمان {self.session_key}"
    
    @property
    def total_price(self):
        return sum(item.total_price for item in self.items.all())
    
    @property
    def total_discount(self):
        return sum(item.total_discount for item in self.items.all())
    
    @property
    def total_items_count(self):
        return sum(item.quantity for item in self.items.all())


class CartItem(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name='items')
    product = models.ForeignKey('products.Product', on_delete=models.CASCADE)
    variant = models.ForeignKey('products.ProductVariant', on_delete=models.CASCADE, 
                              null=True, blank=True)
    quantity = models.PositiveIntegerField(_('تعداد'), default=1)
    unit_price = models.DecimalField(_('قیمت واحد'), max_digits=15, decimal_places=0)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('آیتم سبد خرید')
        verbose_name_plural = _('آیتم‌های سبد خرید')
        unique_together = ('cart', 'product', 'variant')
    
    def __str__(self):
        variant_name = f" - {self.variant.name}" if self.variant else ""
        return f"{self.product.name}{variant_name} x {self.quantity}"
    
    @property
    def total_price(self):
        return self.unit_price * self.quantity
    
    @property
    def total_discount(self):
        if self.product.discount_price:
            return (self.product.price - self.product.discount_price) * self.quantity
        return 0


class OrderStatus(models.TextChoices):
    PENDING = 'pending', _('در انتظار پرداخت')
    PAID = 'paid', _('پرداخت شده')
    PROCESSING = 'processing', _('در حال پردازش')
    SHIPPED = 'shipped', _('ارسال شده')
    DELIVERED = 'delivered', _('تحویل داده شده')
    CANCELLED = 'cancelled', _('لغو شده')
    REFUNDED = 'refunded', _('مسترد شده')


class Order(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='orders')
    order_number = models.CharField(_('شماره سفارش'), max_length=20, unique=True)
    status = models.CharField(_('وضعیت'), max_length=20, choices=OrderStatus.choices, default=OrderStatus.PENDING)
    total_price = models.DecimalField(_('مبلغ کل'), max_digits=15, decimal_places=0)
    total_discount = models.DecimalField(_('تخفیف کل'), max_digits=15, decimal_places=0, default=0)
    shipping_cost = models.DecimalField(_('هزینه ارسال'), max_digits=15, decimal_places=0, default=0)
    tax = models.DecimalField(_('مالیات'), max_digits=15, decimal_places=0, default=0)
    final_price = models.DecimalField(_('مبلغ نهایی'), max_digits=15, decimal_places=0)
    description = models.TextField(_('توضیحات'), blank=True)
    shipping_address = models.ForeignKey('accounts.Address', on_delete=models.PROTECT, 
                                       related_name='orders')
    shipping_method = models.ForeignKey('shipping.ShippingMethod', on_delete=models.PROTECT,
                                      related_name='orders')
    tracking_code = models.CharField(_('کد پیگیری'), max_length=100, blank=True, null=True)
    payment_method = models.CharField(_('روش پرداخت'), max_length=50)
    payment_ref_id = models.CharField(_('شناسه پرداخت'), max_length=100, blank=True, null=True)
    payment_date = models.DateTimeField(_('تاریخ پرداخت'), blank=True, null=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('سفارش')
        verbose_name_plural = _('سفارشات')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"سفارش {self.order_number} - {self.user.get_full_name()}"


class OrderItem(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='items')
    product = models.ForeignKey('products.Product', on_delete=models.PROTECT)
    variant = models.ForeignKey('products.ProductVariant', on_delete=models.PROTECT, 
                              null=True, blank=True)
    seller = models.ForeignKey('sellers.Seller', on_delete=models.PROTECT)
    product_name = models.CharField(_('نام محصول'), max_length=200)
    variant_name = models.CharField(_('نام تنوع'), max_length=100, blank=True, null=True)
    quantity = models.PositiveIntegerField(_('تعداد'))
    unit_price = models.DecimalField(_('قیمت واحد'), max_digits=15, decimal_places=0)
    discount = models.DecimalField(_('تخفیف واحد'), max_digits=15, decimal_places=0, default=0)
    final_price = models.DecimalField(_('قیمت نهایی واحد'), max_digits=15, decimal_places=0)
    total_price = models.DecimalField(_('قیمت کل'), max_digits=15, decimal_places=0)
    commission = models.DecimalField(_('کمیسیون'), max_digits=15, decimal_places=0, default=0)
    status = models.CharField(_('وضعیت'), max_length=20, choices=OrderStatus.choices, 
                            default=OrderStatus.PENDING)
    
    class Meta:
        verbose_name = _('آیتم سفارش')
        verbose_name_plural = _('آیتم‌های سفارش')
    
    def __str__(self):
        variant_name = f" - {self.variant_name}" if self.variant_name else ""
        return f"{self.product_name}{variant_name} x {self.quantity}"


class OrderHistory(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='history')
    status = models.CharField(_('وضعیت'), max_length=20, choices=OrderStatus.choices)
    description = models.TextField(_('توضیحات'), blank=True)
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL,
                                 null=True, blank=True, related_name='order_status_changes')
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('تاریخچه سفارش')
        verbose_name_plural = _('تاریخچه سفارشات')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"سفارش {self.order.order_number} - {self.get_status_display()}"


class OrderReturn(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    order_item = models.ForeignKey(OrderItem, on_delete=models.CASCADE, related_name='returns')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='returns')
    reason = models.TextField(_('دلیل مرجوعی'))
    quantity = models.PositiveIntegerField(_('تعداد'))
    status_choices = [
        ('pending', _('در انتظار بررسی')),
        ('approved', _('تایید شده')),
        ('rejected', _('رد شده')),
        ('returned', _('بازگشت داده شده')),
        ('refunded', _('مسترد شده')),
    ]
    status = models.CharField(_('وضعیت'), max_length=20, choices=status_choices, default='pending')
    admin_note = models.TextField(_('یادداشت مدیر'), blank=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('مرجوعی سفارش')
        verbose_name_plural = _('مرجوعی‌های سفارش')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"مرجوعی {self.order_item.product_name} - {self.user.get_full_name()}"


class OrderReturnImage(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    order_return = models.ForeignKey(OrderReturn, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(_('تصویر'), upload_to='return_images/')
    
    class Meta:
        verbose_name = _('تصویر مرجوعی')
        verbose_name_plural = _('تصاویر مرجوعی')
    
    def __str__(self):
        return f"تصویر مرجوعی {self.order_return.id}"


class Invoice(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    order = models.OneToOneField(Order, on_delete=models.CASCADE, related_name='invoice')
    invoice_number = models.CharField(_('شماره فاکتور'), max_length=20, unique=True)
    issue_date = models.DateTimeField(_('تاریخ صدور'), auto_now_add=True)
    due_date = models.DateTimeField(_('تاریخ سررسید'), blank=True, null=True)
    is_paid = models.BooleanField(_('پرداخت شده'), default=False)
    payment_date = models.DateTimeField(_('تاریخ پرداخت'), blank=True, null=True)
    
    class Meta:
        verbose_name = _('فاکتور')
        verbose_name_plural = _('فاکتورها')
    
    def __str__(self):
        return f"فاکتور {self.invoice_number} - {self.order.order_number}"


class InstallmentPlan(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    order = models.OneToOneField(Order, on_delete=models.CASCADE, related_name='installment_plan')
    total_amount = models.DecimalField(_('مبلغ کل'), max_digits=15, decimal_places=0)
    down_payment = models.DecimalField(_('پیش پرداخت'), max_digits=15, decimal_places=0)
    number_of_installments = models.PositiveSmallIntegerField(_('تعداد اقساط'))
    installment_amount = models.DecimalField(_('مبلغ هر قسط'), max_digits=15, decimal_places=0)
    interest_rate = models.DecimalField(_('نرخ سود'), max_digits=5, decimal_places=2, default=0)
    start_date = models.DateField(_('تاریخ شروع'))
    status_choices = [
        ('active', _('فعال')),
        ('completed', _('تکمیل شده')),
        ('defaulted', _('معوق')),
        ('cancelled', _('لغو شده')),
    ]
    status = models.CharField(_('وضعیت'), max_length=20, choices=status_choices, default='active')
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('طرح اقساطی')
        verbose_name_plural = _('طرح‌های اقساطی')
    
    def __str__(self):
        return f"طرح اقساطی {self.order.order_number} - {self.number_of_installments} قسط"


class Installment(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    plan = models.ForeignKey(InstallmentPlan, on_delete=models.CASCADE, related_name='installments')
    amount = models.DecimalField(_('مبلغ'), max_digits=15, decimal_places=0)
    due_date = models.DateField(_('تاریخ سررسید'))
    is_paid = models.BooleanField(_('پرداخت شده'), default=False)
    payment_date = models.DateTimeField(_('تاریخ پرداخت'), blank=True, null=True)
    payment_ref_id = models.CharField(_('شناسه پرداخت'), max_length=100, blank=True, null=True)
    
    class Meta:
        verbose_name = _('قسط')
        verbose_name_plural = _('اقساط')
        ordering = ['due_date']
    
    def __str__(self):
        status = 'پرداخت شده' if self.is_paid else 'پرداخت نشده'
        return f"قسط {self.due_date} - {self.amount} - {status}"




from rest_framework import serializers
from django.db import transaction
from django.utils import timezone
from django.utils.crypto import get_random_string
from .models import (
    Cart, CartItem, Order, OrderItem, OrderHistory, OrderReturn, OrderReturnImage,
    Invoice, InstallmentPlan, Installment
)
from apps.products.serializers import ProductListSerializer
from apps.accounts.serializers import AddressSerializer
from apps.shipping.serializers import ShippingMethodSerializer


class CartItemSerializer(serializers.ModelSerializer):
    product = ProductListSerializer(read_only=True)
    product_id = serializers.UUIDField(write_only=True)
    variant_id = serializers.UUIDField(write_only=True, required=False, allow_null=True)
    
    class Meta:
        model = CartItem
        fields = ('id', 'product', 'product_id', 'variant', 'variant_id', 'quantity', 
                 'unit_price', 'total_price', 'total_discount', 'created_at')
        read_only_fields = ('id', 'unit_price', 'total_price', 'total_discount', 'created_at')
    
    def validate(self, data):
        product_id = data.get('product_id')
        variant_id = data.get('variant_id')
        quantity = data.get('quantity', 1)
        
        from apps.products.models import Product, ProductVariant
        
        try:
            product = Product.objects.get(id=product_id, is_active=True, is_approved=True)
        except Product.DoesNotExist:
            raise serializers.ValidationError('محصول مورد نظر یافت نشد یا غیرفعال است')
        
        variant = None
        if variant_id:
            try:
                variant = ProductVariant.objects.get(id=variant_id, product=product)
            except ProductVariant.DoesNotExist:
                raise serializers.ValidationError('تنوع مورد نظر یافت نشد')
            
            if quantity > variant.stock:
                raise serializers.ValidationError('موجودی کافی نیست')
        else:
            if quantity > product.stock:
                raise serializers.ValidationError('موجودی کافی نیست')
        
        data['product'] = product
        data['variant'] = variant
        return data


class CartSerializer(serializers.ModelSerializer):
    items = CartItemSerializer(many=True, read_only=True)
    total_price = serializers.DecimalField(max_digits=15, decimal_places=0, read_only=True)
    total_discount = serializers.DecimalField(max_digits=15, decimal_places=0, read_only=True)
    total_items_count = serializers.IntegerField(read_only=True)
    
    class Meta:
        model = Cart
        fields = ('id', 'status', 'created_at', 'updated_at', 'items', 
                 'total_price', 'total_discount', 'total_items_count')
        read_only_fields = ('id', 'status', 'created_at', 'updated_at')


class OrderItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = OrderItem
        fields = ('id', 'product', 'variant', 'seller', 'product_name', 'variant_name',
                 'quantity', 'unit_price', 'discount', 'final_price', 'total_price', 'status')
        read_only_fields = fields


class OrderHistorySerializer(serializers.ModelSerializer):
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    created_by_name = serializers.SerializerMethodField()
    
    class Meta:
        model = OrderHistory
        fields = ('id', 'status', 'status_display', 'description', 
                 'created_by', 'created_by_name', 'created_at')
        read_only_fields = fields
    
    def get_created_by_name(self, obj):
        if obj.created_by:
            return obj.created_by.get_full_name()
        return None


class OrderReturnImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = OrderReturnImage
        fields = ('id', 'image')


class OrderReturnSerializer(serializers.ModelSerializer):
    images = OrderReturnImageSerializer(many=True, read_only=True)
    uploaded_images = serializers.ListField(
        child=serializers.ImageField(max_length=1000000, allow_empty_file=False, use_url=False),
        write_only=True, required=False
    )
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    
    class Meta:
        model = OrderReturn
        fields = ('id', 'order_item', 'reason', 'quantity', 'status', 'status_display',
                 'admin_note', 'created_at', 'updated_at', 'images', 'uploaded_images')
        read_only_fields = ('id', 'status', 'admin_note', 'created_at', 'updated_at')
    
    def validate(self, data):
        order_item = data.get('order_item')
        quantity = data.get('quantity')
        
        # بررسی اینکه آیتم سفارش متعلق به کاربر باشد
        if order_item.order.user != self.context['request'].user:
            raise serializers.ValidationError('شما اجازه مرجوع کردن این آیتم را ندارید')
        
        # بررسی اینکه تعداد مرجوعی از تعداد خریداری شده بیشتر نباشد
        total_returned = OrderReturn.objects.filter(
            order_item=order_item
        ).exclude(status='rejected').aggregate(
            total=models.Sum('quantity')
        )['total'] or 0
        
        if total_returned + quantity > order_item.quantity:
            raise serializers.ValidationError('تعداد مرجوعی بیشتر از تعداد خریداری شده است')
        
        return data
    
    def create(self, validated_data):
        uploaded_images = validated_data.pop('uploaded_images', [])
        order_return = OrderReturn.objects.create(**validated_data)
        
        for image in uploaded_images:
            OrderReturnImage.objects.create(order_return=order_return, image=image)
        
        return order_return


class InvoiceSerializer(serializers.ModelSerializer):
    class Meta:
        model = Invoice
        fields = ('id', 'invoice_number', 'issue_date', 'due_date', 
                 'is_paid', 'payment_date')
        read_only_fields = fields


class InstallmentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Installment
        fields = ('id', 'amount', 'due_date', 'is_paid', 'payment_date')
        read_only_fields = fields


class InstallmentPlanSerializer(serializers.ModelSerializer):
    installments = InstallmentSerializer(many=True, read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    
    class Meta:
        model = InstallmentPlan
        fields = ('id', 'total_amount', 'down_payment', 'number_of_installments',
                 'installment_amount', 'interest_rate', 'start_date', 'status',
                 'status_display', 'created_at', 'installments')
        read_only_fields = fields


class OrderListSerializer(serializers.ModelSerializer):
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    
    class Meta:
        model = Order
        fields = ('id', 'order_number', 'status', 'status_display', 'final_price', 
                 'created_at', 'payment_method')
        read_only_fields = fields


class OrderDetailSerializer(serializers.ModelSerializer):
    items = OrderItemSerializer(many=True, read_only=True)
    history = OrderHistorySerializer(many=True, read_only=True)
    shipping_address = AddressSerializer(read_only=True)
    shipping_method = ShippingMethodSerializer(read_only=True)
    invoice = InvoiceSerializer(read_only=True)
    installment_plan = InstallmentPlanSerializer(read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    
    class Meta:
        model = Order
        fields = ('id', 'order_number', 'status', 'status_display', 'total_price',
                 'total_discount', 'shipping_cost', 'tax', 'final_price', 'description',
                 'shipping_address', 'shipping_method', 'tracking_code', 'payment_method',
                 'payment_ref_id', 'payment_date', 'created_at', 'updated_at',
                 'items', 'history', 'invoice', 'installment_plan')
        read_only_fields = fields


class CheckoutSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()
    shipping_address_id = serializers.UUIDField()
    shipping_method_id = serializers.UUIDField()
    payment_method = serializers.CharField()
    description = serializers.CharField(required=False, allow_blank=True)
    
    def validate(self, data):
        cart_id = data.get('cart_id')
        shipping_address_id = data.get('shipping_address_id')
        shipping_method_id = data.get('shipping_method_id')
        payment_method = data.get('payment_method')
        
        # بررسی سبد خرید
        try:
            cart = Cart.objects.get(id=cart_id, status=CartStatus.OPEN)
        except Cart.DoesNotExist:
            raise serializers.ValidationError('سبد خرید معتبر نیست')
        
        # بررسی آدرس
        from apps.accounts.models import Address
        try:
            address = Address.objects.get(id=shipping_address_id, user=self.context['request'].user)
        except Address.DoesNotExist:
            raise serializers.ValidationError('آدرس ارسال معتبر نیست')
        
        # بررسی روش ارسال
        from apps.shipping.models import ShippingMethod
        try:
            shipping_method = ShippingMethod.objects.get(id=shipping_method_id, is_active=True)
        except ShippingMethod.DoesNotExist:
            raise serializers.ValidationError('روش ارسال معتبر نیست')
        
        # بررسی روش پرداخت
        valid_payment_methods = ['online', 'wallet', 'cod', 'installment']
        if payment_method not in valid_payment_methods:
            raise serializers.ValidationError('روش پرداخت معتبر نیست')
        
        # بررسی موجودی محصولات
        for item in cart.items.all():
            if item.variant:
                if item.variant.stock < item.quantity:
                    raise serializers.ValidationError(f'موجودی محصول {item.product.name} کافی نیست')
            else:
                if item.product.stock < item.quantity:
                    raise serializers.ValidationError(f'موجودی محصول {item.product.name} کافی نیست')
        
        data['cart'] = cart
        data['address'] = address
        data['shipping_method'] = shipping_method
        return data
    
    @transaction.atomic
    def create(self, validated_data):
        cart = validated_data['cart']
        address = validated_data['address']
        shipping_method = validated_data['shipping_method']
        payment_method = validated_data['payment_method']
        description = validated_data.get('description', '')
        
        user = self.context['request'].user
        
        # محاسبه مبالغ
        total_price = sum(item.unit_price * item.quantity for item in cart.items.all())
        total_discount = sum((item.product.price - item.unit_price) * item.quantity for item in cart.items.all() if item.product.discount_price)
        shipping_cost = shipping_method.cost
        
        # محاسبه مالیات (مثلاً 9%)
# محاسبه مالیات (مثلاً 9%)
        tax = int(total_price * 0.09)
        
        # محاسبه مبلغ نهایی
        final_price = total_price - total_discount + shipping_cost + tax
        
        # ایجاد شماره سفارش یکتا
        order_number = f"ORD-{get_random_string(8, '0123456789').upper()}"
        
        # ایجاد سفارش
        order = Order.objects.create(
            user=user,
            order_number=order_number,
            status=OrderStatus.PENDING,
            total_price=total_price,
            total_discount=total_discount,
            shipping_cost=shipping_cost,
            tax=tax,
            final_price=final_price,
            description=description,
            shipping_address=address,
            shipping_method=shipping_method,
            payment_method=payment_method
        )
        
        # ایجاد آیتم‌های سفارش
        for item in cart.items.all():
            OrderItem.objects.create(
                order=order,
                product=item.product,
                variant=item.variant,
                seller=item.product.seller,
                product_name=item.product.name,
                variant_name=item.variant.name if item.variant else None,
                quantity=item.quantity,
                unit_price=item.product.price,
                discount=item.product.price - item.unit_price if item.product.discount_price else 0,
                final_price=item.unit_price,
                total_price=item.unit_price * item.quantity,
                status=OrderStatus.PENDING
            )
        
        # ایجاد تاریخچه سفارش
        OrderHistory.objects.create(
            order=order,
            status=OrderStatus.PENDING,
            description='سفارش ایجاد شد',
            created_by=user
        )
        
        # ایجاد فاکتور
        invoice_number = f"INV-{get_random_string(8, '0123456789').upper()}"
        Invoice.objects.create(
            order=order,
            invoice_number=invoice_number
        )
        
        # تغییر وضعیت سبد خرید
        cart.status = CartStatus.CONVERTED
        cart.save()
        
        return order


from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'carts', views.CartViewSet, basename='cart')
router.register(r'orders', views.OrderViewSet, basename='order')
router.register(r'returns', views.OrderReturnViewSet, basename='return')
router.register(r'admin/orders', views.AdminOrderViewSet, basename='admin-order')
router.register(r'admin/returns', views.AdminOrderReturnViewSet, basename='admin-return')

urlpatterns = [
    path('', include(router.urls)),
    path('checkout/', views.CheckoutView.as_view(), name='checkout'),
]



from rest_framework import viewsets, permissions, status, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db import transaction
from django.db.models import Sum, F, Q
from django.utils import timezone
from django.shortcuts import get_object_or_404
import uuid

from .models import (
    Cart, CartItem, Order, OrderItem, OrderHistory, OrderReturn,
    OrderReturnImage, Invoice, InstallmentPlan, Installment, CartStatus, OrderStatus
)
from .serializers import (
    CartSerializer, CartItemSerializer, OrderListSerializer, OrderDetailSerializer,
    CheckoutSerializer, OrderReturnSerializer, OrderHistorySerializer
)
from apps.products.models import Product, ProductVariant
from apps.sellers.permissions import IsAdminUser


class CartPermission(permissions.BasePermission):
    """
    اجازه دسترسی به سبد خرید فقط برای صاحب سبد
    """
    def has_object_permission(self, request, view, obj):
        if obj.user:
            return obj.user == request.user
        return obj.session_key == request.session.session_key


class CartViewSet(viewsets.ModelViewSet):
    serializer_class = CartSerializer
    permission_classes = [permissions.IsAuthenticated, CartPermission]
    
    def get_queryset(self):
        return Cart.objects.filter(user=self.request.user, status=CartStatus.OPEN)
    
    def create(self, request, *args, **kwargs):
        # بررسی وجود سبد خرید فعال
        active_cart = Cart.objects.filter(user=request.user, status=CartStatus.OPEN).first()
        if active_cart:
            serializer = self.get_serializer(active_cart)
            return Response(serializer.data)
        
        # ایجاد سبد خرید جدید
        cart = Cart.objects.create(user=request.user)
        serializer = self.get_serializer(cart)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    @action(detail=True, methods=['post'])
    def add_item(self, request, pk=None):
        cart = self.get_object()
        serializer = CartItemSerializer(data=request.data, context={'request': request})
        
        if serializer.is_valid():
            product = serializer.validated_data['product']
            variant = serializer.validated_data.get('variant')
            quantity = serializer.validated_data.get('quantity', 1)
            
            # تعیین قیمت واحد
            unit_price = product.discount_price if product.discount_price else product.price
            if variant:
                unit_price += variant.price_adjustment
            
            # بررسی وجود آیتم مشابه در سبد
            try:
                cart_item = CartItem.objects.get(
                    cart=cart,
                    product=product,
                    variant=variant
                )
                # به‌روزرسانی تعداد
                cart_item.quantity += quantity
                cart_item.save()
            except CartItem.DoesNotExist:
                # ایجاد آیتم جدید
                cart_item = CartItem.objects.create(
                    cart=cart,
                    product=product,
                    variant=variant,
                    quantity=quantity,
                    unit_price=unit_price
                )
            
            # به‌روزرسانی زمان سبد خرید
            cart.save()
            
            return Response(CartItemSerializer(cart_item).data, status=status.HTTP_201_CREATED)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['post'])
    def update_item(self, request, pk=None):
        cart = self.get_object()
        item_id = request.data.get('item_id')
        quantity = request.data.get('quantity')
        
        if not item_id or not quantity or int(quantity) < 1:
            return Response({'error': 'آیتم یا تعداد نامعتبر است'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            cart_item = CartItem.objects.get(cart=cart, id=item_id)
        except CartItem.DoesNotExist:
            return Response({'error': 'آیتم در سبد خرید یافت نشد'}, status=status.HTTP_404_NOT_FOUND)
        
        # بررسی موجودی
        if cart_item.variant:
            if cart_item.variant.stock < int(quantity):
                return Response({'error': 'موجودی کافی نیست'}, status=status.HTTP_400_BAD_REQUEST)
        else:
            if cart_item.product.stock < int(quantity):
                return Response({'error': 'موجودی کافی نیست'}, status=status.HTTP_400_BAD_REQUEST)
        
        # به‌روزرسانی تعداد
        cart_item.quantity = int(quantity)
        cart_item.save()
        
        # به‌روزرسانی زمان سبد خرید
        cart.save()
        
        return Response(CartItemSerializer(cart_item).data)
    
    @action(detail=True, methods=['post'])
    def remove_item(self, request, pk=None):
        cart = self.get_object()
        item_id = request.data.get('item_id')
        
        if not item_id:
            return Response({'error': 'آیتم نامعتبر است'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            cart_item = CartItem.objects.get(cart=cart, id=item_id)
        except CartItem.DoesNotExist:
            return Response({'error': 'آیتم در سبد خرید یافت نشد'}, status=status.HTTP_404_NOT_FOUND)
        
        cart_item.delete()
        
        # به‌روزرسانی زمان سبد خرید
        cart.save()
        
        return Response({'status': 'آیتم با موفقیت حذف شد'})
    
    @action(detail=True, methods=['post'])
    def clear(self, request, pk=None):
        cart = self.get_object()
        cart.items.all().delete()
        
        # به‌روزرسانی زمان سبد خرید
        cart.save()
        
        return Response({'status': 'سبد خرید با موفقیت خالی شد'})
    
    @action(detail=False, methods=['get'])
    def active(self, request):
        cart = Cart.objects.filter(user=request.user, status=CartStatus.OPEN).first()
        if cart:
            serializer = self.get_serializer(cart)
            return Response(serializer.data)
        else:
            # ایجاد سبد خرید جدید
            cart = Cart.objects.create(user=request.user)
            serializer = self.get_serializer(cart)
            return Response(serializer.data)


class CheckoutView(generics.GenericAPIView):
    serializer_class = CheckoutSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        
        # ایجاد پاسخ مناسب بر اساس روش پرداخت
        payment_method = serializer.validated_data['payment_method']
        
        if payment_method == 'online':
            # ارسال به درگاه پرداخت
            payment_url = self._get_payment_url(order)
            return Response({'order_id': order.id, 'payment_url': payment_url})
        elif payment_method == 'wallet':
            # پرداخت با کیف پول
            result = self._process_wallet_payment(order, request.user)
            if result['success']:
                return Response({
                    'order_id': order.id,
                    'status': 'پرداخت با موفقیت انجام شد',
                    'redirect_url': f'/orders/{order.id}'
                })
            else:
                return Response({'error': result['message']}, status=status.HTTP_400_BAD_REQUEST)
        elif payment_method == 'installment':
            # ایجاد طرح اقساطی
            installment_plan = self._create_installment_plan(order)
            return Response({
                'order_id': order.id,
                'installment_plan_id': installment_plan.id,
                'redirect_url': f'/orders/{order.id}/installment-plan'
            })
        else:  # COD - پرداخت در محل
            return Response({
                'order_id': order.id,
                'status': 'سفارش با موفقیت ثبت شد',
                'redirect_url': f'/orders/{order.id}'
            })
    
    def _get_payment_url(self, order):
        # در اینجا کد اتصال به درگاه پرداخت و دریافت URL پرداخت قرار می‌گیرد
        return f'/payments/process/{order.id}'
    
    def _process_wallet_payment(self, order, user):
        # بررسی موجودی کیف پول
        from apps.wallet.models import Wallet
        try:
            wallet = Wallet.objects.get(user=user)
            if wallet.balance >= order.final_price:
                # کسر از موجودی کیف پول
                wallet.balance -= order.final_price
                wallet.save()
                
                # به‌روزرسانی وضعیت سفارش
                order.status = OrderStatus.PAID
                order.payment_date = timezone.now()
                order.payment_ref_id = f"WALLET-{uuid.uuid4().hex[:8]}"
                order.save()
                
                # به‌روزرسانی وضعیت آیتم‌های سفارش
                order.items.update(status=OrderStatus.PROCESSING)
                
                # ثبت در تاریخچه سفارش
                OrderHistory.objects.create(
                    order=order,
                    status=OrderStatus.PAID,
                    description='پرداخت از طریق کیف پول انجام شد',
                    created_by=user
                )
                
                # به‌روزرسانی فاکتور
                invoice = order.invoice
                invoice.is_paid = True
                invoice.payment_date = timezone.now()
                invoice.save()
                
                # به‌روزرسانی موجودی محصولات
                self._update_product_inventory(order)
                
                return {'success': True}
            else:
                return {'success': False, 'message': 'موجودی کیف پول کافی نیست'}
        except Wallet.DoesNotExist:
            return {'success': False, 'message': 'کیف پول شما فعال نیست'}
    
    def _create_installment_plan(self, order):
        # ایجاد طرح اقساطی با پیش‌فرض‌های مناسب
        down_payment = order.final_price * 0.3  # 30% پیش پرداخت
        remaining = order.final_price - down_payment
        num_installments = 3  # تعداد اقساط
        installment_amount = remaining / num_installments
        
        plan = InstallmentPlan.objects.create(
            order=order,
            total_amount=order.final_price,
            down_payment=down_payment,
            number_of_installments=num_installments,
            installment_amount=installment_amount,
            start_date=timezone.now().date(),
            status='active'
        )
        
        # ایجاد اقساط
        for i in range(num_installments):
            due_date = timezone.now().date() + timezone.timedelta(days=30 * (i + 1))
            Installment.objects.create(
                plan=plan,
                amount=installment_amount,
                due_date=due_date
            )
        
        return plan
    
    def _update_product_inventory(self, order):
        # به‌روزرسانی موجودی محصولات
        for item in order.items.all():
            if item.variant:
                variant = item.variant
                variant.stock -= item.quantity
                variant.save()
                
                # ثبت لاگ تغییر موجودی
                from apps.products.models import ProductInventoryLog
                ProductInventoryLog.objects.create(
                    product=item.product,
                    variant=variant,
                    previous_stock=variant.stock + item.quantity,
                    new_stock=variant.stock,
                    change_reason=f'فروش - سفارش {order.order_number}',
                    reference=str(order.id)
                )
            else:
                product = item.product
                product.stock -= item.quantity
                product.save()
                
                # ثبت لاگ تغییر موجودی
                from apps.products.models import ProductInventoryLog
                ProductInventoryLog.objects.create(
                    product=product,
                    previous_stock=product.stock + item.quantity,
                    new_stock=product.stock,
                    change_reason=f'فروش - سفارش {order.order_number}',
                    reference=str(order.id)
                )
            
            # به‌روزرسانی تعداد فروش محصول
            product = item.product
            product.sales_count += item.quantity
            product.save()
            
            # به‌روزرسانی آمار فروشنده
            seller = item.seller
            seller.sales_count += item.quantity
            seller.total_revenue += item.total_price
            
            # محاسبه کمیسیون
            commission = 0
            if seller.commission_type == 'fixed':
                commission = seller.commission_value
            elif seller.commission_type == 'percentage':
                commission = item.total_price * (seller.commission_value / 100)
            elif seller.commission_type == 'tiered':
                # محاسبه کمیسیون پلکانی بر اساس میزان فروش
                from apps.sellers.models import TieredCommission
                tiered_commission = TieredCommission.objects.filter(
                    seller=seller,
                    min_sales__lte=seller.total_revenue
                ).filter(
                    Q(max_sales__gte=seller.total_revenue) | Q(max_sales__isnull=True)
                ).first()
                
                if tiered_commission:
                    commission = item.total_price * (tiered_commission.commission_percentage / 100)
                else:
                    commission = item.total_price * (seller.commission_value / 100)
            
            # ذخیره کمیسیون در آیتم سفارش
            item.commission = commission
            item.save()
            
            # به‌روزرسانی موجودی فروشنده (درآمد منهای کمیسیون)
            seller.balance += (item.total_price - commission)
            seller.save()


class OrderViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = OrderListSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return Order.objects.filter(user=self.request.user).order_by('-created_at')
    
    def get_serializer_class(self):
        if self.action == 'retrieve':
            return OrderDetailSerializer
        return OrderListSerializer
    
    @action(detail=True, methods=['post'])
    def cancel(self, request, pk=None):
        order = self.get_object()
        
        # بررسی امکان لغو سفارش
        if order.status not in [OrderStatus.PENDING, OrderStatus.PAID]:
            return Response(
                {'error': 'این سفارش قابل لغو نیست'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        with transaction.atomic():
            # به‌روزرسانی وضعیت سفارش
            order.status = OrderStatus.CANCELLED
            order.save()
            
            # به‌روزرسانی وضعیت آیتم‌های سفارش
            order.items.update(status=OrderStatus.CANCELLED)
            
            # ثبت در تاریخچه سفارش
            reason = request.data.get('reason', 'لغو توسط مشتری')
            OrderHistory.objects.create(
                order=order,
                status=OrderStatus.CANCELLED,
                description=reason,
                created_by=request.user
            )
            
            # اگر سفارش پرداخت شده بود، برگشت وجه
            if order.payment_method == 'wallet' and order.payment_date:
                from apps.wallet.models import Wallet, WalletTransaction
                wallet = Wallet.objects.get(user=request.user)
                wallet.balance += order.final_price
                wallet.save()
                
                # ثبت تراکنش کیف پول
                WalletTransaction.objects.create(
                    wallet=wallet,
                    amount=order.final_price,
                    transaction_type='refund',
                    description=f'برگشت وجه سفارش {order.order_number}',
                    reference_id=str(order.id)
                )
            
            # برگشت موجودی محصولات
            for item in order.items.all():
                if item.variant:
                    variant = item.variant
                    variant.stock += item.quantity
                    variant.save()
                    
                    # ثبت لاگ تغییر موجودی
                    from apps.products.models import ProductInventoryLog
                    ProductInventoryLog.objects.create(
                        product=item.product,
                        variant=variant,
                        previous_stock=variant.stock - item.quantity,
                        new_stock=variant.stock,
                        change_reason=f'لغو سفارش {order.order_number}',
                        reference=str(order.id)
                    )
                else:
                    product = item.product
                    product.stock += item.quantity
                    product.save()
                    
                    # ثبت لاگ تغییر موجودی
                    from apps.products.models import ProductInventoryLog
                    ProductInventoryLog.objects.create(
                        product=product,
                        previous_stock=product.stock - item.quantity,
                        new_stock=product.stock,
                        change_reason=f'لغو سفارش {order.order_number}',
                        reference=str(order.id)
                    )
                
                # به‌روزرسانی تعداد فروش محصول
                product = item.product
                product.sales_count -= item.quantity
                product.save()
                
                # به‌روزرسانی آمار فروشنده
                seller = item.seller
                seller.sales_count -= item.quantity
                seller.total_revenue -= item.total_price
                
                # برگشت کمیسیون و درآمد
                seller.balance -= (item.total_price - item.commission)
                seller.save()
        
        return Response({'status': 'سفارش با موفقیت لغو شد'})
    
    @action(detail=True, methods=['get'])
    def track(self, request, pk=None):
        order = self.get_object()
        
        tracking_info = {
            'order_number': order.order_number,
            'status': order.status,
            'status_display': order.get_status_display(),
            'tracking_code': order.tracking_code,
            'history': OrderHistorySerializer(order.history.all(), many=True).data
        }
        
        return Response(tracking_info)


class OrderReturnViewSet(viewsets.ModelViewSet):
    serializer_class = OrderReturnSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return OrderReturn.objects.filter(user=self.request.user).order_by('-created_at')
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class AdminOrderViewSet(viewsets.ModelViewSet):
    queryset = Order.objects.all().order_by('-created_at')
    serializer_class = OrderDetailSerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=True, methods=['post'])
    def update_status(self, request, pk=None):
        order = self.get_object()
        new_status = request.data.get('status')
        description = request.data.get('description', '')
        
        if new_status not in dict(OrderStatus.choices).keys():
            return Response({'error': 'وضعیت نامعتبر است'}, status=status.HTTP_400_BAD_REQUEST)
        
        with transaction.atomic():
            # به‌روزرسانی وضعیت سفارش
            order.status = new_status
            order.save()
            
            # به‌روزرسانی وضعیت آیتم‌های سفارش
            order.items.update(status=new_status)
            
            # ثبت در تاریخچه سفارش
            OrderHistory.objects.create(
                order=order,
                status=new_status,
                description=description,
                created_by=request.user
            )
            
            # اگر وضعیت "تحویل داده شده" باشد، افزایش امتیاز وفاداری
            if new_status == OrderStatus.DELIVERED:
                user_profile = order.user.profile
                loyalty_points = int(order.final_price / 10000)  # هر 10 هزار تومان 1 امتیاز
                user_profile.loyalty_points += loyalty_points
                user_profile.save()
        
        return Response({'status': 'وضعیت سفارش با موفقیت به‌روزرسانی شد'})
    
    @action(detail=True, methods=['post'])
    def update_tracking(self, request, pk=None):
        order = self.get_object()
        tracking_code = request.data.get('tracking_code')
        
        if not tracking_code:
            return Response({'error': 'کد پیگیری الزامی است'}, status=status.HTTP_400_BAD_REQUEST)
        
        order.tracking_code = tracking_code
        order.save()
        
        # ثبت در تاریخچه سفارش
        OrderHistory.objects.create(
            order=order,
            status=order.status,
            description=f'کد پیگیری به {tracking_code} تغییر یافت',
            created_by=request.user
        )
        
        return Response({'status': 'کد پیگیری با موفقیت به‌روزرسانی شد'})


class AdminOrderReturnViewSet(viewsets.ModelViewSet):
    queryset = OrderReturn.objects.all().order_by('-created_at')
    serializer_class = OrderReturnSerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=True, methods=['post'])
    def update_status(self, request, pk=None):
        order_return = self.get_object()
        new_status = request.data.get('status')
        admin_note = request.data.get('admin_note', '')
        
        valid_statuses = ['pending', 'approved', 'rejected', 'returned', 'refunded']
        if new_status not in valid_statuses:
            return Response({'error': 'وضعیت نامعتبر است'}, status=status.HTTP_400_BAD_REQUEST)
        
        with transaction.atomic():
            # به‌روزرسانی وضعیت مرجوعی
            order_return.status = new_status
            order_return.admin_note = admin_note
            order_return.save()
            
            # اگر وضعیت "تایید شده" باشد، به‌روزرسانی موجودی محصول
            if new_status == 'approved':
                order_item = order_return.order_item
                
                if order_item.variant:
                    variant = order_item.variant
                    variant.stock += order_return.quantity
                    variant.save()
                    
                    # ثبت لاگ تغییر موجودی
                    from apps.products.models import ProductInventoryLog
                    ProductInventoryLog.objects.create(
                        product=order_item.product,
                        variant=variant,
                        previous_stock=variant.stock - order_return.quantity,
                        new_stock=variant.stock,
                        change_reason=f'مرجوعی سفارش {order_item.order.order_number}',
                        reference=str(order_return.id)
                    )
                else:
                    product = order_item.product
                    product.stock += order_return.quantity
                    product.save()
                    
                    # ثبت لاگ تغییر موجودی
                    from apps.products.models import ProductInventoryLog
                    ProductInventoryLog.objects.create(
                        product=product,
                        previous_stock=product.stock - order_return.quantity,
                        new_stock=product.stock,
                        change_reason=f'مرجوعی سفارش {order_item.order.order_number}',
                        reference=str(order_return.id)
                    )
            
            # اگر وضعیت "مسترد شده" باشد، برگشت وجه به کاربر
            if new_status == 'refunded':
                order_item = order_return.order_item
                refund_amount = order_item.final_price * order_return.quantity
                
                # برگشت وجه به کیف پول کاربر
                from apps.wallet.models import Wallet, WalletTransaction
                wallet, created = Wallet.objects.get_or_create(user=order_return.user)
                wallet.balance += refund_amount
                wallet.save()
                
                # ثبت تراکنش کیف پول
                WalletTransaction.objects.create(
                    wallet=wallet,
                    amount=refund_amount,
                    transaction_type='refund',
                    description=f'برگشت وجه مرجوعی سفارش {order_item.order.order_number}',
                    reference_id=str(order_return.id)
                )
                
                # کسر از موجودی فروشنده
                seller = order_item.seller
                seller.balance -= refund_amount
                seller.save()
        
        return Response({'status': 'وضعیت مرجوعی با موفقیت به‌روزرسانی شد'})


from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
import uuid


class PaymentGateway(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(_('نام درگاه'), max_length=100)
    code = models.CharField(_('کد درگاه'), max_length=50, unique=True)
    description = models.TextField(_('توضیحات'), blank=True)
    is_active = models.BooleanField(_('فعال'), default=True)
    config = models.JSONField(_('تنظیمات'), default=dict, blank=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('درگاه پرداخت')
        verbose_name_plural = _('درگاه‌های پرداخت')
    
    def __str__(self):
        return self.name


class PaymentStatus(models.TextChoices):
    PENDING = 'pending', _('در انتظار پرداخت')
    COMPLETED = 'completed', _('پرداخت موفق')
    FAILED = 'failed', _('پرداخت ناموفق')
    REFUNDED = 'refunded', _('برگشت داده شده')
    CANCELLED = 'cancelled', _('لغو شده')


class Payment(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, 
                           related_name='payments')
    order = models.ForeignKey('orders.Order', on_delete=models.CASCADE, 
                            related_name='payments', null=True, blank=True)
    installment = models.ForeignKey('orders.Installment', on_delete=models.CASCADE, 
                                  related_name='payments', null=True, blank=True)
    wallet_transaction = models.ForeignKey('wallet.WalletTransaction', on_delete=models.CASCADE, 
                                         related_name='payments', null=True, blank=True)
    gateway = models.ForeignKey(PaymentGateway, on_delete=models.PROTECT, related_name='payments')
    amount = models.DecimalField(_('مبلغ'), max_digits=15, decimal_places=0)
    status = models.CharField(_('وضعیت'), max_length=20, choices=PaymentStatus.choices, 
                            default=PaymentStatus.PENDING)
    tracking_code = models.CharField(_('کد پیگیری'), max_length=100, blank=True, null=True)
    reference_id = models.CharField(_('شناسه مرجع'), max_length=100, blank=True, null=True)
    transaction_id = models.CharField(_('شناسه تراکنش'), max_length=100, blank=True, null=True)
    payment_date = models.DateTimeField(_('تاریخ پرداخت'), blank=True, null=True)
    description = models.TextField(_('توضیحات'), blank=True)
    meta_data = models.JSONField(_('اطلاعات اضافی'), default=dict, blank=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('پرداخت')
        verbose_name_plural = _('پرداخت‌ها')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"پرداخت {self.id} - {self.amount} - {self.get_status_display()}"


class PaymentLog(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    payment = models.ForeignKey(Payment, on_delete=models.CASCADE, related_name='logs')
    status = models.CharField(_('وضعیت'), max_length=20, choices=PaymentStatus.choices)
    description = models.TextField(_('توضیحات'), blank=True)
    meta_data = models.JSONField(_('اطلاعات اضافی'), default=dict, blank=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('لاگ پرداخت')
        verbose_name_plural = _('لاگ‌های پرداخت')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"لاگ پرداخت {self.payment.id} - {self.get_status_display()}"


from rest_framework import serializers
from .models import PaymentGateway, Payment, PaymentLog


class PaymentGatewaySerializer(serializers.ModelSerializer):
    class Meta:
        model = PaymentGateway
        fields = ('id', 'name', 'code', 'description', 'is_active')


class PaymentLogSerializer(serializers.ModelSerializer):
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    
    class Meta:
        model = PaymentLog
        fields = ('id', 'status', 'status_display', 'description', 'meta_data', 'created_at')


class PaymentSerializer(serializers.ModelSerializer):
    gateway_name = serializers.CharField(source='gateway.name', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    logs = PaymentLogSerializer(many=True, read_only=True)
    
    class Meta:
        model = Payment
        fields = ('id', 'order', 'installment', 'wallet_transaction', 'gateway', 
                 'gateway_name', 'amount', 'status', 'status_display', 'tracking_code',
                 'reference_id', 'transaction_id', 'payment_date', 'description',
                 'meta_data', 'created_at', 'updated_at', 'logs')
        read_only_fields = fields


class PaymentInitSerializer(serializers.Serializer):
    order_id = serializers.UUIDField(required=False)
    installment_id = serializers.UUIDField(required=False)
    wallet_amount = serializers.DecimalField(required=False, max_digits=15, decimal_places=0)
    gateway_code = serializers.CharField()
    return_url = serializers.URLField()
    
    def validate(self, data):
        order_id = data.get('order_id')
        installment_id = data.get('installment_id')
        wallet_amount = data.get('wallet_amount')
        
        # حداقل یکی از موارد باید وجود داشته باشد
        if not any([order_id, installment_id, wallet_amount]):
            raise serializers.ValidationError('حداقل یکی از موارد سفارش، قسط یا شارژ کیف پول باید مشخص شود')
        
        # بررسی درگاه پرداخت
        gateway_code = data.get('gateway_code')
        try:
            gateway = PaymentGateway.objects.get(code=gateway_code, is_active=True)
            data['gateway'] = gateway
        except PaymentGateway.DoesNotExist:
            raise serializers.ValidationError('درگاه پرداخت نامعتبر است')
        
        # بررسی سفارش
        if order_id:
            from apps.orders.models import Order, OrderStatus
            try:
                order = Order.objects.get(id=order_id, status=OrderStatus.PENDING)
                data['order'] = order
                data['amount'] = order.final_price
            except Order.DoesNotExist:
                raise serializers.ValidationError('سفارش نامعتبر است یا قبلاً پرداخت شده است')
        
        # بررسی قسط
        if installment_id:
            from apps.orders.models import Installment
            try:
                installment = Installment.objects.get(id=installment_id, is_paid=False)
                data['installment'] = installment
                data['amount'] = installment.amount
            except Installment.DoesNotExist:
                raise serializers.ValidationError('قسط نامعتبر است یا قبلاً پرداخت شده است')
        
        # بررسی شارژ کیف پول
        if wallet_amount:
            if wallet_amount < 10000:
                raise serializers.ValidationError('حداقل مبلغ شارژ کیف پول 10,000 تومان است')
            data['amount'] = wallet_amount
        
        return data


class PaymentCallbackSerializer(serializers.Serializer):
    payment_id = serializers.UUIDField()
    status = serializers.CharField()
    tracking_code = serializers.CharField(required=False, allow_blank=True)
    reference_id = serializers.CharField(required=False, allow_blank=True)
    transaction_id = serializers.CharField(required=False, allow_blank=True)



from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'gateways', views.PaymentGatewayViewSet)
router.register(r'payments', views.PaymentViewSet, basename='payment')
router.register(r'admin/payments', views.AdminPaymentViewSet, basename='admin-payment')

urlpatterns = [
    path('', include(router.urls)),
    path('init/', views.PaymentInitView.as_view(), name='payment-init'),
    path('callback/', views.PaymentCallbackView.as_view(), name='payment-callback'),
]


from rest_framework import viewsets, permissions, status, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db import transaction
from django.utils import timezone
from django.shortcuts import redirect, get_object_or_404
from django.urls import reverse
import uuid
import json
import requests
import logging

from .models import PaymentGateway, Payment, PaymentLog, PaymentStatus
from .serializers import (
    PaymentGatewaySerializer, PaymentSerializer, PaymentInitSerializer,
    PaymentCallbackSerializer
)
from apps.sellers.permissions import IsAdminUser

logger = logging.getLogger(__name__)


class PaymentGatewayViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = PaymentGateway.objects.filter(is_active=True)
    serializer_class = PaymentGatewaySerializer
    permission_classes = [permissions.IsAuthenticated]


class PaymentViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return Payment.objects.filter(user=self.request.user).order_by('-created_at')


class PaymentInitView(generics.GenericAPIView):
    serializer_class = PaymentInitSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        order = serializer.validated_data.get('order')
        installment = serializer.validated_data.get('installment')
        wallet_amount = serializer.validated_data.get('wallet_amount')
        gateway = serializer.validated_data['gateway']
        amount = serializer.validated_data['amount']
        return_url = serializer.validated_data['return_url']
        
        # ایجاد رکورد پرداخت
        payment = Payment.objects.create(
            user=request.user,
            order=order,
            installment=installment,
            gateway=gateway,
            amount=amount,
            description='پرداخت آنلاین'
        )
        
        # اگر شارژ کیف پول است، ایجاد تراکنش کیف پول
        if wallet_amount:
            from apps.wallet.models import Wallet, WalletTransaction
            wallet, created = Wallet.objects.get_or_create(user=request.user)
            wallet_transaction = WalletTransaction.objects.create(
                wallet=wallet,
                amount=wallet_amount,
                transaction_type='deposit',
                description='شارژ کیف پول',
                status='pending',
                reference_id=str(payment.id)
            )
            payment.wallet_transaction = wallet_transaction
            payment.save()
        
        # ثبت لاگ پرداخت
        PaymentLog.objects.create(
            payment=payment,
            status=PaymentStatus.PENDING,
            description='درخواست پرداخت ایجاد شد'
        )
        
        # فراخوانی API درگاه پرداخت بر اساس نوع درگاه
        gateway_response = None
        
        try:
            if gateway.code == 'zarinpal':
                gateway_response = self._init_zarinpal_payment(payment, return_url)
            elif gateway.code == 'payir':
                gateway_response = self._init_payir_payment(payment, return_url)
            else:
                return Response(
                    {'error': 'درگاه پرداخت پشتیبانی نمی‌شود'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            if gateway_response.get('success'):
                # به‌روزرسانی اطلاعات پرداخت
                payment.reference_id = gateway_response.get('reference_id')
                payment.meta_data = gateway_response.get('meta_data', {})
                payment.save()
                
                # ثبت لاگ پرداخت
                PaymentLog.objects.create(
                    payment=payment,
                    status=PaymentStatus.PENDING,
                    description='درخواست پرداخت به درگاه ارسال شد',
                    meta_data=gateway_response.get('meta_data', {})
                )
                
                return Response({
                    'payment_id': payment.id,
                    'redirect_url': gateway_response.get('redirect_url')
                })
            else:
                # ثبت لاگ خطا
                PaymentLog.objects.create(
                    payment=payment,
                    status=PaymentStatus.FAILED,
                    description=f"خطا در اتصال به درگاه: {gateway_response.get('error')}",
                    meta_data=gateway_response.get('meta_data', {})
                )
                
                return Response(
                    {'error': gateway_response.get('error', 'خطا در اتصال به درگاه پرداخت')},
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        except Exception as e:
            logger.error(f"Payment gateway error: {str(e)}")
            
            # ثبت لاگ خطا
            PaymentLog.objects.create(
                payment=payment,
                status=PaymentStatus.FAILED,
                description=f"خطا در اتصال به درگاه: {str(e)}"
            )
            
            return Response(
                {'error': 'خطا در اتصال به درگاه پرداخت'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    def _init_zarinpal_payment(self, payment, return_url):
        # تنظیمات درگاه زرین‌پال
        merchant_id = payment.gateway.config.get('merchant_id')
        zarinpal_url = "https://api.zarinpal.com/pg/v4/payment/request.json"
        
        callback_url = f"{return_url}?payment_id={payment.id}"
        
        # آماده‌سازی داده‌های ارسال به درگاه
        data = {
            "merchant_id": merchant_id,
            "amount": int(payment.amount),
            "currency": "IRT",  # تومان
            "description": payment.description,
            "callback_url": callback_url,
            "metadata": {
                "mobile": payment.user.phone_number,
                "email": payment.user.email or ""
            }
        }
        
        # ارسال درخواست به درگاه
        try:
            response = requests.post(zarinpal_url, json=data, timeout=10)
            result = response.json()
            
            if response.status_code == 200 and result.get('data', {}).get('code') == 100:
                authority = result['data']['authority']
                redirect_url = f"https://www.zarinpal.com/pg/StartPay/{authority}"
                
                return {
                    'success': True,
                    'reference_id': authority,
                    'redirect_url': redirect_url,
                    'meta_data': result
                }
            else:
                return {
                    'success': False,
                    'error': f"خطای زرین‌پال: {result.get('errors', {}).get('message', 'خطای نامشخص')}",
                    'meta_data': result
                }
        
        except Exception as e:
            return {
                'success': False,
                'error': f"خطا در ارتباط با زرین‌پال: {str(e)}"
            }
    
    def _init_payir_payment(self, payment, return_url):
        # تنظیمات درگاه pay.ir
        api_key = payment.gateway.config.get('api_key')
        payir_url = "https://pay.ir/pg/send"
        
        callback_url = f"{return_url}?payment_id={payment.id}"
        
        # آماده‌سازی داده‌های ارسال به درگاه
        data = {
            "api": api_key,
            "amount": int(payment.amount),
            "redirect": callback_url,
            "factorNumber": str(payment.id)[:8],
            "mobile": payment.user.phone_number,
            "description": payment.description
        }
        
        # ارسال درخواست به درگاه
        try:
            response = requests.post(payir_url, data=data, timeout=10)
            result = response.json()
            
            if response.status_code == 200 and result.get('status') == 1:
                token = result['token']
                redirect_url = f"https://pay.ir/pg/{token}"
                
                return {
                    'success': True,
                    'reference_id': token,
                    'redirect_url': redirect_url,
                    'meta_data': result
                }
            else:
                return {
                    'success': False,
                    'error': f"خطای pay.ir: {result.get('errorMessage', 'خطای نامشخص')}",
                    'meta_data': result
                }
        
        except Exception as e:
            return {
                'success': False,
                'error': f"خطا در ارتباط با pay.ir: {str(e)}"
            }


class PaymentCallbackView(generics.GenericAPIView):
    serializer_class = PaymentCallbackSerializer
    permission_classes = [permissions.AllowAny]  # درگاه پرداخت به این آدرس دسترسی دارد
    
    def get(self, request, *args, **kwargs):
        payment_id = request.query_params.get('payment_id')
        
        if not payment_id:
            return Response({'error': 'شناسه پرداخت الزامی است'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            payment = Payment.objects.get(id=payment_id)
        except Payment.DoesNotExist:
            return Response({'error': 'پرداخت یافت نشد'}, status=status.HTTP_404_NOT_FOUND)
        
        # بررسی نتیجه پرداخت بر اساس نوع درگاه
        verification_result = None
        
        try:
            if payment.gateway.code == 'zarinpal':
                verification_result = self._verify_zarinpal_payment(payment, request)
            elif payment.gateway.code == 'payir':
                verification_result = self._verify_payir_payment(payment, request)
            else:
                # ثبت لاگ خطا
                PaymentLog.objects.create(
                    payment=payment,
                    status=PaymentStatus.FAILED,
                    description='درگاه پرداخت پشتیبانی نمی‌شود'
                )
                
                return redirect(f"/payment/result?status=error&message=درگاه پرداخت پشتیبانی نمی‌شود")
            
            if verification_result.get('success'):
                # پرداخت موفق
                with transaction.atomic():
                    # به‌روزرسانی اطلاعات پرداخت
                    payment.status = PaymentStatus.COMPLETED
                    payment.payment_date = timezone.now()
                    payment.tracking_code = verification_result.get('tracking_code')
                    payment.transaction_id = verification_result.get('transaction_id')
                    payment.meta_data = verification_result.get('meta_data', {})
                    payment.save()
                    
                    # ثبت لاگ پرداخت
                    PaymentLog.objects.create(
                        payment=payment,
                        status=PaymentStatus.COMPLETED,
                        description='پرداخت با موفقیت انجام شد',
                        meta_data=verification_result.get('meta_data', {})
                    )
                    
                    # به‌روزرسانی وضعیت سفارش یا قسط یا کیف پول
                    if payment.order:
                        self._update_order_status(payment)
                    elif payment.installment:
                        self._update_installment_status(payment)
                    elif payment.wallet_transaction:
                        self._update_wallet_transaction(payment)
                
                return redirect(f"/payment/result?status=success&payment_id={payment.id}")
            else:
                # پرداخت ناموفق
                payment.status = PaymentStatus.FAILED
                payment.meta_data = verification_result.get('meta_data', {})
                payment.save()
                
                # ثبت لاگ پرداخت
                PaymentLog.objects.create(
                    payment=payment,
                    status=PaymentStatus.FAILED,
                    description=f"پرداخت ناموفق: {verification_result.get('error')}",
                    meta_data=verification_result.get('meta_data', {})
                )
                
                return redirect(f"/payment/result?status=error&message={verification_result.get('error')}")
        
        except Exception as e:
            logger.error(f"Payment verification error: {str(e)}")
            
            # ثبت لاگ خطا
            PaymentLog.objects.create(
                payment=payment,
                status=PaymentStatus.FAILED,
                description=f"خطا در تایید پرداخت: {str(e)}"
            )
            
            return redirect(f"/payment/result?status=error&message=خطا در تایید پرداخت")
    
    def _verify_zarinpal_payment(self, payment, request):
        authority = request.query_params.get('Authority')
        status = request.query_params.get('Status')
        
        if not authority or status != 'OK':
            return {
                'success': False,
                'error': 'پرداخت توسط کاربر لغو شد',
                'meta_data': {'authority': authority, 'status': status}
            }
        
        # تنظیمات درگاه زرین‌پال
        merchant_id = payment.gateway.config.get('merchant_id')
        verify_url = "https://api.zarinpal.com/pg/v4/payment/verify.json"
        
        # آماده‌سازی داده‌های تایید پرداخت
        data = {
            "merchant_id": merchant_id,
            "authority": authority,
            "amount": int(payment.amount)
        }
        
        # ارسال درخواست تایید به درگاه
        try:
            response = requests.post(verify_url, json=data, timeout=10)
            result = response.json()
            
            if response.status_code == 200 and result.get('data', {}).get('code') == 100:
                ref_id = result['data']['ref_id']
                
                return {
                    'success': True,
                    'tracking_code': authority,
                    'transaction_id': ref_id,
                    'meta_data': result
                }
            else:
                return {
                    'success': False,
                    'error': f"خطای تایید زرین‌پال: {result.get('errors', {}).get('message', 'خطای نامشخص')}",
                    'meta_data': result
                }
        
        except Exception as e:
            return {
                'success': False,
                'error': f"خطا در ارتباط با زرین‌پال: {str(e)}"
            }
    
    def _verify_payir_payment(self, payment, request):
        token = request.query_params.get('token')
        status = request.query_params.get('status')
        
        if not token or status != '1':
            return {
                'success': False,
                'error': 'پرداخت توسط کاربر لغو شد',
                'meta_data': {'token': token, 'status': status}
            }
        
        # تنظیمات درگاه pay.ir
        api_key = payment.gateway.config.get('api_key')
        verify_url = "https://pay.ir/pg/verify"
        
        # آماده‌سازی داده‌های تایید پرداخت
        data = {
            "api": api_key,
            "token": token
        }
        
        # ارسال درخواست تایید به درگاه
        try:
            response = requests.post(verify_url, data=data, timeout=10)
            result = response.json()
            
            if response.status_code == 200 and result.get('status') == 1:
                transaction_id = result['transId']
                
                return {
                    'success': True,
                    'tracking_code': token,
                    'transaction_id': transaction_id,
                    'meta_data': result
                }
            else:
                return {
                    'success': False,
                    'error': f"خطای تایید pay.ir: {result.get('errorMessage', 'خطای نامشخص')}",
                    'meta_data': result
                }
        
        except Exception as e:
            return {
                'success': False,
                'error': f"خطا در ارتباط با pay.ir: {str(e)}"
            }
    
    def _update_order_status(self, payment):
        from apps.orders.models import Order, OrderStatus, OrderHistory
        
        order = payment.order
        order.status = OrderStatus.PAID
        order.payment_date = payment.payment_date
        order.payment_ref_id = payment.transaction_id
        order.save()
        
        # به‌روزرسانی وضعیت آیتم‌های سفارش
        order.items.update(status=OrderStatus.PROCESSING)
        
        # ثبت در تاریخچه سفارش
        OrderHistory.objects.create(
            order=order,
            status=OrderStatus.PAID,
            description=f'پرداخت با موفقیت انجام شد. کد پیگیری: {payment.transaction_id}',
            created_by=payment.user
        )
        
        # به‌روزرسانی فاکتور
        invoice = order.invoice
        invoice.is_paid = True
        invoice.payment_date = payment.payment_date
        invoice.save()
        
        # به‌روزرسانی موجودی محصولات
        self._update_product_inventory(order)
    
    def _update_installment_status(self, payment):
        installment = payment.installment
        installment.is_paid = True
        installment.payment_date = payment.payment_date
        installment.payment_ref_id = payment.transaction_id
        installment.save()
        
        # بررسی وضعیت طرح اقساطی
        plan = installment.plan
        all_paid = plan.installments.filter(is_paid=False).count() == 0
        
        if all_paid:
            plan.status = 'completed'
            plan.save()
    
    def _update_wallet_transaction(self, payment):
        wallet_transaction = payment.wallet_transaction
        wallet_transaction.status = 'completed'
        wallet_transaction.reference_id = payment.transaction_id
        wallet_transaction.save()
        
        # افزایش موجودی کیف پول
        wallet = wallet_transaction.wallet
        wallet.balance += wallet_transaction.amount
        wallet.save()
    
    def _update_product_inventory(self, order):
        # به‌روزرسانی موجودی محصولات
        for item in order.items.all():
            if item.variant:
                variant = item.variant
                variant.stock -= item.quantity
                variant.save()
                
                # ثبت لاگ تغییر موجودی
                from apps.products.models import ProductInventoryLog
                ProductInventoryLog.objects.create(
                    product=item.product,
                    variant=variant,
                    previous_stock=variant.stock + item.quantity,
                    new_stock=variant.stock,
                    change_reason=f'فروش - سفارش {order.order_number}',
                    reference=str(order.id)
                )
            else:
                product = item.product
                product.stock -= item.quantity
                product.save()
                
                # ثبت لاگ تغییر موجودی
                from apps.products.models import ProductInventoryLog
                ProductInventoryLog.objects.create(
                    product=product,
                    previous_stock=product.stock + item.quantity,
                    new_stock=product.stock,
                    change_reason=f'فروش - سفارش {order.order_number}',
                    reference=str(order.id)
                )
            
            # به‌روزرسانی تعداد فروش محصول
            product = item.product
            product.sales_count += item.quantity
            product.save()
            
            # به‌روزرسانی آمار فروشنده
            seller = item.seller
            seller.sales_count += item.quantity
            seller.total_revenue += item.total_price
            
            # محاسبه کمیسیون
            commission = 0
            if seller.commission_type == 'fixed':
                commission = seller.commission_value
            elif seller.commission_type == 'percentage':
                commission = item.total_price * (seller.commission_value / 100)
            elif seller.commission_type == 'tiered':
                # محاسبه کمیسیون پلکانی بر اساس میزان فروش
                from apps.sellers.models import TieredCommission
                from django.db.models import Q
                
                tiered_commission = TieredCommission.objects.filter(
                    seller=seller,
                    min_sales__lte=seller.total_revenue
                ).filter(
                    Q(max_sales__gte=seller.total_revenue) | Q(max_sales__isnull=True)
                ).first()
                
                if tiered_commission:
                    commission = item.total_price * (tiered_commission.commission_percentage / 100)
                else:
                    commission = item.total_price * (seller.commission_value / 100)
            
            # ذخیره کمیسیون در آیتم سفارش
            item.commission = commission
            item.save()
            
            # به‌روزرسانی موجودی فروشنده (درآمد منهای کمیسیون)
            seller.balance += (item.total_price - commission)
            seller.save()


class AdminPaymentViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Payment.objects.all().order_by('-created_at')
    serializer_class = PaymentSerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=True, methods=['post'])
    def refund(self, request, pk=None):
        payment = self.get_object()
        
        if payment.status != PaymentStatus.COMPLETED:
            return Response({'error': 'فقط پرداخت‌های موفق قابل استرداد هستند'}, status=status.HTTP_400_BAD_REQUEST)
        
        reason = request.data.get('reason', 'استرداد توسط مدیر')
        
        with transaction.atomic():
            # به‌روزرسانی وضعیت پرداخت
            payment.status = PaymentStatus.REFUNDED
            payment.save()
            
            # ثبت لاگ پرداخت
            PaymentLog.objects.create(
                payment=payment,
                status=PaymentStatus.REFUNDED,
                description=f'استرداد وجه: {reason}'
            )
            
            # اگر پرداخت مربوط به سفارش است
            if payment.order:
                from apps.orders.models import OrderStatus, OrderHistory
                
                order = payment.order
                order.status = OrderStatus.REFUNDED
                order.save()
                
                # به‌روزرسانی وضعیت آیتم‌های سفارش
                order.items.update(status=OrderStatus.REFUNDED)
                
                # ثبت در تاریخچه سفارش
                OrderHistory.objects.create(
                    order=order,
                    status=OrderStatus.REFUNDED,
                    description=f'استرداد وجه: {reason}',
                    created_by=request.user
                )
                
                # برگشت وجه به کیف پول کاربر
                from apps.wallet.models import Wallet, WalletTransaction
                wallet, created = Wallet.objects.get_or_create(user=payment.user)
                wallet.balance += payment.amount
                wallet.save()
                
                # ثبت تراکنش کیف پول
                wallet_transaction = WalletTransaction.objects.create(
                    wallet=wallet,
                    amount=payment.amount,
                    transaction_type='refund',
                    description=f'استرداد وجه سفارش {order.order_number}: {reason}',
                    status='completed',
                    reference_id=str(payment.id)
                )
                
                # به‌روزرسانی فاکتور
                invoice = order.invoice
                invoice.is_paid = False
                invoice.save()
            
            # اگر پرداخت مربوط به شارژ کیف پول است
            elif payment.wallet_transaction:
                wallet_transaction = payment.wallet_transaction
                wallet = wallet_transaction.wallet
                
                # کاهش موجودی کیف پول
                wallet.balance -= payment.amount
                wallet.save()
                
                # به‌روزرسانی تراکنش کیف پول
                wallet_transaction.status = 'refunded'
                wallet_transaction.description += f' (استرداد: {reason})'
                wallet_transaction.save()
        
        return Response({'status': 'وجه با موفقیت استرداد شد'})





from django.db import models
from django.utils.translation import gettext_lazy as _
from django.utils.text import slugify
from django.conf import settings
import uuid


class Product(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    seller = models.ForeignKey('sellers.Seller', on_delete=models.CASCADE, related_name='products')
    category = models.ForeignKey('categories.Category', on_delete=models.CASCADE, related_name='products')
    name = models.CharField(_('نام محصول'), max_length=200)
    slug = models.SlugField(_('اسلاگ'), max_length=200, unique=True)
    description = models.TextField(_('توضیحات'))
    short_description = models.CharField(_('توضیحات کوتاه'), max_length=300, blank=True)
    price = models.DecimalField(_('قیمت'), max_digits=15, decimal_places=0)
    discount_price = models.DecimalField(_('قیمت با تخفیف'), max_digits=15, decimal_places=0, blank=True, null=True)
    stock = models.PositiveIntegerField(_('موجودی'), default=0)
    is_active = models.BooleanField(_('فعال'), default=True)
    is_featured = models.BooleanField(_('ویژه'), default=False)
    is_approved = models.BooleanField(_('تایید شده'), default=False)
    rating = models.DecimalField(_('امتیاز'), max_digits=3, decimal_places=2, default=0)
    review_count = models.PositiveIntegerField(_('تعداد نظرات'), default=0)
    sales_count = models.PositiveIntegerField(_('تعداد فروش'), default=0)
    view_count = models.PositiveIntegerField(_('تعداد بازدید'), default=0)
    sku = models.CharField(_('کد محصول'), max_length=50, blank=True, null=True)
    weight = models.DecimalField(_('وزن (گرم)'), max_digits=10, decimal_places=2, blank=True, null=True)
    width = models.DecimalField(_('عرض (سانتی‌متر)'), max_digits=10, decimal_places=2, blank=True, null=True)
    height = models.DecimalField(_('ارتفاع (سانتی‌متر)'), max_digits=10, decimal_places=2, blank=True, null=True)
    length = models.DecimalField(_('طول (سانتی‌متر)'), max_digits=10, decimal_places=2, blank=True, null=True)
    meta_title = models.CharField(_('عنوان متا'), max_length=100, blank=True, null=True)
    meta_description = models.TextField(_('توضیحات متا'), blank=True, null=True)
    meta_keywords = models.CharField(_('کلمات کلیدی متا'), max_length=200, blank=True, null=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('محصول')
        verbose_name_plural = _('محصولات')
        ordering = ['-created_at']
    
    def __str__(self):
        return self.name
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
            # اضافه کردن شناسه یکتا برای جلوگیری از تکرار اسلاگ
            if Product.objects.filter(slug=self.slug).exists():
                self.slug = f"{self.slug}-{str(uuid.uuid4())[:8]}"
        super().save(*args, **kwargs)
    
    @property
    def discount_percentage(self):
        if self.discount_price and self.price > 0:
            return int(100 - (self.discount_price * 100 / self.price))
        return 0
    
    @property
    def final_price(self):
        return self.discount_price if self.discount_price else self.price
    
    @property
    def is_in_stock(self):
        return self.stock > 0


class ProductImage(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(_('تصویر'), upload_to='products/')
    alt_text = models.CharField(_('متن جایگزین'), max_length=100, blank=True)
    is_primary = models.BooleanField(_('تصویر اصلی'), default=False)
    order = models.PositiveIntegerField(_('ترتیب'), default=0)
    
    class Meta:
        verbose_name = _('تصویر محصول')
        verbose_name_plural = _('تصاویر محصول')
        ordering = ['order']
    
    def __str__(self):
        return f"تصویر {self.order} محصول {self.product.name}"


class ProductAttribute(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='attributes')
    attribute = models.ForeignKey('categories.CategoryAttribute', on_delete=models.CASCADE, related_name='product_attributes')
    value = models.CharField(_('مقدار'), max_length=255)
    
    class Meta:
        verbose_name = _('ویژگی محصول')
        verbose_name_plural = _('ویژگی‌های محصول')
        unique_together = ('product', 'attribute')
    
    def __str__(self):
        return f"{self.attribute.name}: {self.value}"


class ProductVariant(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='variants')
    name = models.CharField(_('نام تنوع'), max_length=100)
    sku = models.CharField(_('کد محصول'), max_length=50, blank=True, null=True)
    price_adjustment = models.DecimalField(_('تغییر قیمت'), max_digits=15, decimal_places=0, default=0)
    stock = models.PositiveIntegerField(_('موجودی'), default=0)
    image = models.ImageField(_('تصویر'), upload_to='product_variants/', blank=True, null=True)
    is_default = models.BooleanField(_('پیش‌فرض'), default=False)
    
    class Meta:
        verbose_name = _('تنوع محصول')
        verbose_name_plural = _('تنوع‌های محصول')
    
    def __str__(self):
        return f"{self.product.name} - {self.name}"
    
    @property
    def final_price(self):
        base_price = self.product.discount_price if self.product.discount_price else self.product.price
        return base_price + self.price_adjustment


class ProductVariantAttribute(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    variant = models.ForeignKey(ProductVariant, on_delete=models.CASCADE, related_name='attributes')
    attribute = models.ForeignKey('categories.CategoryAttribute', on_delete=models.CASCADE)
    value = models.CharField(_('مقدار'), max_length=100)
    
    class Meta:
        verbose_name = _('ویژگی تنوع محصول')
        verbose_name_plural = _('ویژگی‌های تنوع محصول')
        unique_together = ('variant', 'attribute')
    
    def __str__(self):
        return f"{self.variant.name} - {self.attribute.name}: {self.value}"


class ProductTag(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(_('نام'), max_length=100, unique=True)
    slug = models.SlugField(_('اسلاگ'), max_length=100, unique=True)
    
    class Meta:
        verbose_name = _('برچسب محصول')
        verbose_name_plural = _('برچسب‌های محصول')
    
    def __str__(self):
        return self.name
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)


class ProductTagRelation(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='tags')
    tag = models.ForeignKey(ProductTag, on_delete=models.CASCADE, related_name='products')
    
    class Meta:
        verbose_name = _('رابطه محصول و برچسب')
        verbose_name_plural = _('روابط محصول و برچسب')
        unique_together = ('product', 'tag')
    
    def __str__(self):
        return f"{self.product.name} - {self.tag.name}"


class ProductReview(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='reviews')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='product_reviews')
    rating = models.PositiveSmallIntegerField(_('امتیاز'), choices=[(i, i) for i in range(1, 6)])
    title = models.CharField(_('عنوان'), max_length=100, blank=True)
    comment = models.TextField(_('نظر'))
    is_approved = models.BooleanField(_('تایید شده'), default=False)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('نظر محصول')
        verbose_name_plural = _('نظرات محصول')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.product.name} - {self.rating}"


class ProductReviewImage(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    review = models.ForeignKey(ProductReview, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(_('تصویر'), upload_to='review_images/')
    
    class Meta:
        verbose_name = _('تصویر نظر')
        verbose_name_plural = _('تصاویر نظر')
    
    def __str__(self):
        return f"تصویر نظر {self.review.id}"


class ProductReviewComment(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    review = models.ForeignKey(ProductReview, on_delete=models.CASCADE, related_name='comments')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='review_comments')
    comment = models.TextField(_('نظر'))
    is_seller = models.BooleanField(_('پاسخ فروشنده'), default=False)
    is_approved = models.BooleanField(_('تایید شده'), default=False)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('پاسخ به نظر')
        verbose_name_plural = _('پاسخ‌های به نظرات')
        ordering = ['created_at']
    
    def __str__(self):
        return f"پاسخ {self.user.get_full_name()} به نظر {self.review.id}"


class ProductReviewReport(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    review = models.ForeignKey(ProductReview, on_delete=models.CASCADE, related_name='reports')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='review_reports')
    reason = models.TextField(_('دلیل گزارش'))
    is_resolved = models.BooleanField(_('حل شده'), default=False)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('گزارش نظر نامناسب')
        verbose_name_plural = _('گزارش‌های نظرات نامناسب')
        unique_together = ('review', 'user')
    
    def __str__(self):
        return f"گزارش {self.user.get_full_name()} برای نظر {self.review.id}"


class ProductQuestion(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='questions')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='product_questions')
    question = models.TextField(_('پرسش'))
    is_approved = models.BooleanField(_('تایید شده'), default=False)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('پرسش محصول')
        verbose_name_plural = _('پرسش‌های محصول')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"پرسش {self.user.get_full_name()} درباره {self.product.name}"


class ProductAnswer(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    question = models.ForeignKey(ProductQuestion, on_delete=models.CASCADE, related_name='answers')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='product_answers')
    answer = models.TextField(_('پاسخ'))
    is_seller = models.BooleanField(_('پاسخ فروشنده'), default=False)
    is_approved = models.BooleanField(_('تایید شده'), default=False)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('پاسخ به پرسش محصول')
        verbose_name_plural = _('پاسخ‌های به پرسش‌های محصول')
        ordering = ['created_at']
    
    def __str__(self):
        return f"پاسخ {self.user.get_full_name()} به پرسش {self.question.id}"


class RelatedProduct(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='related_products')
    related_product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='related_to_products')
    
    class Meta:
        verbose_name = _('محصول مرتبط')
        verbose_name_plural = _('محصولات مرتبط')
        unique_together = ('product', 'related_product')
    
    def __str__(self):
        return f"{self.product.name} -> {self.related_product.name}"


class ProductInventoryLog(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='inventory_logs')
    variant = models.ForeignKey(ProductVariant, on_delete=models.CASCADE, 
                              related_name='inventory_logs', blank=True, null=True)
    previous_stock = models.PositiveIntegerField(_('موجودی قبلی'))
    new_stock = models.PositiveIntegerField(_('موجودی جدید'))
    change_reason = models.CharField(_('دلیل تغییر'), max_length=100)
    reference = models.CharField(_('مرجع'), max_length=100, blank=True, null=True)
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, 
                                 related_name='inventory_logs', blank=True, null=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('لاگ موجودی محصول')
        verbose_name_plural = _('لاگ‌های موجودی محصول')
        ordering = ['-created_at']
    
    def __str__(self):
        product_name = self.product.name
        if self.variant:
            product_name += f" - {self.variant.name}"
        return f"{product_name} - {self.previous_stock} به {self.new_stock}"


from rest_framework import serializers
from django.db.models import Avg
from django.utils.text import slugify
import uuid

from .models import (
    Product, ProductImage, ProductAttribute, ProductVariant, ProductVariantAttribute,
    ProductTag, ProductTagRelation, ProductReview, ProductReviewImage, ProductReviewComment,
    ProductQuestion, ProductAnswer, RelatedProduct, ProductInventoryLog
)
from apps.categories.serializers import CategoryListSerializer, CategoryAttributeSerializer
from apps.sellers.serializers import SellerListSerializer


class ProductImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProductImage
        fields = ('id', 'image', 'alt_text', 'is_primary', 'order')


class ProductAttributeSerializer(serializers.ModelSerializer):
    attribute_name = serializers.SerializerMethodField()
    
    class Meta:
        model = ProductAttribute
        fields = ('id', 'attribute', 'attribute_name', 'value')
    
    def get_attribute_name(self, obj):
        return obj.attribute.name


class ProductVariantAttributeSerializer(serializers.ModelSerializer):
    attribute_name = serializers.SerializerMethodField()
    
    class Meta:
        model = ProductVariantAttribute
        fields = ('id', 'attribute', 'attribute_name', 'value')
    
    def get_attribute_name(self, obj):
        return obj.attribute.name


class ProductVariantSerializer(serializers.ModelSerializer):
    attributes = ProductVariantAttributeSerializer(many=True, read_only=True)
    final_price = serializers.DecimalField(max_digits=15, decimal_places=0, read_only=True)
    
    class Meta:
        model = ProductVariant
        fields = ('id', 'name', 'sku', 'price_adjustment', 'stock', 'image', 
                 'is_default', 'attributes', 'final_price')


class ProductTagSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProductTag
        fields = ('id', 'name', 'slug')


class ProductReviewImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProductReviewImage
        fields = ('id', 'image')


class ProductReviewCommentSerializer(serializers.ModelSerializer):
    user_full_name = serializers.SerializerMethodField()
    
    class Meta:
        model = ProductReviewComment
        fields = ('id', 'comment', 'user_full_name', 'is_seller', 'created_at')
        read_only_fields = ('is_seller', 'created_at')
    
    def get_user_full_name(self, obj):
        return obj.user.get_full_name()


class ProductReviewSerializer(serializers.ModelSerializer):
    user_full_name = serializers.SerializerMethodField()
    images = ProductReviewImageSerializer(many=True, read_only=True)
    comments = ProductReviewCommentSerializer(many=True, read_only=True)
    uploaded_images = serializers.ListField(
        child=serializers.ImageField(max_length=1000000, allow_empty_file=False, use_url=False),
        write_only=True, required=False
    )
    
    class Meta:
        model = ProductReview
        fields = ('id', 'rating', 'title', 'comment', 'user_full_name', 
                 'created_at', 'images', 'comments', 'uploaded_images')
        read_only_fields = ('user_full_name', 'created_at')
    
    def get_user_full_name(self, obj):
        return obj.user.get_full_name()
    
    def create(self, validated_data):
        uploaded_images = validated_data.pop('uploaded_images', [])
        review = ProductReview.objects.create(**validated_data)
        
        for image in uploaded_images:
            ProductReviewImage.objects.create(review=review, image=image)
        
        return review


class ProductAnswerSerializer(serializers.ModelSerializer):
    user_full_name = serializers.SerializerMethodField()
    
    class Meta:
        model = ProductAnswer
        fields = ('id', 'answer', 'user_full_name', 'is_seller', 'created_at')
        read_only_fields = ('is_seller', 'created_at')
    
    def get_user_full_name(self, obj):
        return obj.user.get_full_name()


class ProductQuestionSerializer(serializers.ModelSerializer):
    user_full_name = serializers.SerializerMethodField()
    answers = ProductAnswerSerializer(many=True, read_only=True)
    
    class Meta:
        model = ProductQuestion
        fields = ('id', 'question', 'user_full_name', 'created_at', 'answers')
        read_only_fields = ('user_full_name', 'created_at')
    
    def get_user_full_name(self, obj):
        return obj.user.get_full_name()


class ProductListSerializer(serializers.ModelSerializer):
    primary_image = serializers.SerializerMethodField()
    discount_percentage = serializers.IntegerField(read_only=True)
    final_price = serializers.DecimalField(max_digits=15, decimal_places=0, read_only=True)
    seller_name = serializers.SerializerMethodField()
    category_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Product
        fields = ('id', 'name', 'slug', 'short_description', 'price', 'discount_price',
                 'discount_percentage', 'final_price', 'rating', 'review_count',
                 'primary_image', 'seller_name', 'category_name', 'is_in_stock')
    
    def get_primary_image(self, obj):
        primary_image = obj.images.filter(is_primary=True).first()
        if primary_image:
            return primary_image.image.url
        # اگر تصویر اصلی وجود نداشت، اولین تصویر را برمی‌گرداند
        first_image = obj.images.first()
        if first_image:
            return first_image.image.url
        return None
    
    def get_seller_name(self, obj):
        return obj.seller.shop_name
    
    def get_category_name(self, obj):
        return obj.category.name


class RelatedProductSerializer(serializers.ModelSerializer):
    related_product = ProductListSerializer(read_only=True)
    
    class Meta:
        model = RelatedProduct
        fields = ('id', 'related_product')


class ProductDetailSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)
    attributes = ProductAttributeSerializer(many=True, read_only=True)
    variants = ProductVariantSerializer(many=True, read_only=True)
    tags = serializers.SerializerMethodField()
    related_products = RelatedProductSerializer(many=True, read_only=True)
    reviews = ProductReviewSerializer(many=True, read_only=True)
    questions = ProductQuestionSerializer(many=True, read_only=True)
    seller = SellerListSerializer(read_only=True)
    category = CategoryListSerializer(read_only=True)
    discount_percentage = serializers.IntegerField(read_only=True)
    final_price = serializers.DecimalField(max_digits=15, decimal_places=0, read_only=True)
    
    class Meta:
        model = Product
        fields = ('id', 'name', 'slug', 'description', 'short_description', 'price',
                 'discount_price', 'discount_percentage', 'final_price', 'stock',
                 'is_active', 'is_featured', 'rating', 'review_count', 'sales_count',
                 'view_count', 'sku', 'weight', 'width', 'height', 'length',
                 'meta_title', 'meta_description', 'meta_keywords', 'created_at',
                 'updated_at', 'seller', 'category', 'images', 'attributes',
                 'variants', 'tags', 'related_products', 'reviews', 'questions',
                 'is_in_stock')
    
    def get_tags(self, obj):
        tags = ProductTag.objects.filter(products__product=obj)
        return ProductTagSerializer(tags, many=True).data


class ProductCreateUpdateSerializer(serializers.ModelSerializer):
    uploaded_images = serializers.ListField(
        child=serializers.ImageField(max_length=1000000, allow_empty_file=False, use_url=False),
        write_only=True, required=False
    )
    primary_image = serializers.ImageField(write_only=True, required=False)
    attributes = serializers.ListField(
        child=serializers.JSONField(),
        write_only=True, required=False
    )
    variants = serializers.ListField(
        child=serializers.JSONField(),
        write_only=True, required=False
    )
    tags = serializers.ListField(
        child=serializers.CharField(max_length=100),
        write_only=True, required=False
    )
    
    class Meta:
        model = Product
        fields = ('name', 'category', 'description', 'short_description', 'price',
                 'discount_price', 'stock', 'sku', 'weight', 'width', 'height', 'length',
                 'meta_title', 'meta_description', 'meta_keywords', 'uploaded_images',
                 'primary_image', 'attributes', 'variants', 'tags')
    
    def create(self, validated_data):
        uploaded_images = validated_data.pop('uploaded_images', [])
        primary_image = validated_data.pop('primary_image', None)
        attributes_data = validated_data.pop('attributes', [])
        variants_data = validated_data.pop('variants', [])
        tags_data = validated_data.pop('tags', [])
        
        # ایجاد محصول
        product = Product.objects.create(**validated_data)
        
        # ذخیره تصاویر
        if primary_image:
            ProductImage.objects.create(product=product, image=primary_image, is_primary=True, order=0)
        
        for i, image in enumerate(uploaded_images, start=1):
            ProductImage.objects.create(product=product, image=image, order=i)
        
        # ذخیره ویژگی‌ها
        for attr_data in attributes_data:
            ProductAttribute.objects.create(
                product=product,
                attribute_id=attr_data['attribute_id'],
                value=attr_data['value']
            )
        
        # ذخیره تنوع‌ها
        for variant_data in variants_data:
            variant = ProductVariant.objects.create(
                product=product,
                name=variant_data['name'],
                sku=variant_data.get('sku'),
                price_adjustment=variant_data.get('price_adjustment', 0),
                stock=variant_data.get('stock', 0),
                image=variant_data.get('image'),
                is_default=variant_data.get('is_default', False)
            )
            
            # ذخیره ویژگی‌های تنوع
            for attr in variant_data.get('attributes', []):
                ProductVariantAttribute.objects.create(
                    variant=variant,
                    attribute_id=attr['attribute_id'],
                    value=attr['value']
                )
        
        # ذخیره برچسب‌ها
        for tag_name in tags_data:
            tag, created = ProductTag.objects.get_or_create(
                name=tag_name,
                defaults={'slug': slugify(tag_name)}
            )
            ProductTagRelation.objects.create(product=product, tag=tag)
        
        return product
    
    def update(self, instance, validated_data):
        uploaded_images = validated_data.pop('uploaded_images', [])
        primary_image = validated_data.pop('primary_image', None)
        attributes_data = validated_data.pop('attributes', [])
        variants_data = validated_data.pop('variants', [])
        tags_data = validated_data.pop('tags', [])
        
        # به‌روزرسانی فیلدهای محصول
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        
        # به‌روزرسانی تصاویر
        if primary_image:
            # حذف تصویر اصلی قبلی
            ProductImage.objects.filter(product=instance, is_primary=True).delete()
            ProductImage.objects.create(product=instance, image=primary_image, is_primary=True, order=0)
        
        for i, image in enumerate(uploaded_images, start=1):
            ProductImage.objects.create(product=instance, image=image, order=i)
        
        # به‌روزرسانی ویژگی‌ها
        if attributes_data:
            # حذف ویژگی‌های قبلی
            ProductAttribute.objects.filter(product=instance).delete()
            
            # ایجاد ویژگی‌های جدید
            for attr_data in attributes_data:
                ProductAttribute.objects.create(
                    product=instance,
                    attribute_id=attr_data['attribute_id'],
                    value=attr_data['value']
                )
        
        # به‌روزرسانی تنوع‌ها
        if variants_data:
            # حذف تنوع‌های قبلی
            ProductVariant.objects.filter(product=instance).delete()
            
            # ایجاد تنوع‌های جدید
            for variant_data in variants_data:
                variant = ProductVariant.objects.create(
                    product=instance,
                    name=variant_data['name'],
                    sku=variant_data.get('sku'),
                    price_adjustment=variant_data.get('price_adjustment', 0),
                    stock=variant_data.get('stock', 0),
                    image=variant_data.get('image'),
                    is_default=variant_data.get('is_default', False)
                )
                
                # ذخیره ویژگی‌های تنوع
                for attr in variant_data.get('attributes', []):
                    ProductVariantAttribute.objects.create(
                        variant=variant,
                        attribute_id=attr['attribute_id'],
                        value=attr['value']
                    )
        
        # به‌روزرسانی برچسب‌ها
        if tags_data:
            # حذف روابط برچسب قبلی
            ProductTagRelation.objects.filter(product=instance).delete()
            
            # ایجاد روابط برچسب جدید
            for tag_name in tags_data:
                tag, created = ProductTag.objects.get_or_create(
                    name=tag_name,
                    defaults={'slug': slugify(tag_name)}
                )
                ProductTagRelation.objects.create(product=instance, tag=tag)
        
        return instance


class ProductInventoryLogSerializer(serializers.ModelSerializer):
    product_name = serializers.SerializerMethodField()
    variant_name = serializers.SerializerMethodField()
    created_by_name = serializers.SerializerMethodField()
    
    class Meta:
        model = ProductInventoryLog
        fields = ('id', 'product', 'product_name', 'variant', 'variant_name',
                 'previous_stock', 'new_stock', 'change_reason', 'reference',
                 'created_by', 'created_by_name', 'created_at')
        read_only_fields = ('id', 'created_at')
    
    def get_product_name(self, obj):
        return obj.product.name
    
    def get_variant_name(self, obj):
        if obj.variant:
            return obj.variant.name
        return None
    
    def get_created_by_name(self, obj):
        if obj.created_by:
            return obj.created_by.get_full_name()
        return None


    from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'products', views.ProductViewSet)
router.register(r'tags', views.ProductTagViewSet)
router.register(r'inventory-logs', views.ProductInventoryLogViewSet, basename='inventory-logs')

urlpatterns = [
    path('', include(router.urls)),
]


from rest_framework import viewsets, permissions, status, filters
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db.models import Q, F, Avg, Count, Sum
from django.db.transaction import atomic
from django_filters.rest_framework import DjangoFilterBackend
from django.utils import timezone
import uuid

from .models import (
    Product, ProductImage, ProductAttribute, ProductVariant, ProductVariantAttribute,
    ProductTag, ProductTagRelation, ProductReview, ProductReviewImage, ProductReviewComment,
    ProductQuestion, ProductAnswer, RelatedProduct, ProductInventoryLog
)
from .serializers import (
    ProductListSerializer, ProductDetailSerializer, ProductCreateUpdateSerializer,
    ProductReviewSerializer, ProductReviewCommentSerializer, ProductQuestionSerializer,
    ProductAnswerSerializer, ProductInventoryLogSerializer, ProductTagSerializer
)
from apps.sellers.permissions import IsSellerOwner, IsAdminUser


class IsProductSellerOrReadOnly(permissions.BasePermission):
    """
    فقط فروشنده محصول می‌تواند آن را ویرایش کند
    """
    def has_object_permission(self, request, view, obj):
        if request.method in permissions.SAFE_METHODS:
            return True
        
        # بررسی اینکه کاربر فروشنده محصول باشد
        if hasattr(request.user, 'seller'):
            return obj.seller == request.user.seller
        return False


class IsProductSellerOrAdmin(permissions.BasePermission):
    """
    فقط فروشنده محصول یا مدیر سیستم می‌تواند به این دسترسی داشته باشد
    """
    def has_object_permission(self, request, view, obj):
        if request.user.is_staff:
            return True
        
        if hasattr(request.user, 'seller'):
            return obj.seller == request.user.seller
        return False


class ProductViewSet(viewsets.ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductListSerializer
    lookup_field = 'slug'
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['category', 'seller', 'is_featured', 'is_active']
    search_fields = ['name', 'description', 'short_description', 'sku', 'meta_keywords']
    ordering_fields = ['created_at', 'price', 'rating', 'sales_count', 'view_count']
    
    def get_permissions(self):
        if self.action in ['create']:
            return [permissions.IsAuthenticated(), IsSellerOwner()]
        elif self.action in ['update', 'partial_update', 'destroy']:
            return [permissions.IsAuthenticated(), IsProductSellerOrReadOnly()]
        elif self.action in ['admin_approve', 'admin_feature']:
            return [permissions.IsAuthenticated(), IsAdminUser()]
        return [permissions.AllowAny()]
    
    def get_serializer_class(self):
        if self.action == 'retrieve':
            return ProductDetailSerializer
        elif self.action in ['create', 'update', 'partial_update']:
            return ProductCreateUpdateSerializer
        return ProductListSerializer
    
    def get_queryset(self):
        queryset = Product.objects.all()
        
        if self.action in ['list', 'retrieve']:
            # فقط محصولات فعال و تایید شده را به کاربران عادی نمایش می‌دهیم
            if not self.request.user.is_staff and not hasattr(self.request.user, 'seller'):
                queryset = queryset.filter(is_active=True, is_approved=True)
        
        # فیلتر بر اساس قیمت
        min_price = self.request.query_params.get('min_price')
        max_price = self.request.query_params.get('max_price')
        
        if min_price:
            queryset = queryset.filter(Q(discount_price__gte=min_price) | 
                                      (Q(discount_price__isnull=True) & Q(price__gte=min_price)))
        
        if max_price:
            queryset = queryset.filter(Q(discount_price__lte=max_price) | 
                                      (Q(discount_price__isnull=True) & Q(price__lte=max_price)))
        
        # فیلتر بر اساس برچسب
        tag = self.request.query_params.get('tag')
        if tag:
            queryset = queryset.filter(tags__tag__slug=tag)
        
        # فیلتر بر اساس موجودی
        in_stock = self.request.query_params.get('in_stock')
        if in_stock == 'true':
            queryset = queryset.filter(stock__gt=0)
        
        return queryset
    
    def perform_create(self, serializer):
        serializer.save(seller=self.request.user.seller, is_approved=False)
    
    @action(detail=True, methods=['post'])
    def increment_view(self, request, slug=None):
        product = self.get_object()
        product.view_count = F('view_count') + 1
        product.save(update_fields=['view_count'])
        return Response({'status': 'view count incremented'})
    
    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def add_review(self, request, slug=None):
        product = self.get_object()
        user = request.user
        
        # بررسی اینکه کاربر قبلاً نظر نداده باشد
        if ProductReview.objects.filter(product=product, user=user).exists():
            return Response(
                {'error': 'شما قبلاً برای این محصول نظر ثبت کرده‌اید'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        serializer = ProductReviewSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save(product=product, user=user)
            
            # به‌روزرسانی امتیاز و تعداد نظرات محصول
            avg_rating = ProductReview.objects.filter(product=product).aggregate(Avg('rating'))['rating__avg'] or 0
            review_count = ProductReview.objects.filter(product=product).count()
            
            product.rating = avg_rating
            product.review_count = review_count
            product.save(update_fields=['rating', 'review_count'])
            
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def add_review_comment(self, request, slug=None):
        product = self.get_object()
        review_id = request.data.get('review_id')
        
        try:
            review = ProductReview.objects.get(id=review_id, product=product)
        except ProductReview.DoesNotExist:
            return Response(
                {'error': 'نظر مورد نظر یافت نشد'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        serializer = ProductReviewCommentSerializer(data=request.data)
        if serializer.is_valid():
            # بررسی اینکه آیا کاربر فروشنده محصول است
            is_seller = False
            if hasattr(request.user, 'seller') and request.user.seller == product.seller:
                is_seller = True
            
            serializer.save(review=review, user=request.user, is_seller=is_seller)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def add_question(self, request, slug=None):
        product = self.get_object()
        serializer = ProductQuestionSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save(product=product, user=request.user)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def add_answer(self, request, slug=None):
        product = self.get_object()
        question_id = request.data.get('question_id')
        
        try:
            question = ProductQuestion.objects.get(id=question_id, product=product)
        except ProductQuestion.DoesNotExist:
            return Response(
                {'error': 'پرسش مورد نظر یافت نشد'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        serializer = ProductAnswerSerializer(data=request.data)
        if serializer.is_valid():
            # بررسی اینکه آیا کاربر فروشنده محصول است
            is_seller = False
            if hasattr(request.user, 'seller') and request.user.seller == product.seller:
                is_seller = True
            
            serializer.save(question=question, user=request.user, is_seller=is_seller)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['post'], permission_classes=[IsProductSellerOrAdmin])
    def update_inventory(self, request, slug=None):
        product = self.get_object()
        new_stock = request.data.get('stock')
        variant_id = request.data.get('variant_id')
        change_reason = request.data.get('change_reason', 'بروزرسانی دستی')
        
        with atomic():
            if variant_id:
                try:
                    variant = ProductVariant.objects.get(id=variant_id, product=product)
                    previous_stock = variant.stock
                    variant.stock = new_stock
                    variant.save()
                    
                    # ثبت لاگ تغییر موجودی
                    ProductInventoryLog.objects.create(
                        product=product,
                        variant=variant,
                        previous_stock=previous_stock,
                        new_stock=new_stock,
                        change_reason=change_reason,
                        created_by=request.user
                    )
                    
                    return Response({'status': 'موجودی تنوع به‌روزرسانی شد'})
                except ProductVariant.DoesNotExist:
                    return Response(
                        {'error': 'تنوع مورد نظر یافت نشد'},
                        status=status.HTTP_404_NOT_FOUND
                    )
            else:
                previous_stock = product.stock
                product.stock = new_stock
                product.save()
                
                # ثبت لاگ تغییر موجودی
                ProductInventoryLog.objects.create(
                    product=product,
                    previous_stock=previous_stock,
                    new_stock=new_stock,
                    change_reason=change_reason,
                    created_by=request.user
                )
                
                return Response({'status': 'موجودی محصول به‌روزرسانی شد'})
    
    @action(detail=True, methods=['post'], permission_classes=[IsProductSellerOrAdmin])
    def related_products(self, request, slug=None):
        product = self.get_object()
        related_product_ids = request.data.get('related_product_ids', [])
        
        # حذف روابط قبلی
        RelatedProduct.objects.filter(product=product).delete()
        
        # ایجاد روابط جدید
        for related_id in related_product_ids:
            try:
                related_product = Product.objects.get(id=related_id)
                RelatedProduct.objects.create(
                    product=product,
                    related_product=related_product
                )
            except Product.DoesNotExist:
                pass
        
        return Response({'status': 'محصولات مرتبط به‌روزرسانی شدند'})
    
    @action(detail=True, methods=['patch'], permission_classes=[IsAdminUser])
    def admin_approve(self, request, slug=None):
        product = self.get_object()
        product.is_approved = request.data.get('is_approved', True)
        product.save(update_fields=['is_approved'])
        return Response({'status': 'وضعیت تایید محصول به‌روزرسانی شد'})
    
    @action(detail=True, methods=['patch'], permission_classes=[IsAdminUser])
    def admin_feature(self, request, slug=None):
        product = self.get_object()
        product.is_featured = request.data.get('is_featured', True)
        product.save(update_fields=['is_featured'])
        return Response({'status': 'وضعیت ویژه بودن محصول به‌روزرسانی شد'})
    
    @action(detail=False, methods=['get'])
    def featured(self, request):
        featured_products = Product.objects.filter(is_featured=True, is_active=True, is_approved=True)
        page = self.paginate_queryset(featured_products)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(featured_products, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def best_selling(self, request):
        best_selling = Product.objects.filter(is_active=True, is_approved=True).order_by('-sales_count')
        page = self.paginate_queryset(best_selling)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(best_selling, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def new_arrivals(self, request):
        new_arrivals = Product.objects.filter(is_active=True, is_approved=True).order_by('-created_at')
        page = self.paginate_queryset(new_arrivals)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(new_arrivals, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def discounted(self, request):
        discounted = Product.objects.filter(
            is_active=True, is_approved=True, discount_price__isnull=False
        ).exclude(discount_price=0)
        
        page = self.paginate_queryset(discounted)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(discounted, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'], permission_classes=[IsSellerOwner])
    def my_products(self, request):
        products = Product.objects.filter(seller=request.user.seller)
        page = self.paginate_queryset(products)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(products, many=True)
        return Response(serializer.data)


class ProductTagViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = ProductTag.objects.all()
    serializer_class = ProductTagSerializer
    lookup_field = 'slug'
    filter_backends = [filters.SearchFilter]
    search_fields = ['name']


class ProductInventoryLogViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = ProductInventoryLogSerializer
    permission_classes = [IsProductSellerOrAdmin]
    
    def get_queryset(self):
        user = self.request.user
        
        if user.is_staff:
            return ProductInventoryLog.objects.all()
        
        if hasattr(user, 'seller'):
            return ProductInventoryLog.objects.filter(product__seller=user.seller)
        
        return ProductInventoryLog.objects.none()




from django.db import models
from django.contrib.auth import get_user_model
from django.core.validators import MinValueValidator, MaxValueValidator
from apps.common.models import BaseModel

User = get_user_model()


class Review(BaseModel):
    """Product reviews model"""
    RATING_CHOICES = [
        (1, '1 ستاره'),
        (2, '2 ستاره'),
        (3, '3 ستاره'),
        (4, '4 ستاره'),
        (5, '5 ستاره'),
    ]

    STATUS_CHOICES = [
        ('pending', 'در انتظار بررسی'),
        ('approved', 'تایید شده'),
        ('rejected', 'رد شده'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='کاربر')
    product = models.ForeignKey('products.Product', on_delete=models.CASCADE, related_name='product_detailed_reviews', verbose_name='محصول')
    order_item = models.ForeignKey('orders.OrderItem', on_delete=models.SET_NULL, null=True, blank=True, verbose_name='آیتم سفارش')
    
    rating = models.PositiveSmallIntegerField(
        choices=RATING_CHOICES,
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        verbose_name='امتیاز'
    )
    title = models.CharField(max_length=200, verbose_name='عنوان نظر')
    comment = models.TextField(verbose_name='متن نظر')
    
    # Review aspects
    quality_rating = models.PositiveSmallIntegerField(
        choices=RATING_CHOICES,
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        null=True, blank=True,
        verbose_name='امتیاز کیفیت'
    )
    value_rating = models.PositiveSmallIntegerField(
        choices=RATING_CHOICES,
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        null=True, blank=True,
        verbose_name='امتیاز ارزش خرید'
    )
    delivery_rating = models.PositiveSmallIntegerField(
        choices=RATING_CHOICES,
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        null=True, blank=True,
        verbose_name='امتیاز ارسال'
    )
    
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', verbose_name='وضعیت')
    admin_notes = models.TextField(blank=True, verbose_name='یادداشت مدیر')
    
    # Helpful votes
    helpful_count = models.PositiveIntegerField(default=0, verbose_name='تعداد مفید بودن')
    not_helpful_count = models.PositiveIntegerField(default=0, verbose_name='تعداد مفید نبودن')
    
    # Verification
    is_verified_purchase = models.BooleanField(default=False, verbose_name='خرید تایید شده')
    
    class Meta:
        verbose_name = 'نظر'
        verbose_name_plural = 'نظرات'
        ordering = ['-created_at']
        unique_together = ['user', 'product']  # One review per user per product

    def __str__(self):
        return f"{self.user.phone} - {self.product.name} - {self.rating} ستاره"

    @property
    def average_aspect_rating(self):
        """Calculate average of aspect ratings"""
        ratings = [r for r in [self.quality_rating, self.value_rating, self.delivery_rating] if r]
        return sum(ratings) / len(ratings) if ratings else self.rating

    @property
    def helpful_percentage(self):
        """Calculate helpful percentage"""
        total_votes = self.helpful_count + self.not_helpful_count
        if total_votes == 0:
            return 0
        return (self.helpful_count / total_votes) * 100

    def save(self, *args, **kwargs):
        # Check if this is a verified purchase
        if self.order_item and self.order_item.order.user == self.user:
            self.is_verified_purchase = True
        super().save(*args, **kwargs)


class ReviewImage(BaseModel):
    """Review images model"""
    review = models.ForeignKey(Review, on_delete=models.CASCADE, related_name='images', verbose_name='نظر')
    image = models.ImageField(upload_to='reviews/', verbose_name='تصویر')
    caption = models.CharField(max_length=200, blank=True, verbose_name='توضیح تصویر')

    class Meta:
        verbose_name = 'تصویر نظر'
        verbose_name_plural = 'تصاویر نظرات'

    def __str__(self):
        return f"تصویر نظر {self.review.id}"


class ReviewHelpful(BaseModel):
    """Review helpful votes model"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='کاربر')
    review = models.ForeignKey(Review, on_delete=models.CASCADE, related_name='helpful_votes', verbose_name='نظر')
    is_helpful = models.BooleanField(verbose_name='مفید است')

    class Meta:
        verbose_name = 'رای مفید بودن نظر'
        verbose_name_plural = 'آرای مفید بودن نظرات'
        unique_together = ['user', 'review']

    def __str__(self):
        return f"{self.user.phone} - {self.review.id} - {'مفید' if self.is_helpful else 'غیرمفید'}"

    def save(self, *args, **kwargs):
        # Update review helpful counts
        old_vote = None
        if self.pk:
            old_vote = ReviewHelpful.objects.get(pk=self.pk)
        
        super().save(*args, **kwargs)
        
        # Update counts
        if old_vote:
            if old_vote.is_helpful and not self.is_helpful:
                self.review.helpful_count -= 1
                self.review.not_helpful_count += 1
            elif not old_vote.is_helpful and self.is_helpful:
                self.review.helpful_count += 1
                self.review.not_helpful_count -= 1
        else:
            if self.is_helpful:
                self.review.helpful_count += 1
            else:
                self.review.not_helpful_count += 1
        
        self.review.save()

    def delete(self, *args, **kwargs):
        # Update review helpful counts
        if self.is_helpful:
            self.review.helpful_count -= 1
        else:
            self.review.not_helpful_count -= 1
        self.review.save()
        
        super().delete(*args, **kwargs)


class ReviewReply(BaseModel):
    """Seller replies to reviews"""
    review = models.OneToOneField(Review, on_delete=models.CASCADE, related_name='reply', verbose_name='نظر')
    seller = models.ForeignKey('sellers.Seller', on_delete=models.CASCADE, verbose_name='فروشنده')
    message = models.TextField(verbose_name='پیام پاسخ')

    class Meta:
        verbose_name = 'پاسخ به نظر'
        verbose_name_plural = 'پاسخ‌های نظرات'

    def __str__(self):
        return f"پاسخ به نظر {self.review.id}"


class ReviewReport(BaseModel):
    """Review reports model"""
    REPORT_REASONS = [
        ('spam', 'اسپم'),
        ('inappropriate', 'نامناسب'),
        ('fake', 'جعلی'),
        ('offensive', 'توهین‌آمیز'),
        ('irrelevant', 'غیرمرتبط'),
        ('other', 'سایر'),
    ]

    STATUS_CHOICES = [
        ('pending', 'در انتظار بررسی'),
        ('reviewed', 'بررسی شده'),
        ('resolved', 'حل شده'),
        ('dismissed', 'رد شده'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='گزارش‌دهنده')
    review = models.ForeignKey(Review, on_delete=models.CASCADE, related_name='reports', verbose_name='نظر')
    reason = models.CharField(max_length=20, choices=REPORT_REASONS, verbose_name='دلیل گزارش')
    description = models.TextField(blank=True, verbose_name='توضیحات')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', verbose_name='وضعیت')
    admin_notes = models.TextField(blank=True, verbose_name='یادداشت مدیر')

    class Meta:
        verbose_name = 'گزارش نظر'
        verbose_name_plural = 'گزارش‌های نظرات'
        unique_together = ['user', 'review']

    def __str__(self):
        return f"گزارش نظر {self.review.id} توسط {self.user.phone}"


class ReviewSummary(models.Model):
    """Review summary for products (cached data)"""
    product = models.OneToOneField('products.Product', on_delete=models.CASCADE, related_name='review_summary', verbose_name='محصول')
    
    total_reviews = models.PositiveIntegerField(default=0, verbose_name='تعداد کل نظرات')
    average_rating = models.DecimalField(max_digits=3, decimal_places=2, default=0, verbose_name='میانگین امتیاز')
    
    # Rating distribution
    rating_1_count = models.PositiveIntegerField(default=0, verbose_name='تعداد 1 ستاره')
    rating_2_count = models.PositiveIntegerField(default=0, verbose_name='تعداد 2 ستاره')
    rating_3_count = models.PositiveIntegerField(default=0, verbose_name='تعداد 3 ستاره')
    rating_4_count = models.PositiveIntegerField(default=0, verbose_name='تعداد 4 ستاره')
    rating_5_count = models.PositiveIntegerField(default=0, verbose_name='تعداد 5 ستاره')
    
    # Aspect ratings
    average_quality_rating = models.DecimalField(max_digits=3, decimal_places=2, default=0, verbose_name='میانگین امتیاز کیفیت')
    average_value_rating = models.DecimalField(max_digits=3, decimal_places=2, default=0, verbose_name='میانگین امتیاز ارزش')
    average_delivery_rating = models.DecimalField(max_digits=3, decimal_places=2, default=0, verbose_name='میانگین امتیاز ارسال')
    
    verified_purchases_percentage = models.DecimalField(max_digits=5, decimal_places=2, default=0, verbose_name='درصد خریدهای تایید شده')
    
    last_updated = models.DateTimeField(auto_now=True, verbose_name='آخرین بروزرسانی')

    class Meta:
        verbose_name = 'خلاصه نظرات'
        verbose_name_plural = 'خلاصه نظرات'

    def __str__(self):
        return f"خلاصه نظرات {self.product.name}"

    @classmethod
    def update_for_product(cls, product):
        """Update review summary for a product"""
        from django.db.models import Avg, Count, Q
        
        reviews = Review.objects.filter(product=product, status='approved')
        
        summary, created = cls.objects.get_or_create(product=product)
        
        # Basic stats
        summary.total_reviews = reviews.count()
        summary.average_rating = reviews.aggregate(avg=Avg('rating'))['avg'] or 0
        
        # Rating distribution
        summary.rating_1_count = reviews.filter(rating=1).count()
        summary.rating_2_count = reviews.filter(rating=2).count()
        summary.rating_3_count = reviews.filter(rating=3).count()
        summary.rating_4_count = reviews.filter(rating=4).count()
        summary.rating_5_count = reviews.filter(rating=5).count()
        
        # Aspect ratings
        summary.average_quality_rating = reviews.aggregate(avg=Avg('quality_rating'))['avg'] or 0
        summary.average_value_rating = reviews.aggregate(avg=Avg('value_rating'))['avg'] or 0
        summary.average_delivery_rating = reviews.aggregate(avg=Avg('delivery_rating'))['avg'] or 0
        
        # Verified purchases
        if summary.total_reviews > 0:
            verified_count = reviews.filter(is_verified_purchase=True).count()
            summary.verified_purchases_percentage = (verified_count / summary.total_reviews) * 100
        else:
            summary.verified_purchases_percentage = 0
        
        summary.save()
        return summary


from rest_framework import serializers
from .models import Review, ReviewImage, ReviewHelpful, ReviewReply, ReviewReport, ReviewSummary


class ReviewImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = ReviewImage
        fields = ['id', 'image', 'caption']


class ReviewSerializer(serializers.ModelSerializer):
    user_name = serializers.CharField(source='user.first_name', read_only=True)
    user_phone_masked = serializers.SerializerMethodField()
    product_name = serializers.CharField(source='product.name', read_only=True)
    images = ReviewImageSerializer(many=True, read_only=True)
    rating_display = serializers.CharField(source='get_rating_display', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    helpful_percentage = serializers.ReadOnlyField()
    average_aspect_rating = serializers.ReadOnlyField()

    class Meta:
        model = Review
        fields = [
            'id', 'user', 'user_name', 'user_phone_masked', 'product', 'product_name',
            'rating', 'rating_display', 'title', 'comment', 'quality_rating',
            'value_rating', 'delivery_rating', 'average_aspect_rating',
            'status', 'status_display', 'is_verified_purchase',
            'helpful_count', 'not_helpful_count', 'helpful_percentage',
            'images', 'created_at', 'updated_at'
        ]
        read_only_fields = [
            'id', 'user', 'status', 'helpful_count', 'not_helpful_count',
            'is_verified_purchase', 'created_at', 'updated_at'
        ]

    def get_user_phone_masked(self, obj):
        """Mask user phone for privacy"""
        phone = obj.user.phone
        if len(phone) > 6:
            return phone[:3] + '*' * (len(phone) - 6) + phone[-3:]
        return phone

    def validate(self, data):
        user = self.context['request'].user
        product = data.get('product')
        
        # Check if user already reviewed this product
        if Review.objects.filter(user=user, product=product).exists():
            raise serializers.ValidationError('شما قبلاً برای این محصول نظر ثبت کرده‌اید')
        
        # Check if user purchased this product
        from apps.orders.models import OrderItem
        has_purchased = OrderItem.objects.filter(
            order__user=user,
            product=product,
            order__status='delivered'
        ).exists()
        
        if not has_purchased:
            raise serializers.ValidationError('شما این محصول را خریداری نکرده‌اید')
        
        return data

    def create(self, validated_data):
        validated_data['user'] = self.context['request'].user
        
        # Find the order item for this purchase
        from apps.orders.models import OrderItem
        try:
            order_item = OrderItem.objects.filter(
                order__user=validated_data['user'],
                product=validated_data['product'],
                order__status='delivered'
            ).first()
            validated_data['order_item'] = order_item
        except:
            pass
        
        return super().create(validated_data)


class ReviewCreateSerializer(serializers.ModelSerializer):
    images = serializers.ListField(
        child=serializers.ImageField(),
        required=False,
        allow_empty=True
    )

    class Meta:
        model = Review
        fields = [
            'product', 'rating', 'title', 'comment',
            'quality_rating', 'value_rating', 'delivery_rating', 'images'
        ]

    def create(self, validated_data):
        images_data = validated_data.pop('images', [])
        validated_data['user'] = self.context['request'].user
        
        review = super().create(validated_data)
        
        # Create review images
        for image_data in images_data:
            ReviewImage.objects.create(review=review, image=image_data)
        
        return review


class ReviewHelpfulSerializer(serializers.ModelSerializer):
    class Meta:
        model = ReviewHelpful
        fields = ['id', 'review', 'is_helpful', 'created_at']
        read_only_fields = ['id', 'created_at']

    def validate(self, data):
        user = self.context['request'].user
        review = data.get('review')
        
        # Check if user already voted for this review
        if ReviewHelpful.objects.filter(user=user, review=review).exists():
            raise serializers.ValidationError('شما قبلاً برای این نظر رای داده‌اید')
        
        # Users cannot vote for their own reviews
        if review.user == user:
            raise serializers.ValidationError('نمی‌توانید برای نظر خود رای دهید')
        
        return data

    def create(self, validated_data):
        validated_data['user'] = self.context['request'].user
        return super().create(validated_data)


class ReviewReplySerializer(serializers.ModelSerializer):
    seller_name = serializers.CharField(source='seller.business_name', read_only=True)

    class Meta:
        model = ReviewReply
        fields = ['id', 'review', 'seller', 'seller_name', 'message', 'created_at']
        read_only_fields = ['id', 'seller', 'created_at']

    def validate(self, data):
        review = data.get('review')
        seller = self.context['request'].user.seller_profile
        
        # Check if seller owns the product
        if review.product.seller != seller:
            raise serializers.ValidationError('شما فقط می‌توانید به نظرات محصولات خود پاسخ دهید')
        
        # Check if reply already exists
        if hasattr(review, 'reply'):
            raise serializers.ValidationError('قبلاً به این نظر پاسخ داده‌اید')
        
        return data

    def create(self, validated_data):
        validated_data['seller'] = self.context['request'].user.seller_profile
        return super().create(validated_data)


class ReviewReportSerializer(serializers.ModelSerializer):
    reason_display = serializers.CharField(source='get_reason_display', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)

    class Meta:
        model = ReviewReport
        fields = [
            'id', 'review', 'reason', 'reason_display', 'description',
            'status', 'status_display', 'created_at'
        ]
        read_only_fields = ['id', 'status', 'created_at']

    def validate(self, data):
        user = self.context['request'].user
        review = data.get('review')
        
        # Check if user already reported this review
        if ReviewReport.objects.filter(user=user, review=review).exists():
            raise serializers.ValidationError('شما قبلاً این نظر را گزارش کرده‌اید')
        
        # Users cannot report their own reviews
        if review.user == user:
            raise serializers.ValidationError('نمی‌توانید نظر خود را گزارش کنید')
        
        return data

    def create(self, validated_data):
        validated_data['user'] = self.context['request'].user
        return super().create(validated_data)


class ReviewSummarySerializer(serializers.ModelSerializer):
    rating_distribution = serializers.SerializerMethodField()

    class Meta:
        model = ReviewSummary
        fields = [
            'total_reviews', 'average_rating', 'rating_distribution',
            'average_quality_rating', 'average_value_rating', 'average_delivery_rating',
            'verified_purchases_percentage', 'last_updated'
        ]

    def get_rating_distribution(self, obj):
        return {
            '1': obj.rating_1_count,
            '2': obj.rating_2_count,
            '3': obj.rating_3_count,
            '4': obj.rating_4_count,
            '5': obj.rating_5_count,
        }


class ReviewAdminSerializer(serializers.ModelSerializer):
    """Serializer for admin review management"""
    user_phone = serializers.CharField(source='user.phone', read_only=True)
    product_name = serializers.CharField(source='product.name', read_only=True)
    seller_name = serializers.CharField(source='product.seller.business_name', read_only=True)

    class Meta:
        model = Review
        fields = [
            'id', 'user', 'user_phone', 'product', 'product_name', 'seller_name',
            'rating', 'title', 'comment', 'status', 'admin_notes',
            'is_verified_purchase', 'helpful_count', 'not_helpful_count',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'user', 'product', 'helpful_count', 'not_helpful_count', 'created_at']

    def update(self, instance, validated_data):
        # Update review summary when status changes
        old_status = instance.status
        instance = super().update(instance, validated_data)
        
        if old_status != instance.status:
            ReviewSummary.update_for_product(instance.product)
        
        return instance



    from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register('', views.ReviewViewSet)
router.register('replies', views.ReviewReplyViewSet)
router.register('reports', views.ReviewReportViewSet)

urlpatterns = [
    path('', include(router.urls)),
]


from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter
from django.db.models import Q, Avg
from .models import Review, ReviewHelpful, ReviewReply, ReviewReport, ReviewSummary
from .serializers import (
    ReviewSerializer, ReviewCreateSerializer, ReviewHelpfulSerializer,
    ReviewReplySerializer, ReviewReportSerializer, ReviewSummarySerializer,
    ReviewAdminSerializer
)
from apps.common.pagination import StandardResultsSetPagination


class ReviewViewSet(viewsets.ModelViewSet):
    """Reviews viewset"""
    queryset = Review.objects.filter(status='approved')
    serializer_class = ReviewSerializer
    pagination_class = StandardResultsSetPagination
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['product', 'rating', 'is_verified_purchase']
    search_fields = ['title', 'comment']
    ordering_fields = ['created_at', 'rating', 'helpful_count']
    ordering = ['-created_at']

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            permission_classes = [AllowAny]
        else:
            permission_classes = [IsAuthenticated]
        return [permission() for permission in permission_classes]

    def get_serializer_class(self):
        if self.action == 'create':
            return ReviewCreateSerializer
        elif self.action in ['update', 'partial_update'] and self.request.user.is_staff:
            return ReviewAdminSerializer
        return ReviewSerializer

    def get_queryset(self):
        queryset = Review.objects.all()
        
        if not self.request.user.is_staff:
            if self.action in ['list', 'retrieve']:
                queryset = queryset.filter(status='approved')
            elif self.action in ['update', 'partial_update', 'destroy']:
                queryset = queryset.filter(user=self.request.user)
        
        # Filter by product
        product_id = self.request.query_params.get('product')
        if product_id:
            queryset = queryset.filter(product_id=product_id)
        
        # Filter by rating range
        min_rating = self.request.query_params.get('min_rating')
        max_rating = self.request.query_params.get('max_rating')
        if min_rating:
            queryset = queryset.filter(rating__gte=min_rating)
        if max_rating:
            queryset = queryset.filter(rating__lte=max_rating)
        
        return queryset

    def perform_create(self, serializer):
        review = serializer.save()
        # Update product review summary
        ReviewSummary.update_for_product(review.product)

    def perform_update(self, serializer):
        review = serializer.save()
        # Update product review summary
        ReviewSummary.update_for_product(review.product)

    def perform_destroy(self, instance):
        product = instance.product
        instance.delete()
        # Update product review summary
        ReviewSummary.update_for_product(product)

    @action(detail=False, methods=['get'])
    def my_reviews(self, request):
        """Get current user's reviews"""
        if not request.user.is_authenticated:
            return Response({'error': 'احراز هویت الزامی است'}, status=status.HTTP_401_UNAUTHORIZED)
        
        reviews = Review.objects.filter(user=request.user)
        page = self.paginate_queryset(reviews)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(reviews, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['post'])
    def vote_helpful(self, request, pk=None):
        """Vote if review is helpful or not"""
        review = self.get_object()
        is_helpful = request.data.get('is_helpful', True)
        
        # Check if user already voted
        existing_vote = ReviewHelpful.objects.filter(user=request.user, review=review).first()
        if existing_vote:
            if existing_vote.is_helpful != is_helpful:
                existing_vote.is_helpful = is_helpful
                existing_vote.save()
                return Response({'message': 'رای شما بروزرسانی شد'})
            else:
                return Response({'message': 'شما قبلاً رای داده‌اید'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Create new vote
        ReviewHelpful.objects.create(user=request.user, review=review, is_helpful=is_helpful)
        return Response({'message': 'رای شما ثبت شد'})

    @action(detail=True, methods=['post'])
    def report(self, request, pk=None):
        """Report a review"""
        review = self.get_object()
        serializer = ReviewReportSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            serializer.save(review=review)
            return Response({'message': 'گزارش شما ثبت شد'})
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=False, methods=['get'])
    def statistics(self, request):
        """Get review statistics"""
        product_id = request.query_params.get('product')
        if not product_id:
            return Response({'error': 'شناسه محصول الزامی است'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            summary = ReviewSummary.objects.get(product_id=product_id)
            serializer = ReviewSummarySerializer(summary)
            return Response(serializer.data)
        except ReviewSummary.DoesNotExist:
            # Create summary if it doesn't exist
            from apps.products.models import Product
            try:
                product = Product.objects.get(id=product_id)
                summary = ReviewSummary.update_for_product(product)
                serializer = ReviewSummarySerializer(summary)
                return Response(serializer.data)
            except Product.DoesNotExist:
                return Response({'error': 'محصول یافت نشد'}, status=status.HTTP_404_NOT_FOUND)


class ReviewReplyViewSet(viewsets.ModelViewSet):
    """Review replies viewset"""
    queryset = ReviewReply.objects.all()
    serializer_class = ReviewReplySerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        if hasattr(self.request.user, 'seller_profile'):
            return ReviewReply.objects.filter(seller=self.request.user.seller_profile)
        return ReviewReply.objects.none()


class ReviewReportViewSet(viewsets.ModelViewSet):
    """Review reports viewset (admin only)"""
    queryset = ReviewReport.objects.all()
    serializer_class = ReviewReportSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filterset_fields = ['status', 'reason']
    ordering = ['-created_at']

    def get_queryset(self):
        if self.request.user.is_staff:
            return ReviewReport.objects.all()
        return ReviewReport.objects.filter(user=self.request.user)

    @action(detail=True, methods=['post'])
    def resolve(self, request, pk=None):
        """Resolve a report (admin only)"""
        if not request.user.is_staff:
            return Response({'error': 'دسترسی محدود'}, status=status.HTTP_403_FORBIDDEN)
        
        report = self.get_object()
        action_type = request.data.get('action')  # 'dismiss', 'remove_review', 'warn_user'
        admin_notes = request.data.get('admin_notes', '')
        
        if action_type == 'dismiss':
            report.status = 'dismissed'
        elif action_type == 'remove_review':
            report.review.status = 'rejected'
            report.review.save()
            report.status = 'resolved'
        elif action_type == 'warn_user':
            # Send warning to user
            report.status = 'resolved'
        else:
            return Response({'error': 'نوع عمل نامعتبر'}, status=status.HTTP_400_BAD_REQUEST)
        
        report.admin_notes = admin_notes
        report.save()
        
        return Response({'message': 'گزارش پردازش شد'})




    from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
import uuid


class SellerStatus(models.TextChoices):
    PENDING = 'pending', _('در انتظار بررسی')
    APPROVED = 'approved', _('تایید شده')
    REJECTED = 'rejected', _('رد شده')
    SUSPENDED = 'suspended', _('تعلیق شده')


class IdentificationType(models.TextChoices):
    NATIONAL_ID = 'national_id', _('کارت ملی')
    BUSINESS_LICENSE = 'business_license', _('مجوز کسب و کار')
    BOTH = 'both', _('هر دو')


class CommissionType(models.TextChoices):
    FIXED = 'fixed', _('ثابت')
    PERCENTAGE = 'percentage', _('درصدی')
    TIERED = 'tiered', _('پلکانی')


class Seller(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='seller')
    shop_name = models.CharField(_('نام فروشگاه'), max_length=100)
    slug = models.SlugField(_('اسلاگ'), max_length=100, unique=True)
    description = models.TextField(_('توضیحات'), blank=True)
    logo = models.ImageField(_('لوگو'), upload_to='seller_logos/', blank=True, null=True)
    banner = models.ImageField(_('بنر'), upload_to='seller_banners/', blank=True, null=True)
    status = models.CharField(_('وضعیت'), max_length=20, choices=SellerStatus.choices, default=SellerStatus.PENDING)
    identification_type = models.CharField(_('نوع احراز هویت'), max_length=20, 
                                         choices=IdentificationType.choices, default=IdentificationType.NATIONAL_ID)
    identification_number = models.CharField(_('شماره شناسایی'), max_length=20, blank=True, null=True)
    identification_image = models.ImageField(_('تصویر مدرک'), upload_to='seller_identification/', blank=True, null=True)
    business_license = models.ImageField(_('تصویر مجوز کسب'), upload_to='seller_licenses/', blank=True, null=True)
    bank_account_number = models.CharField(_('شماره حساب بانکی'), max_length=26, blank=True, null=True)
    bank_sheba = models.CharField(_('شماره شبا'), max_length=26, blank=True, null=True)
    bank_card_number = models.CharField(_('شماره کارت بانکی'), max_length=16, blank=True, null=True)
    bank_name = models.CharField(_('نام بانک'), max_length=50, blank=True, null=True)
    address = models.TextField(_('آدرس'), blank=True, null=True)
    postal_code = models.CharField(_('کد پستی'), max_length=10, blank=True, null=True)
    phone_number = models.CharField(_('شماره تلفن ثابت'), max_length=11, blank=True, null=True)
    email = models.EmailField(_('ایمیل'), blank=True, null=True)
    website = models.URLField(_('وب‌سایت'), blank=True, null=True)
    instagram = models.CharField(_('اینستاگرام'), max_length=100, blank=True, null=True)
    telegram = models.CharField(_('تلگرام'), max_length=100, blank=True, null=True)
    rating = models.DecimalField(_('امتیاز'), max_digits=3, decimal_places=2, default=0)
    review_count = models.PositiveIntegerField(_('تعداد نظرات'), default=0)
    sales_count = models.PositiveIntegerField(_('تعداد فروش'), default=0)
    total_revenue = models.DecimalField(_('درآمد کل'), max_digits=15, decimal_places=0, default=0)
    commission_type = models.CharField(_('نوع کمیسیون'), max_length=20, choices=CommissionType.choices, default=CommissionType.PERCENTAGE)
    commission_value = models.DecimalField(_('مقدار کمیسیون'), max_digits=5, decimal_places=2, default=10)
    balance = models.DecimalField(_('موجودی حساب'), max_digits=15, decimal_places=0, default=0)
    is_featured = models.BooleanField(_('ویژه'), default=False)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('فروشنده')
        verbose_name_plural = _('فروشندگان')
    
    def __str__(self):
        return self.shop_name


class SellerCategory(models.Model):
    seller = models.ForeignKey(Seller, on_delete=models.CASCADE, related_name='categories')
    category = models.ForeignKey('categories.Category', on_delete=models.CASCADE, related_name='sellers')
    is_approved = models.BooleanField(_('تایید شده'), default=False)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('دسته‌بندی فروشنده')
        verbose_name_plural = _('دسته‌بندی‌های فروشنده')
        unique_together = ('seller', 'category')
    
    def __str__(self):
        return f"{self.seller.shop_name} - {self.category.name}"


class SellerReview(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    seller = models.ForeignKey(Seller, on_delete=models.CASCADE, related_name='reviews')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='seller_reviews')
    rating = models.PositiveSmallIntegerField(_('امتیاز'), choices=[(i, i) for i in range(1, 6)])
    comment = models.TextField(_('نظر'))
    is_approved = models.BooleanField(_('تایید شده'), default=False)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('نظر فروشنده')
        verbose_name_plural = _('نظرات فروشنده')
        unique_together = ('seller', 'user')
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.seller.shop_name} - {self.rating}"


class TieredCommission(models.Model):
    seller = models.ForeignKey(Seller, on_delete=models.CASCADE, related_name='tiered_commissions')
    min_sales = models.DecimalField(_('حداقل فروش'), max_digits=15, decimal_places=0)
    max_sales = models.DecimalField(_('حداکثر فروش'), max_digits=15, decimal_places=0, blank=True, null=True)
    commission_percentage = models.DecimalField(_('درصد کمیسیون'), max_digits=5, decimal_places=2)
    
    class Meta:
        verbose_name = _('کمیسیون پلکانی')
        verbose_name_plural = _('کمیسیون‌های پلکانی')
        ordering = ['min_sales']
    
    def __str__(self):
        max_sales_str = f" تا {self.max_sales}" if self.max_sales else " به بالا"
        return f"{self.seller.shop_name} - از {self.min_sales}{max_sales_str} - {self.commission_percentage}%"


class SellerWithdrawal(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    seller = models.ForeignKey(Seller, on_delete=models.CASCADE, related_name='withdrawals')
    amount = models.DecimalField(_('مبلغ'), max_digits=15, decimal_places=0)
    status_choices = [
        ('pending', _('در انتظار بررسی')),
        ('approved', _('تایید شده')),
        ('rejected', _('رد شده')),
        ('paid', _('پرداخت شده')),
    ]
    status = models.CharField(_('وضعیت'), max_length=20, choices=status_choices, default='pending')
    transaction_id = models.CharField(_('شناسه تراکنش'), max_length=100, blank=True, null=True)
    description = models.TextField(_('توضیحات'), blank=True)
    admin_note = models.TextField(_('یادداشت مدیر'), blank=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('برداشت فروشنده')
        verbose_name_plural = _('برداشت‌های فروشنده')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.seller.shop_name} - {self.amount} - {self.get_status_display()}"



from rest_framework import serializers
from django.utils.text import slugify
from django.db.models import Avg
from .models import (
    Seller, SellerCategory, SellerReview, TieredCommission, SellerWithdrawal
)
from apps.categories.serializers import CategoryListSerializer


class SellerListSerializer(serializers.ModelSerializer):
    user_full_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Seller
        fields = ('id', 'shop_name', 'slug', 'logo', 'rating', 'review_count', 
                 'sales_count', 'is_featured', 'user_full_name', 'status')
    
    def get_user_full_name(self, obj):
        return obj.user.get_full_name()


class TieredCommissionSerializer(serializers.ModelSerializer):
    class Meta:
        model = TieredCommission
        fields = ('id', 'min_sales', 'max_sales', 'commission_percentage')


class SellerCategorySerializer(serializers.ModelSerializer):
    category = CategoryListSerializer(read_only=True)
    category_id = serializers.UUIDField(write_only=True)
    
    class Meta:
        model = SellerCategory
        fields = ('id', 'category', 'category_id', 'is_approved')


class SellerReviewSerializer(serializers.ModelSerializer):
    user_full_name = serializers.SerializerMethodField()
    
    class Meta:
        model = SellerReview
        fields = ('id', 'rating', 'comment', 'user_full_name', 
                 'is_approved', 'created_at')
        read_only_fields = ('user_full_name', 'is_approved', 'created_at')
    
    def get_user_full_name(self, obj):
        return obj.user.get_full_name()


class SellerDetailSerializer(serializers.ModelSerializer):
    categories = SellerCategorySerializer(many=True, read_only=True)
    tiered_commissions = TieredCommissionSerializer(many=True, read_only=True)
    reviews = serializers.SerializerMethodField()
    
    class Meta:
        model = Seller
        fields = ('id', 'user', 'shop_name', 'slug', 'description', 'logo', 'banner',
                 'status', 'identification_type', 'identification_number',
                 'identification_image', 'business_license', 'bank_account_number',
                 'bank_sheba', 'bank_card_number', 'bank_name', 'address',
                 'postal_code', 'phone_number', 'email', 'website', 'instagram',
                 'telegram', 'rating', 'review_count', 'sales_count', 'total_revenue',
                 'commission_type', 'commission_value', 'balance', 'is_featured',
                 'created_at', 'updated_at', 'categories', 'tiered_commissions', 'reviews')
        read_only_fields = ('id', 'user', 'rating', 'review_count', 'sales_count', 
                          'total_revenue', 'balance', 'created_at', 'updated_at')
    
    def get_reviews(self, obj):
        # فقط نظرات تایید شده را برمی‌گرداند
        reviews = obj.reviews.filter(is_approved=True).order_by('-created_at')
        return SellerReviewSerializer(reviews, many=True).data


class SellerRegistrationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Seller
        fields = ('shop_name', 'description', 'logo', 'identification_type',
                 'identification_number', 'identification_image', 'business_license',
                 'bank_account_number', 'bank_sheba', 'bank_card_number',
                 'bank_name', 'address', 'postal_code', 'phone_number', 'email')
    
    def create(self, validated_data):
        user = self.context['request'].user
        
        # بررسی اینکه کاربر قبلاً فروشنده نباشد
        if hasattr(user, 'seller'):
            raise serializers.ValidationError('شما قبلاً به عنوان فروشنده ثبت‌نام کرده‌اید')
        
        # ایجاد اسلاگ یکتا
        shop_name = validated_data['shop_name']
        slug = slugify(shop_name)
        
        # بررسی یکتا بودن اسلاگ
        if Seller.objects.filter(slug=slug).exists():
            slug = f"{slug}-{user.id}"
        
        # ایجاد فروشنده
        seller = Seller.objects.create(
            user=user,
            slug=slug,
            **validated_data
        )
        
        return seller


class SellerWithdrawalSerializer(serializers.ModelSerializer):
    class Meta:
        model = SellerWithdrawal
        fields = ('id', 'amount', 'status', 'transaction_id', 'description', 
                 'admin_note', 'created_at', 'updated_at')
        read_only_fields = ('id', 'status', 'transaction_id', 'admin_note', 
                          'created_at', 'updated_at')
    
    def validate_amount(self, value):
        seller = self.context['request'].user.seller
        if value > seller.balance:
            raise serializers.ValidationError('مبلغ درخواستی بیشتر از موجودی حساب شما است')
        if value < 100000:  # حداقل مبلغ برداشت 100,000 تومان
            raise serializers.ValidationError('حداقل مبلغ برداشت 100,000 تومان است')
        return value
    
    def create(self, validated_data):
        seller = self.context['request'].user.seller
        return SellerWithdrawal.objects.create(seller=seller, **validated_data)


class AdminSellerUpdateSerializer(serializers.ModelSerializer):
    class Meta:
        model = Seller
        fields = ('status', 'commission_type', 'commission_value', 'is_featured')


class AdminSellerWithdrawalUpdateSerializer(serializers.ModelSerializer):
    class Meta:
        model = SellerWithdrawal
        fields = ('status', 'transaction_id', 'admin_note')



    from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'sellers', views.SellerViewSet)
router.register(r'categories', views.SellerCategoryViewSet, basename='seller-categories')
router.register(r'commissions', views.TieredCommissionViewSet, basename='seller-commissions')
router.register(r'withdrawals', views.SellerWithdrawalViewSet, basename='seller-withdrawals')

urlpatterns = [
    path('', include(router.urls)),
]



from rest_framework import viewsets, permissions, status, generics, filters
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db.models import Avg, Count
from django.db.transaction import atomic
from django_filters.rest_framework import DjangoFilterBackend
from .models import (
    Seller, SellerCategory, SellerReview, TieredCommission, SellerWithdrawal
)
from .serializers import (
    SellerListSerializer, SellerDetailSerializer, SellerRegistrationSerializer,
    SellerCategorySerializer, SellerReviewSerializer, TieredCommissionSerializer,
    SellerWithdrawalSerializer, AdminSellerUpdateSerializer, AdminSellerWithdrawalUpdateSerializer
)
from .permissions import IsSellerOwner, IsAdminUser


class IsSellerOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in permissions.SAFE_METHODS:
            return True
        return hasattr(request.user, 'seller')


class SellerViewSet(viewsets.ModelViewSet):
    queryset = Seller.objects.all()
    serializer_class = SellerListSerializer
    lookup_field = 'slug'
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['status', 'is_featured']
    search_fields = ['shop_name', 'description']
    ordering_fields = ['created_at', 'rating', 'sales_count']
    
    def get_permissions(self):
        if self.action == 'create':
            return [permissions.IsAuthenticated()]
        elif self.action in ['update', 'partial_update']:
            return [IsSellerOwner()]
        elif self.action == 'admin_update':
            return [IsAdminUser()]
        return [permissions.AllowAny()]
    
    def get_serializer_class(self):
        if self.action == 'create':
            return SellerRegistrationSerializer
        elif self.action in ['retrieve', 'update', 'partial_update']:
            return SellerDetailSerializer
        elif self.action == 'admin_update':
            return AdminSellerUpdateSerializer
        return SellerListSerializer
    
    def get_queryset(self):
        queryset = Seller.objects.all()
        if self.action in ['list', 'retrieve']:
            queryset = queryset.filter(status='approved')
        return queryset
    
    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])
    def add_review(self, request, slug=None):
        seller = self.get_object()
        user = request.user
        
        # بررسی اینکه کاربر قبلاً نظر نداده باشد
        if SellerReview.objects.filter(seller=seller, user=user).exists():
            return Response(
                {'error': 'شما قبلاً برای این فروشنده نظر ثبت کرده‌اید'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        serializer = SellerReviewSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save(seller=seller, user=user)
            
            # به‌روزرسانی امتیاز و تعداد نظرات فروشنده
            avg_rating = SellerReview.objects.filter(seller=seller).aggregate(Avg('rating'))['rating__avg'] or 0
            review_count = SellerReview.objects.filter(seller=seller).count()
            
            seller.rating = avg_rating
            seller.review_count = review_count
            seller.save()
            
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['get'])
    def reviews(self, request, slug=None):
        seller = self.get_object()
        reviews = SellerReview.objects.filter(seller=seller, is_approved=True)
        page = self.paginate_queryset(reviews)
        if page is not None:
            serializer = SellerReviewSerializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = SellerReviewSerializer(reviews, many=True)
        return Response(serializer.data)
    
    @action(detail=True, methods=['get'], permission_classes=[IsSellerOwner])
    def dashboard(self, request, slug=None):
        seller = self.get_object()
        
        # آمار فروش، درآمد و محصولات
        data = {
            'total_revenue': seller.total_revenue,
            'sales_count': seller.sales_count,
            'products_count': seller.products.count(),
            'balance': seller.balance,
            'rating': seller.rating,
            'review_count': seller.review_count,
            # سایر آمار مورد نیاز
        }
        
        return Response(data)
    
    @action(detail=False, methods=['get'], permission_classes=[permissions.IsAuthenticated])
    def my_shop(self, request):
        try:
            seller = request.user.seller
            serializer = SellerDetailSerializer(seller)
            return Response(serializer.data)
        except:
            return Response({'error': 'شما هنوز فروشگاهی ندارید'}, status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=False, methods=['patch'], permission_classes=[IsAdminUser])
    def admin_update(self, request, pk=None):
        seller_id = request.data.get('seller_id')
        if not seller_id:
            return Response({'error': 'شناسه فروشنده الزامی است'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            seller = Seller.objects.get(id=seller_id)
        except Seller.DoesNotExist:
            return Response({'error': 'فروشنده یافت نشد'}, status=status.HTTP_404_NOT_FOUND)
        
        serializer = AdminSellerUpdateSerializer(seller, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class SellerCategoryViewSet(viewsets.ModelViewSet):
    serializer_class = SellerCategorySerializer
    permission_classes = [IsSellerOwner]
    
    def get_queryset(self):
        return SellerCategory.objects.filter(seller=self.request.user.seller)
    
    def perform_create(self, serializer):
        serializer.save(seller=self.request.user.seller, is_approved=False)


class TieredCommissionViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = TieredCommissionSerializer
    permission_classes = [IsSellerOwner]
    
    def get_queryset(self):
        return TieredCommission.objects.filter(seller=self.request.user.seller)


class SellerWithdrawalViewSet(viewsets.ModelViewSet):
    serializer_class = SellerWithdrawalSerializer
    permission_classes = [IsSellerOwner]
    
    def get_queryset(self):
        return SellerWithdrawal.objects.filter(seller=self.request.user.seller)
    
    @atomic
    def perform_create(self, serializer):
        seller = self.request.user.seller
        amount = serializer.validated_data['amount']
        
        # کم کردن مبلغ از موجودی فروشنده
        seller.balance -= amount
        seller.save()
        
        serializer.save(seller=seller)
    
    @action(detail=True, methods=['patch'], permission_classes=[IsAdminUser])
    def admin_update(self, request, pk=None):
        withdrawal = self.get_object()
        serializer = AdminSellerWithdrawalUpdateSerializer(withdrawal, data=request.data, partial=True)
        
        if serializer.is_valid():
            # اگر درخواست رد شد، مبلغ به حساب فروشنده برگردانده شود
            if 'status' in request.data and request.data['status'] == 'rejected' and withdrawal.status != 'rejected':
                seller = withdrawal.seller
                seller.balance += withdrawal.amount
                seller.save()
            
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)



from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
import uuid


class ShippingMethod(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(_('نام روش ارسال'), max_length=100)
    description = models.TextField(_('توضیحات'), blank=True)
    cost = models.DecimalField(_('هزینه ارسال'), max_digits=15, decimal_places=0)
    is_active = models.BooleanField(_('فعال'), default=True)
    estimated_delivery_days = models.PositiveIntegerField(_('تخمین روزهای تحویل'), default=3)
    icon = models.ImageField(_('آیکون'), upload_to='shipping_icons/', blank=True, null=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('روش ارسال')
        verbose_name_plural = _('روش‌های ارسال')
        ordering = ['cost']
    
    def __str__(self):
        return f"{self.name} - {self.cost} تومان"


class ShippingZone(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(_('نام منطقه'), max_length=100)
    description = models.TextField(_('توضیحات'), blank=True)
    is_active = models.BooleanField(_('فعال'), default=True)
    
    class Meta:
        verbose_name = _('منطقه ارسال')
        verbose_name_plural = _('مناطق ارسال')
    
    def __str__(self):
        return self.name


class ShippingRate(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    shipping_method = models.ForeignKey(ShippingMethod, on_delete=models.CASCADE, related_name='rates')
    zone = models.ForeignKey(ShippingZone, on_delete=models.CASCADE, related_name='rates')
    cost = models.DecimalField(_('هزینه ارسال'), max_digits=15, decimal_places=0)
    estimated_delivery_days = models.PositiveIntegerField(_('تخمین روزهای تحویل'), default=3)
    
    class Meta:
        verbose_name = _('نرخ ارسال')
        verbose_name_plural = _('نرخ‌های ارسال')
        unique_together = ('shipping_method', 'zone')
    
    def __str__(self):
        return f"{self.shipping_method.name} - {self.zone.name} - {self.cost} تومان"


class ShippingLocation(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    zone = models.ForeignKey(ShippingZone, on_delete=models.CASCADE, related_name='locations')
    province = models.CharField(_('استان'), max_length=100)
    city = models.CharField(_('شهر'), max_length=100)
    
    class Meta:
        verbose_name = _('موقعیت ارسال')
        verbose_name_plural = _('موقعیت‌های ارسال')
        unique_together = ('zone', 'province', 'city')
    
    def __str__(self):
        return f"{self.province} - {self.city} ({self.zone.name})"


class Warehouse(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(_('نام انبار'), max_length=100)
    address = models.TextField(_('آدرس'))
    province = models.CharField(_('استان'), max_length=100)
    city = models.CharField(_('شهر'), max_length=100)
    postal_code = models.CharField(_('کد پستی'), max_length=10)
    phone = models.CharField(_('تلفن'), max_length=20)
    manager = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, 
                              related_name='managed_warehouses', null=True, blank=True)
    is_active = models.BooleanField(_('فعال'), default=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('انبار')
        verbose_name_plural = _('انبارها')
    
    def __str__(self):
        return f"{self.name} - {self.city}"


class WarehouseProduct(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    warehouse = models.ForeignKey(Warehouse, on_delete=models.CASCADE, related_name='products')
    product = models.ForeignKey('products.Product', on_delete=models.CASCADE, related_name='warehouse_stocks')
    variant = models.ForeignKey('products.ProductVariant', on_delete=models.CASCADE, 
                              related_name='warehouse_stocks', null=True, blank=True)
    stock = models.PositiveIntegerField(_('موجودی'))
    location = models.CharField(_('موقعیت در انبار'), max_length=100, blank=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('موجودی محصول در انبار')
        verbose_name_plural = _('موجودی محصولات در انبار')
        unique_together = ('warehouse', 'product', 'variant')
    
    def __str__(self):
        variant_name = f" - {self.variant.name}" if self.variant else ""
        return f"{self.warehouse.name} - {self.product.name}{variant_name} - {self.stock}"


class WarehouseTransfer(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    source_warehouse = models.ForeignKey(Warehouse, on_delete=models.CASCADE, 
                                       related_name='outgoing_transfers')
    destination_warehouse = models.ForeignKey(Warehouse, on_delete=models.CASCADE, 
                                           related_name='incoming_transfers')
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, 
                                 related_name='created_transfers')
    status_choices = [
        ('pending', _('در انتظار')),
        ('in_transit', _('در حال انتقال')),
        ('completed', _('تکمیل شده')),
        ('cancelled', _('لغو شده')),
    ]
    status = models.CharField(_('وضعیت'), max_length=20, choices=status_choices, default='pending')
    notes = models.TextField(_('یادداشت‌ها'), blank=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('انتقال بین انبار')
        verbose_name_plural = _('انتقالات بین انبار')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"انتقال از {self.source_warehouse.name} به {self.destination_warehouse.name} - {self.get_status_display()}"


class WarehouseTransferItem(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    transfer = models.ForeignKey(WarehouseTransfer, on_delete=models.CASCADE, related_name='items')
    product = models.ForeignKey('products.Product', on_delete=models.CASCADE)
    variant = models.ForeignKey('products.ProductVariant', on_delete=models.CASCADE, 
                              null=True, blank=True)
    quantity = models.PositiveIntegerField(_('تعداد'))
    
    class Meta:
        verbose_name = _('آیتم انتقال بین انبار')
        verbose_name_plural = _('آیتم‌های انتقال بین انبار')
    
    def __str__(self):
        variant_name = f" - {self.variant.name}" if self.variant else ""
        return f"{self.product.name}{variant_name} - {self.quantity}"



from rest_framework import serializers
from django.db import transaction
from .models import (
    ShippingMethod, ShippingZone, ShippingRate, ShippingLocation,
    Warehouse, WarehouseProduct, WarehouseTransfer, WarehouseTransferItem
)


class ShippingLocationSerializer(serializers.ModelSerializer):
    class Meta:
        model = ShippingLocation
        fields = ('id', 'zone', 'province', 'city')


class ShippingZoneSerializer(serializers.ModelSerializer):
    locations = ShippingLocationSerializer(many=True, read_only=True)
    
    class Meta:
        model = ShippingZone
        fields = ('id', 'name', 'description', 'is_active', 'locations')


class ShippingRateSerializer(serializers.ModelSerializer):
    zone_name = serializers.CharField(source='zone.name', read_only=True)
    
    class Meta:
        model = ShippingRate
        fields = ('id', 'shipping_method', 'zone', 'zone_name', 'cost', 'estimated_delivery_days')


class ShippingMethodSerializer(serializers.ModelSerializer):
    rates = ShippingRateSerializer(many=True, read_only=True)
    
    class Meta:
        model = ShippingMethod
        fields = ('id', 'name', 'description', 'cost', 'is_active',
                 'estimated_delivery_days', 'icon', 'created_at', 'updated_at', 'rates')
        read_only_fields = ('id', 'created_at', 'updated_at')


class WarehouseProductSerializer(serializers.ModelSerializer):
    product_name = serializers.CharField(source='product.name', read_only=True)
    variant_name = serializers.CharField(source='variant.name', read_only=True)
    
    class Meta:
        model = WarehouseProduct
        fields = ('id', 'warehouse', 'product', 'product_name', 'variant',
                 'variant_name', 'stock', 'location', 'updated_at')


class WarehouseSerializer(serializers.ModelSerializer):
    manager_name = serializers.CharField(source='manager.get_full_name', read_only=True)
    products_count = serializers.SerializerMethodField()
    
    class Meta:
        model = Warehouse
        fields = ('id', 'name', 'address', 'province', 'city', 'postal_code',
                 'phone', 'manager', 'manager_name', 'is_active', 'created_at',
                 'products_count')
        read_only_fields = ('id', 'created_at', 'products_count')
    
    def get_products_count(self, obj):
        return obj.products.count()


class WarehouseTransferItemSerializer(serializers.ModelSerializer):
    product_name = serializers.CharField(source='product.name', read_only=True)
    variant_name = serializers.CharField(source='variant.name', read_only=True)
    
    class Meta:
        model = WarehouseTransferItem
        fields = ('id', 'product', 'product_name', 'variant', 'variant_name', 'quantity')


class WarehouseTransferSerializer(serializers.ModelSerializer):
    source_warehouse_name = serializers.CharField(source='source_warehouse.name', read_only=True)
    destination_warehouse_name = serializers.CharField(source='destination_warehouse.name', read_only=True)
    created_by_name = serializers.CharField(source='created_by.get_full_name', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    items = WarehouseTransferItemSerializer(many=True, read_only=True)
    
    class Meta:
        model = WarehouseTransfer
        fields = ('id', 'source_warehouse', 'source_warehouse_name',
                 'destination_warehouse', 'destination_warehouse_name',
                 'created_by', 'created_by_name', 'status', 'status_display',
                 'notes', 'created_at', 'updated_at', 'items')
        read_only_fields = ('id', 'created_by', 'created_by_name', 'created_at', 'updated_at')
    
    def create(self, validated_data):
        items_data = self.context['request'].data.get('items', [])
        
        if not items_data:
            raise serializers.ValidationError('حداقل یک آیتم برای انتقال الزامی است')
        
        validated_data['created_by'] = self.context['request'].user
        
        with transaction.atomic():
            transfer = WarehouseTransfer.objects.create(**validated_data)
            
            for item_data in items_data:
                product_id = item_data.get('product')
                variant_id = item_data.get('variant')
                quantity = item_data.get('quantity')
                
                if not product_id or not quantity:
                    continue
                
                # بررسی موجودی در انبار مبدأ
                source_stock = WarehouseProduct.objects.filter(
                    warehouse=transfer.source_warehouse,
                    product_id=product_id,
                    variant_id=variant_id
                ).first()
                
                if not source_stock or source_stock.stock < quantity:
                    raise serializers.ValidationError(f'موجودی محصول {product_id} در انبار مبدأ کافی نیست')
                
                # ایجاد آیتم انتقال
                WarehouseTransferItem.objects.create(
                    transfer=transfer,
                    product_id=product_id,
                    variant_id=variant_id,
                    quantity=quantity
                )
        
        return transfer


class ShippingCalculatorSerializer(serializers.Serializer):
    province = serializers.CharField()
    city = serializers.CharField()
    cart_id = serializers.UUIDField()
    
    def validate(self, data):
        province = data.get('province')
        city = data.get('city')
        cart_id = data.get('cart_id')
        
        # بررسی سبد خرید
        from apps.orders.models import Cart, CartStatus
        try:
            cart = Cart.objects.get(id=cart_id, status=CartStatus.OPEN)
            data['cart'] = cart
        except Cart.DoesNotExist:
            raise serializers.ValidationError('سبد خرید نامعتبر است')
        
        # بررسی منطقه ارسال
        try:
            location = ShippingLocation.objects.get(province=province, city=city)
            data['zone'] = location.zone
        except ShippingLocation.DoesNotExist:
            # اگر موقعیت دقیق پیدا نشد، فقط استان را بررسی می‌کنیم
            try:
                location = ShippingLocation.objects.filter(province=province).first()
                if location:
                    data['zone'] = location.zone
                else:
                    # اگر استان هم پیدا نشد، از منطقه پیش‌فرض استفاده می‌کنیم
                    default_zone = ShippingZone.objects.filter(is_active=True).first()
                    if default_zone:
                        data['zone'] = default_zone
                    else:
                        raise serializers.ValidationError('منطقه ارسال برای این آدرس یافت نشد')
            except Exception:
                raise serializers.ValidationError('منطقه ارسال برای این آدرس یافت نشد')
        
        return data


from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'shipping-methods', views.ShippingMethodViewSet)
router.register(r'admin/shipping-methods', views.AdminShippingMethodViewSet, basename='admin-shipping-methods')
router.register(r'admin/shipping-zones', views.AdminShippingZoneViewSet, basename='admin-shipping-zones')
router.register(r'admin/shipping-rates', views.AdminShippingRateViewSet, basename='admin-shipping-rates')
router.register(r'admin/shipping-locations', views.AdminShippingLocationViewSet, basename='admin-shipping-locations')
router.register(r'admin/warehouses', views.WarehouseViewSet, basename='admin-warehouses')
router.register(r'admin/warehouse-products', views.WarehouseProductViewSet, basename='admin-warehouse-products')
router.register(r'admin/warehouse-transfers', views.WarehouseTransferViewSet, basename='admin-warehouse-transfers')

urlpatterns = [
    path('', include(router.urls)),
    path('calculate-shipping/', views.ShippingCalculatorView.as_view(), name='calculate-shipping'),
]


from rest_framework import viewsets, permissions, status, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db import transaction
from django.db.models import Sum, F
import uuid

from .models import (
    ShippingMethod, ShippingZone, ShippingRate, ShippingLocation,
    Warehouse, WarehouseProduct, WarehouseTransfer, WarehouseTransferItem
)
from .serializers import (
    ShippingMethodSerializer, ShippingZoneSerializer, ShippingRateSerializer,
    ShippingLocationSerializer, WarehouseSerializer, WarehouseProductSerializer,
    WarehouseTransferSerializer, WarehouseTransferItemSerializer,
    ShippingCalculatorSerializer
)
from apps.sellers.permissions import IsAdminUser


class ShippingMethodViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = ShippingMethod.objects.filter(is_active=True)
    serializer_class = ShippingMethodSerializer
    permission_classes = [permissions.AllowAny]


class ShippingCalculatorView(generics.GenericAPIView):
    serializer_class = ShippingCalculatorSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        zone = serializer.validated_data['zone']
        cart = serializer.validated_data['cart']
        
        # محاسبه مجموع وزن محصولات
        total_weight = sum(item.product.weight * item.quantity for item in cart.items.all() if item.product.weight)
        
        # محاسبه مجموع قیمت محصولات
        cart_total = sum(item.total_price for item in cart.items.all())
        
        # دریافت روش‌های ارسال مناسب برای این منطقه
        shipping_methods = []
        
        for method in ShippingMethod.objects.filter(is_active=True):
            # بررسی وجود نرخ خاص برای این منطقه
            zone_rate = ShippingRate.objects.filter(shipping_method=method, zone=zone).first()
            
            if zone_rate:
                cost = zone_rate.cost
                delivery_days = zone_rate.estimated_delivery_days
            else:
                cost = method.cost
                delivery_days = method.estimated_delivery_days
            
            # بررسی ارسال رایگان برای خریدهای بالای مبلغ خاص
            if hasattr(method, 'free_shipping_threshold') and method.free_shipping_threshold:
                if cart_total >= method.free_shipping_threshold:
                    cost = 0
            
            shipping_methods.append({
                'id': method.id,
                'name': method.name,
                'description': method.description,
                'cost': cost,
                'estimated_delivery_days': delivery_days,
                'icon': method.icon.url if method.icon else None
            })
        
        return Response({
            'shipping_methods': shipping_methods,
            'cart_total': cart_total,
            'total_weight': total_weight
        })


class AdminShippingMethodViewSet(viewsets.ModelViewSet):
    queryset = ShippingMethod.objects.all()
    serializer_class = ShippingMethodSerializer
    permission_classes = [IsAdminUser]


class AdminShippingZoneViewSet(viewsets.ModelViewSet):
    queryset = ShippingZone.objects.all()
    serializer_class = ShippingZoneSerializer
    permission_classes = [IsAdminUser]


class AdminShippingRateViewSet(viewsets.ModelViewSet):
    queryset = ShippingRate.objects.all()
    serializer_class = ShippingRateSerializer
    permission_classes = [IsAdminUser]


class AdminShippingLocationViewSet(viewsets.ModelViewSet):
    queryset = ShippingLocation.objects.all()
    serializer_class = ShippingLocationSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس منطقه
        zone_id = self.request.query_params.get('zone_id')
        if zone_id:
            queryset = queryset.filter(zone_id=zone_id)
        
        # فیلتر بر اساس استان
        province = self.request.query_params.get('province')
        if province:
            queryset = queryset.filter(province=province)
        
        return queryset


class WarehouseViewSet(viewsets.ModelViewSet):
    queryset = Warehouse.objects.all()
    serializer_class = WarehouseSerializer
    permission_classes = [IsAdminUser]


class WarehouseProductViewSet(viewsets.ModelViewSet):
    queryset = WarehouseProduct.objects.all()
    serializer_class = WarehouseProductSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس انبار
        warehouse_id = self.request.query_params.get('warehouse_id')
        if warehouse_id:
            queryset = queryset.filter(warehouse_id=warehouse_id)
        
        # فیلتر بر اساس محصول
# فیلتر بر اساس محصول
        product_id = self.request.query_params.get('product_id')
        if product_id:
            queryset = queryset.filter(product_id=product_id)
        
        # فیلتر بر اساس موجودی
        low_stock = self.request.query_params.get('low_stock')
        if low_stock:
            try:
                threshold = int(low_stock)
                queryset = queryset.filter(stock__lte=threshold)
            except ValueError:
                pass
        
        return queryset
    
    @action(detail=False, methods=['post'])
    def adjust_stock(self, request):
        warehouse_id = request.data.get('warehouse_id')
        product_id = request.data.get('product_id')
        variant_id = request.data.get('variant_id')
        quantity = request.data.get('quantity')
        reason = request.data.get('reason', 'تنظیم دستی موجودی')
        
        if not warehouse_id or not product_id or not quantity:
            return Response(
                {'error': 'انبار، محصول و تعداد الزامی هستند'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            quantity = int(quantity)
        except ValueError:
            return Response(
                {'error': 'تعداد باید عددی باشد'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        with transaction.atomic():
            # دریافت یا ایجاد رکورد موجودی انبار
            warehouse_product, created = WarehouseProduct.objects.get_or_create(
                warehouse_id=warehouse_id,
                product_id=product_id,
                variant_id=variant_id,
                defaults={'stock': 0}
            )
            
            previous_stock = warehouse_product.stock
            warehouse_product.stock += quantity
            
            if warehouse_product.stock < 0:
                return Response(
                    {'error': 'موجودی نمی‌تواند منفی باشد'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            warehouse_product.save()
            
            # ثبت لاگ تغییر موجودی
            from apps.products.models import ProductInventoryLog
            ProductInventoryLog.objects.create(
                product_id=product_id,
                variant_id=variant_id,
                previous_stock=previous_stock,
                new_stock=warehouse_product.stock,
                warehouse_id=warehouse_id,
                change_reason=reason,
                reference=f"MANUAL-{uuid.uuid4().hex[:8]}"
            )
            
            # به‌روزرسانی موجودی کلی محصول
            if variant_id:
                from apps.products.models import ProductVariant
                variant = ProductVariant.objects.get(id=variant_id)
                total_stock = WarehouseProduct.objects.filter(
                    product_id=product_id,
                    variant_id=variant_id
                ).aggregate(total=Sum('stock'))['total'] or 0
                
                variant.stock = total_stock
                variant.save()
            else:
                from apps.products.models import Product
                product = Product.objects.get(id=product_id)
                total_stock = WarehouseProduct.objects.filter(
                    product_id=product_id,
                    variant_id__isnull=True
                ).aggregate(total=Sum('stock'))['total'] or 0
                
                product.stock = total_stock
                product.save()
        
        return Response({
            'status': 'موجودی با موفقیت به‌روزرسانی شد',
            'product_id': product_id,
            'variant_id': variant_id,
            'warehouse_id': warehouse_id,
            'previous_stock': previous_stock,
            'new_stock': warehouse_product.stock,
            'change': quantity
        })


class WarehouseTransferViewSet(viewsets.ModelViewSet):
    queryset = WarehouseTransfer.objects.all().order_by('-created_at')
    serializer_class = WarehouseTransferSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس انبار مبدأ
        source_id = self.request.query_params.get('source_id')
        if source_id:
            queryset = queryset.filter(source_warehouse_id=source_id)
        
        # فیلتر بر اساس انبار مقصد
        destination_id = self.request.query_params.get('destination_id')
        if destination_id:
            queryset = queryset.filter(destination_warehouse_id=destination_id)
        
        # فیلتر بر اساس وضعیت
        status = self.request.query_params.get('status')
        if status:
            queryset = queryset.filter(status=status)
        
        return queryset
    
    @action(detail=True, methods=['post'])
    def update_status(self, request, pk=None):
        transfer = self.get_object()
        new_status = request.data.get('status')
        notes = request.data.get('notes', '')
        
        if new_status not in ['pending', 'in_transit', 'completed', 'cancelled']:
            return Response({'error': 'وضعیت نامعتبر است'}, status=status.HTTP_400_BAD_REQUEST)
        
        with transaction.atomic():
            # به‌روزرسانی وضعیت انتقال
            transfer.status = new_status
            
            if notes:
                transfer.notes = (transfer.notes + "\n\n" + notes).strip()
            
            transfer.save()
            
            # اگر انتقال تکمیل شده، موجودی انبارها را به‌روزرسانی کنیم
            if new_status == 'completed':
                for item in transfer.items.all():
                    # کاهش موجودی انبار مبدأ
                    source_product, created = WarehouseProduct.objects.get_or_create(
                        warehouse=transfer.source_warehouse,
                        product=item.product,
                        variant=item.variant,
                        defaults={'stock': 0}
                    )
                    
                    source_product.stock -= item.quantity
                    source_product.save()
                    
                    # افزایش موجودی انبار مقصد
                    dest_product, created = WarehouseProduct.objects.get_or_create(
                        warehouse=transfer.destination_warehouse,
                        product=item.product,
                        variant=item.variant,
                        defaults={'stock': 0}
                    )
                    
                    dest_product.stock += item.quantity
                    dest_product.save()
                    
                    # ثبت لاگ تغییر موجودی برای انبار مبدأ
                    from apps.products.models import ProductInventoryLog
                    ProductInventoryLog.objects.create(
                        product=item.product,
                        variant=item.variant,
                        previous_stock=source_product.stock + item.quantity,
                        new_stock=source_product.stock,
                        warehouse=transfer.source_warehouse,
                        change_reason=f'انتقال به انبار {transfer.destination_warehouse.name}',
                        reference=str(transfer.id)
                    )
                    
                    # ثبت لاگ تغییر موجودی برای انبار مقصد
                    ProductInventoryLog.objects.create(
                        product=item.product,
                        variant=item.variant,
                        previous_stock=dest_product.stock - item.quantity,
                        new_stock=dest_product.stock,
                        warehouse=transfer.destination_warehouse,
                        change_reason=f'دریافت از انبار {transfer.source_warehouse.name}',
                        reference=str(transfer.id)
                    )
            
            # اگر انتقال لغو شده، هیچ تغییری در موجودی ایجاد نمی‌کنیم
        
        return Response({'status': 'وضعیت انتقال با موفقیت به‌روزرسانی شد'})



    from django.db import models
from django.utils.translation import gettext_lazy as _
from django.conf import settings
import uuid


class Wallet(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='wallet')
    balance = models.DecimalField(_('موجودی'), max_digits=15, decimal_places=0, default=0)
    is_active = models.BooleanField(_('فعال'), default=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('کیف پول')
        verbose_name_plural = _('کیف‌های پول')
    
    def __str__(self):
        return f"کیف پول {self.user.get_full_name()}"


class TransactionType(models.TextChoices):
    DEPOSIT = 'deposit', _('واریز')
    WITHDRAWAL = 'withdrawal', _('برداشت')
    PAYMENT = 'payment', _('پرداخت')
    REFUND = 'refund', _('استرداد')
    TRANSFER = 'transfer', _('انتقال')
    REWARD = 'reward', _('پاداش')


class TransactionStatus(models.TextChoices):
    PENDING = 'pending', _('در انتظار')
    COMPLETED = 'completed', _('تکمیل شده')
    FAILED = 'failed', _('ناموفق')
    CANCELLED = 'cancelled', _('لغو شده')
    REFUNDED = 'refunded', _('مسترد شده')


class WalletTransaction(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    wallet = models.ForeignKey(Wallet, on_delete=models.CASCADE, related_name='transactions')
    amount = models.DecimalField(_('مبلغ'), max_digits=15, decimal_places=0)
    transaction_type = models.CharField(_('نوع تراکنش'), max_length=20, choices=TransactionType.choices)
    status = models.CharField(_('وضعیت'), max_length=20, choices=TransactionStatus.choices, default=TransactionStatus.PENDING)
    description = models.TextField(_('توضیحات'), blank=True)
    reference_id = models.CharField(_('شناسه مرجع'), max_length=100, blank=True, null=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    updated_at = models.DateTimeField(_('تاریخ به‌روزرسانی'), auto_now=True)
    
    class Meta:
        verbose_name = _('تراکنش کیف پول')
        verbose_name_plural = _('تراکنش‌های کیف پول')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.get_transaction_type_display()} {self.amount} - {self.wallet.user.get_full_name()}"


class WalletTransfer(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    sender = models.ForeignKey(Wallet, on_delete=models.CASCADE, related_name='sent_transfers')
    receiver = models.ForeignKey(Wallet, on_delete=models.CASCADE, related_name='received_transfers')
    amount = models.DecimalField(_('مبلغ'), max_digits=15, decimal_places=0)
    status = models.CharField(_('وضعیت'), max_length=20, choices=TransactionStatus.choices, default=TransactionStatus.COMPLETED)
    description = models.TextField(_('توضیحات'), blank=True)
    created_at = models.DateTimeField(_('تاریخ ایجاد'), auto_now_add=True)
    
    class Meta:
        verbose_name = _('انتقال کیف پول')
        verbose_name_plural = _('انتقال‌های کیف پول')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"انتقال {self.amount} از {self.sender.user.get_full_name()} به {self.receiver.user.get_full_name()}"

    from rest_framework import serializers
from django.db import transaction
from .models import Wallet, WalletTransaction, WalletTransfer, TransactionType, TransactionStatus


class WalletSerializer(serializers.ModelSerializer):
    user_full_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Wallet
        fields = ('id', 'user', 'user_full_name', 'balance', 'is_active', 'created_at', 'updated_at')
        read_only_fields = fields
    
    def get_user_full_name(self, obj):
        return obj.user.get_full_name()


class WalletTransactionSerializer(serializers.ModelSerializer):
    transaction_type_display = serializers.CharField(source='get_transaction_type_display', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    
    class Meta:
        model = WalletTransaction
        fields = ('id', 'wallet', 'amount', 'transaction_type', 'transaction_type_display',
                 'status', 'status_display', 'description', 'reference_id', 'created_at')
        read_only_fields = fields


class WalletTransferSerializer(serializers.ModelSerializer):
    sender_name = serializers.SerializerMethodField()
    receiver_name = serializers.SerializerMethodField()
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    
    class Meta:
        model = WalletTransfer
        fields = ('id', 'sender', 'sender_name', 'receiver', 'receiver_name',
                 'amount', 'status', 'status_display', 'description', 'created_at')
        read_only_fields = ('id', 'sender', 'sender_name', 'status', 'status_display', 'created_at')
    
    def get_sender_name(self, obj):
        return obj.sender.user.get_full_name()
    
    def get_receiver_name(self, obj):
        return obj.receiver.user.get_full_name()


class TransferRequestSerializer(serializers.Serializer):
    receiver_id = serializers.CharField()
    amount = serializers.DecimalField(max_digits=15, decimal_places=0)
    description = serializers.CharField(required=False, allow_blank=True)
    
    def validate_amount(self, value):
        if value <= 0:
            raise serializers.ValidationError('مبلغ باید بزرگتر از صفر باشد')
        return value
    
    def validate(self, data):
        receiver_id = data.get('receiver_id')
        amount = data.get('amount')
        
        # بررسی وجود کیف پول گیرنده
        try:
            receiver_wallet = Wallet.objects.get(user__id=receiver_id, is_active=True)
            data['receiver_wallet'] = receiver_wallet
        except Wallet.DoesNotExist:
            raise serializers.ValidationError('کیف پول گیرنده یافت نشد یا غیرفعال است')
        
        # بررسی کافی بودن موجودی فرستنده
        sender_wallet = self.context['request'].user.wallet
        if sender_wallet.balance < amount:
            raise serializers.ValidationError('موجودی کیف پول شما کافی نیست')
        
# اطمینان از اینکه کاربر به خودش انتقال نمی‌دهد
        if sender_wallet.user.id == receiver_wallet.user.id:
            raise serializers.ValidationError('نمی‌توانید به کیف پول خودتان انتقال دهید')
        
        data['sender_wallet'] = sender_wallet
        return data
    
    @transaction.atomic
    def create(self, validated_data):
        sender_wallet = validated_data['sender_wallet']
        receiver_wallet = validated_data['receiver_wallet']
        amount = validated_data['amount']
        description = validated_data.get('description', '')
        
        # کاهش موجودی فرستنده
        sender_wallet.balance -= amount
        sender_wallet.save()
        
        # افزایش موجودی گیرنده
        receiver_wallet.balance += amount
        receiver_wallet.save()
        
        # ثبت تراکنش برای فرستنده
        sender_transaction = WalletTransaction.objects.create(
            wallet=sender_wallet,
            amount=amount,
            transaction_type=TransactionType.TRANSFER,
            status=TransactionStatus.COMPLETED,
            description=f"انتقال به {receiver_wallet.user.get_full_name()}: {description}"
        )
        
        # ثبت تراکنش برای گیرنده
        receiver_transaction = WalletTransaction.objects.create(
            wallet=receiver_wallet,
            amount=amount,
            transaction_type=TransactionType.DEPOSIT,
            status=TransactionStatus.COMPLETED,
            description=f"دریافت از {sender_wallet.user.get_full_name()}: {description}"
        )
        
        # ثبت انتقال
        transfer = WalletTransfer.objects.create(
            sender=sender_wallet,
            receiver=receiver_wallet,
            amount=amount,
            description=description
        )
        
        return transfer


class WithdrawalRequestSerializer(serializers.Serializer):
    amount = serializers.DecimalField(max_digits=15, decimal_places=0)
    bank_account = serializers.CharField()
    description = serializers.CharField(required=False, allow_blank=True)
    
    def validate_amount(self, value):
        if value <= 0:
            raise serializers.ValidationError('مبلغ باید بزرگتر از صفر باشد')
        
        # حداقل مبلغ برداشت
        if value < 50000:
            raise serializers.ValidationError('حداقل مبلغ برداشت 50,000 تومان است')
        
        return value
    
    def validate(self, data):
        amount = data.get('amount')
        
        # بررسی کافی بودن موجودی
        wallet = self.context['request'].user.wallet
        if wallet.balance < amount:
            raise serializers.ValidationError('موجودی کیف پول شما کافی نیست')
        
        return data
    
    @transaction.atomic
    def create(self, validated_data):
        wallet = self.context['request'].user.wallet
        amount = validated_data['amount']
        bank_account = validated_data['bank_account']
        description = validated_data.get('description', '')
        
        # کاهش موجودی کیف پول
        wallet.balance -= amount
        wallet.save()
        
        # ثبت تراکنش برداشت
        transaction = WalletTransaction.objects.create(
            wallet=wallet,
            amount=amount,
            transaction_type=TransactionType.WITHDRAWAL,
            status=TransactionStatus.PENDING,
            description=f"درخواست برداشت به شماره حساب {bank_account}: {description}"
        )
        
        return transaction


    from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'wallet', views.WalletViewSet, basename='wallet')
router.register(r'admin/wallets', views.AdminWalletViewSet, basename='admin-wallet')
router.register(r'admin/transactions', views.AdminWalletTransactionViewSet, basename='admin-transaction')
router.register(r'admin/transfers', views.AdminWalletTransferViewSet, basename='admin-transfer')

urlpatterns = [
    path('', include(router.urls)),
]


from rest_framework import viewsets, permissions, status, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db import transaction
from django.db.models import Sum
from django.utils import timezone
import uuid

from .models import Wallet, WalletTransaction, WalletTransfer, TransactionType, TransactionStatus
from .serializers import (
    WalletSerializer, WalletTransactionSerializer, WalletTransferSerializer,
    TransferRequestSerializer, WithdrawalRequestSerializer
)
from apps.sellers.permissions import IsAdminUser


class WalletViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = WalletSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        return Wallet.objects.filter(user=self.request.user)
    
    def get_object(self):
        # ایجاد کیف پول در صورت عدم وجود
        wallet, created = Wallet.objects.get_or_create(user=self.request.user)
        return wallet
    
    @action(detail=False, methods=['get'])
    def balance(self, request):
        wallet = self.get_object()
        return Response({'balance': wallet.balance})
    
    @action(detail=False, methods=['get'])
    def transactions(self, request):
        wallet = self.get_object()
        transactions = wallet.transactions.all().order_by('-created_at')
        
        # فیلتر بر اساس نوع تراکنش
        transaction_type = request.query_params.get('type')
        if transaction_type:
            transactions = transactions.filter(transaction_type=transaction_type)
        
        # فیلتر بر اساس وضعیت
        status = request.query_params.get('status')
        if status:
            transactions = transactions.filter(status=status)
        
        # فیلتر بر اساس تاریخ
        start_date = request.query_params.get('start_date')
        end_date = request.query_params.get('end_date')
        
        if start_date:
            transactions = transactions.filter(created_at__gte=start_date)
        if end_date:
            transactions = transactions.filter(created_at__lte=end_date)
        
        # صفحه‌بندی
        page = self.paginate_queryset(transactions)
        if page is not None:
            serializer = WalletTransactionSerializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = WalletTransactionSerializer(transactions, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def transfers(self, request):
        wallet = self.get_object()
        transfers = WalletTransfer.objects.filter(
            sender=wallet
        ) | WalletTransfer.objects.filter(
            receiver=wallet
        )
        transfers = transfers.order_by('-created_at')
        
        # صفحه‌بندی
        page = self.paginate_queryset(transfers)
        if page is not None:
            serializer = WalletTransferSerializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = WalletTransferSerializer(transfers, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['post'])
    def transfer(self, request):
        serializer = TransferRequestSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            transfer = serializer.save()
            return Response(WalletTransferSerializer(transfer).data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=False, methods=['post'])
    def withdraw(self, request):
        serializer = WithdrawalRequestSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            transaction = serializer.save()
            return Response(WalletTransactionSerializer(transaction).data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=False, methods=['get'])
    def summary(self, request):
        wallet = self.get_object()
        
        # محاسبه مجموع تراکنش‌ها بر اساس نوع
        deposits = wallet.transactions.filter(
            transaction_type=TransactionType.DEPOSIT,
            status=TransactionStatus.COMPLETED
        ).aggregate(total=Sum('amount'))['total'] or 0
        
        withdrawals = wallet.transactions.filter(
            transaction_type=TransactionType.WITHDRAWAL,
            status=TransactionStatus.COMPLETED
        ).aggregate(total=Sum('amount'))['total'] or 0
        
        payments = wallet.transactions.filter(
            transaction_type=TransactionType.PAYMENT,
            status=TransactionStatus.COMPLETED
        ).aggregate(total=Sum('amount'))['total'] or 0
        
        refunds = wallet.transactions.filter(
            transaction_type=TransactionType.REFUND,
            status=TransactionStatus.COMPLETED
        ).aggregate(total=Sum('amount'))['total'] or 0
        
        # محاسبه تعداد تراکنش‌ها
        transaction_count = wallet.transactions.count()
        
        # محاسبه تراکنش‌های اخیر
        recent_transactions = wallet.transactions.order_by('-created_at')[:5]
        
        return Response({
            'balance': wallet.balance,
            'deposits': deposits,
            'withdrawals': withdrawals,
            'payments': payments,
            'refunds': refunds,
            'transaction_count': transaction_count,
            'recent_transactions': WalletTransactionSerializer(recent_transactions, many=True).data
        })


class AdminWalletViewSet(viewsets.ModelViewSet):
    queryset = Wallet.objects.all()
    serializer_class = WalletSerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=True, methods=['post'])
    def adjust_balance(self, request, pk=None):
        wallet = self.get_object()
        amount = request.data.get('amount')
        reason = request.data.get('reason', 'تنظیم توسط مدیر')
        
        if not amount:
            return Response({'error': 'مبلغ الزامی است'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            amount = int(amount)
        except ValueError:
            return Response({'error': 'مبلغ باید عددی باشد'}, status=status.HTTP_400_BAD_REQUEST)
        
        with transaction.atomic():
            # به‌روزرسانی موجودی کیف پول
            previous_balance = wallet.balance
            wallet.balance += amount
            wallet.save()
            
            # ثبت تراکنش
            if amount > 0:
                transaction_type = TransactionType.DEPOSIT
                description = f"افزایش موجودی توسط مدیر: {reason}"
            else:
                transaction_type = TransactionType.WITHDRAWAL
                description = f"کاهش موجودی توسط مدیر: {reason}"
                amount = abs(amount)
            
            WalletTransaction.objects.create(
                wallet=wallet,
                amount=amount,
                transaction_type=transaction_type,
                status=TransactionStatus.COMPLETED,
                description=description,
                reference_id=f"ADMIN-{uuid.uuid4().hex[:8]}"
            )
        
        return Response({
            'status': 'موجودی با موفقیت تنظیم شد',
            'previous_balance': previous_balance,
            'new_balance': wallet.balance,
            'change': amount
        })
    
    @action(detail=True, methods=['post'])
    def process_withdrawal(self, request, pk=None):
        wallet = self.get_object()
        transaction_id = request.data.get('transaction_id')
        action = request.data.get('action')  # 'approve' یا 'reject'
        note = request.data.get('note', '')
        
        if not transaction_id or not action:
            return Response({'error': 'شناسه تراکنش و عملیات الزامی هستند'}, status=status.HTTP_400_BAD_REQUEST)
        
        if action not in ['approve', 'reject']:
            return Response({'error': 'عملیات باید یکی از مقادیر "approve" یا "reject" باشد'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            transaction = WalletTransaction.objects.get(
                id=transaction_id,
                wallet=wallet,
                transaction_type=TransactionType.WITHDRAWAL,
                status=TransactionStatus.PENDING
            )
        except WalletTransaction.DoesNotExist:
            return Response({'error': 'تراکنش مورد نظر یافت نشد'}, status=status.HTTP_404_NOT_FOUND)
        
        with transaction.atomic():
            if action == 'approve':
                # تایید برداشت
                transaction.status = TransactionStatus.COMPLETED
                transaction.description += f" | تایید شده: {note}"
                transaction.save()
                
                return Response({'status': 'درخواست برداشت با موفقیت تایید شد'})
            else:
                # رد برداشت و برگشت وجه
                transaction.status = TransactionStatus.CANCELLED
                transaction.description += f" | رد شده: {note}"
                transaction.save()
                
                # برگشت وجه به کیف پول
                wallet.balance += transaction.amount
                wallet.save()
                
                # ثبت تراکنش برگشت وجه
                WalletTransaction.objects.create(
                    wallet=wallet,
                    amount=transaction.amount,
                    transaction_type=TransactionType.DEPOSIT,
                    status=TransactionStatus.COMPLETED,
                    description=f"برگشت وجه برداشت رد شده: {note}",
                    reference_id=str(transaction.id)
                )
                
                return Response({'status': 'درخواست برداشت رد شد و وجه به کیف پول برگشت داده شد'})


class AdminWalletTransactionViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = WalletTransaction.objects.all().order_by('-created_at')
    serializer_class = WalletTransactionSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس کاربر
        user_id = self.request.query_params.get('user_id')
        if user_id:
            queryset = queryset.filter(wallet__user__id=user_id)
        
        # فیلتر بر اساس نوع تراکنش
        transaction_type = self.request.query_params.get('type')
        if transaction_type:
            queryset = queryset.filter(transaction_type=transaction_type)
        
        # فیلتر بر اساس وضعیت
        status = self.request.query_params.get('status')
        if status:
            queryset = queryset.filter(status=status)
        
        # فیلتر بر اساس تاریخ
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        
        if start_date:
            queryset = queryset.filter(created_at__gte=start_date)
        if end_date:
            queryset = queryset.filter(created_at__lte=end_date)
        
        return queryset


class AdminWalletTransferViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = WalletTransfer.objects.all().order_by('-created_at')
    serializer_class = WalletTransferSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # فیلتر بر اساس فرستنده
        sender_id = self.request.query_params.get('sender_id')
        if sender_id:
            queryset = queryset.filter(sender__user__id=sender_id)
        
        # فیلتر بر اساس گیرنده
        receiver_id = self.request.query_params.get('receiver_id')
        if receiver_id:
            queryset = queryset.filter(receiver__user__id=receiver_id)
        
        # فیلتر بر اساس تاریخ
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        
        if start_date:
            queryset = queryset.filter(created_at__gte=start_date)
        if end_date:
            queryset = queryset.filter(created_at__lte=end_date)
        
        return queryset